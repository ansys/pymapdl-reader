[{"objectID":"Home","href":"api/full.html#full-file-class","title":"Full File Class","text":"Full File Class\n\n\n\nclass ansys.mapdl.reader.full.FullFile(filename: str | Path)\n\nStores the results of an ANSYS full file.\n\nParameters\n\nfilename (str) – Filename of the full file to read.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full)\nPyMAPDL-Reader : MAPDL Full File\nTitle                    : Demo\nVersion                  : 20.1\nPlatform                 : WINDOWS x64\nJobname                  : file\nMatrices                 : 2\nEquations                : 345\nNodes                    : 115\nDegrees of Freedom       : 3\n\n\n\nproperty const\n\nConstrained DOF\nReturns the node number and DOF constrained in ANSYS.\n\nExamples\n\n>>> full.const\narray([], shape=(0, 2), dtype=int32)\n\n\n\nproperty dof_ref\n\nSorted degree of freedom reference.\n\nExamples\n\n>>> full.dof_ref\narray([[  1,   0],\n       [  1,   1],\n       [  1,   2],\n       [115,   0],\n       [115,   1],\n       [115,   2]], dtype=int32)\n\nNotes\n\nObtain the unsorted degree of freedom reference with\n>>> dof_ref, k, m = sparse_full.load_km(sort=False)\n\n\n\nproperty filename\n\nString form of the filename. This property is read-only.\n\n\n\nproperty k\n\nStiffness Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full.k)\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 7002 stored elements in Compressed Sparse Column format>\n\n\n\nload_km(as_sparse=True, sort=False)\n\nLoad and construct mass and stiffness matrices from an\nANSYS full file.\n\nParameters\n\nas_sparse (bool, optional) – Outputs the mass and stiffness matrices as scipy csc\nsparse arrays when True by default.\n\nsort (bool, optional) – Rearranges the k and m matrices such that the rows\ncorrespond to to the sorted rows and columns in dor_ref.\nAlso sorts dor_ref.\n\nReturns\n\ndof_ref ((n x 2) np.int32 array) – This array contains the node and degree corresponding to\neach row and column in the mass and stiffness matrices.\nIn a 3 DOF analysis the dof integers will correspond to:\n0 - x\n1 - y\n2 - z\nSort these values by node number and DOF by enabling the\nsort parameter.\n\nk ((n x n) np.float_ or scipy.csc array) – Stiffness array\n\nm ((n x n) np.float_ or scipy.csc array) – Mass array\n\nExamples\n\n>>> dof_ref, k, m = full.load_km()\n>>> print(k)\n(0, 0)       163408119.6581276\n(0, 1)               0.0423270\n(1, 1)       163408119.6581276\n:       :\n(342, 344)     6590544.8717949\n(343, 344)    -6590544.8717950\n(344, 344)    20426014.9572689\n\nNotes\n\nConstrained entries are removed from the mass and stiffness\nmatrices.\n\nConstrained DOF can be accessed from const, which returns\nthe node number and DOF constrained in ANSYS.\n\n\n\nproperty load_vector\n\nThe load vector\n\nExamples\n\n>>> full.load_vector\narray([0., 0., 0., ..., 0., 0., 0.])\n\n\n\nproperty m\n\nMass Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> full.m\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 2883 stored elements in Compressed Sparse Column format>\n\n\n\nproperty neqn\n\nNumber of equations\n\nExamples\n\n>>> full.neqn\n963\n\n\n\nproperty pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"examples/00-read_binary/load_shaft_result.html#shaft-modal-analysis","title":"Shaft Modal Analysis","text":"Shaft Modal Analysis\n\nVisualize a shaft modal analysis\n\nMesh is stored within the result object\n\n…and contains a VTK unstructured grid\n\nPlot the shaft\n\n\n\nPlot a node component\n\nThis camera angle was saved interactively from shaft.plot\n\n\n\nPlot a node component as a wireframe:\n\n\n\nPlot the shaft with edges and with a blue color:\n\n\n\nPlot the shaft without lighting but with edges and with a blue color:\n\n\n\nPlot a mode shape without contours using the “bwr” color map:\n\n\n\nPlot a mode shape with contours and the default colormap:\n\n\n\nAnimate a mode of a component the shaft\n\nSet loop==True to plot continuously.\nDisable movie_filename and increase n_frames for a smoother plot\n\n\n\nTotal running time of the script: (0 minutes 6.411 seconds)\n\n\n\nDownload Jupyter notebook: load_shaft_result.ipynb\n\nDownload Python source code: load_shaft_result.py\n\nDownload zipped: load_shaft_result.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"api/misc.html#miscellaneous-classes","title":"Miscellaneous Classes","text":"Miscellaneous Classes\n\n\n\nclass ansys.mapdl.reader.Report(additional=None, ncol=3, text_width=79, sort=False, gpu=True)\n\nGenerate an environment and software report.\n\nParameters\n\nadditional (list(ModuleType), list(str)) – List of packages or package names to add to output information.\n\nncol (int, optional) – Number of package-columns in html table; only has effect if\nmode='HTML' or mode='html'. Defaults to 3.\n\ntext_width (int, optional) – The text width for non-HTML display modes.\n\nsort (bool, optional) – Alphabetically sort the packages.\n\ngpu (bool, optional) – Gather information about the GPU. Defaults to True but if\nexperiencing rendering issues, pass False to safely\ngenerate a report.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> print(pymapdl_reader.Report())\n-----------------------------------------------------------------\nPyMAPDL-Reader Software and Environment Report\n-----------------------------------------------------------------\n  Date: Sat Jun 19 14:52:00 2021 MDT\n|\n                OS : Linux\n            CPU(s) : 16\n           Machine : x86_64\n      Architecture : 64bit\n               RAM : 62.8 GiB\n       Environment : Python\nNVIDIA Corporation : GPU Vendor\nNVIDIA Quadro P2000/PCIe/SSE2 : GPU Renderer\n4.5.0 NVIDIA 465.27 : GPU Version\n|\n  Python 3.8.5 (default, May 27 2021, 13:30:53)  [GCC 9.3.0]\n|\n           pyvista : 0.31.1\n               vtk : 9.0.1\n             numpy : 1.20.3\n           appdirs : 1.4.4\nansys.mapdl.reader : 0.51.dev0\n              tqdm : 4.61.1\n        matplotlib : 3.4.2\n  ansys.mapdl.core : 0.59.dev0\n             scipy : 1.6.3\n-----------------------------------------------------------------"},{"objectID":"Home","href":"api/cyclic_result.html#cyclic-result-class","title":"Cyclic Result Class","text":"Cyclic Result Class\n\n\n\nclass ansys.mapdl.reader.cyclic_reader.CyclicResult(filename, read_mesh: bool = True)\n\nAdds cyclic functionality to the result class\n\n\n\nanimate_nodal_displacement(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )\n\n\n\nanimate_nodal_solution(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )\n\n\n\nproperty full_rotor\n\nUnstructuredGrid of the full replicated rotor\n\n\n\nharmonic_index_to_cumulative(hindex, mode)\n\nConverts a harmonic index and a 0 index mode number to a\ncumulative result index.\n\nHarmonic indices are stored as positive and negative pairs for\nmodes other than 0 and N/nsectors.\n\nParameters\n\nhindex (int) – Harmonic index.  Must be less than or equal to nsectors/2.\nMay be positive or negative\n\nmode (int) – Mode number.  0 based indexing.  Access mode pairs by with\na negative/positive harmonic index.\n\nReturns\n\nrnum – Cumulative index number.  Zero based indexing.\n\nReturn type\n\nint\n\n\n\nproperty harmonic_indices\n\nHarmonic indices of the result file.\n\nHarmonic index is simply the Nodal Diameter of the mode.  This\nis defined as the number of complete sine waves that pass\nthrough the circumference.\n\nExamples\n\n>>> rst.harmonic_indices\narray([ 0,  0,  0,  0,  0,  0, -1,  1, -1,  1,  1, -1,\n       -2,  2, -2,  2, -2,  2,  3,  3,  3,  3,  3,  3], dtype=int32)\n\n\n\nproperty mode_table\n\nUnique modes for cyclic results\n\n\n\nnodal_displacement(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1).\n\n\n\nnodal_elastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in radians.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nelastic_strain (numpy.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> nnum, elastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_plastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component plastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nplastic_strain (numpy.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first result.\n\n>>> nnum, plastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_solution(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1).\n\n\n\nnodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at Sx Sy Sz Sxy Syz Sxz averaged at each corner\nnode.  For the corresponding node numbers, see where\nresult is the result object.\n\nExamples\n\n>>> nnum, stress = rst.nodal_stress(0)\n\nNotes\n\nNodes without a stress value will be NAN.\n\n\n\nnodal_temperature(rnum, full_rotor=False)\n\nRetrieves the temperature for each node in the solution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL commands:\nPRNSOL, TEMP\nPRNSOL, BFE\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> nnum, stress = rst.nodal_temperature(0)\n\n\n\nnodal_thermal_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component thermal strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV, and eswell\n(element swelling strain).  Thermal strains are always values\nat the integration points moved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first result.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nplot(**kwargs)\n\nPlot the full rotor geometry.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot()\n\nSave a screenshot of the rotor\n\n>>> rst.plot(screenshot='rotor.png')\n\n\n\nplot_nodal_elastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal elastic strain for an academic rotor.\n\n>>> result.plot_nodal_elastic_strain(0, 'X')\n\n\n\nplot_nodal_plastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal plastic strain for an academic rotor\n\n>>> result.plot_nodal_plastic_strain(0)\n\n\n\nplot_nodal_solution(rnum, comp='norm', phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal solution (generally displacement).\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are ‘x’, ‘y’, ‘z’,\nand ‘norm’, corresponding to the x direction, y direction,\nz direction, and the normalized direction:\n(x**2 + y**2 + z**2)**0.5\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the displacement of the first cyclic result.\n\n>>> result.plot_nodal_solution(0)\n\n\n\nplot_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal stress of a given component\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the \"Z\" nodal stress of the first cyclic result.\n\n>>> result.plot_nodal_stress(0, comp=\"Z\")\n\n\n\nplot_nodal_temperature(rnum, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, overlay_wireframe=False, add_text=True, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal temperature.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand the sector solution and plot the full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal temperature of a rotor for the first result.\n\n>>> result.plot_nodal_temperature(0)\n\n\n\nplot_nodal_thermal_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal thermal strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\" (element swelling strain)\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0.\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal thermal strain for an academic rotor\n\n>>> rst.plot_nodal_thermal_strain(0)\n\n\n\nplot_principal_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the von Mises stress of the first cyclic result.\n\n>>> result.plot_principal_nodal_stress(0, comp='SEQV')\n\n\n\nplot_sectors(**kwargs)\n\nPlot the full rotor and individually color the sectors.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot_sectors()\n\nSave a screenshot of the sectors\n\n>>> rst.plot_sectors(screenshot='sectors.png')\n\n\n\nprincipal_nodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\n\n\nsave_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True, expand_cyclic=True, merge_sectors=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nexpand_cyclic (bool, default: True.) – When True, expands cyclic results by writing out the result as\na full cyclic result rather than as a single cyclic sector.\n\nmerge_sectors (bool, default: False) – When expand_cyclic is True and this parameter is True,\nsectors will be merged to create one unified grid. Set this to\nFalse to not merge nodes between sectors.\n\nNotes\n\nNodal solutions are stored within the point_data attribute of the\nunstructured grid and can be accessed after reading in the result with\npyvista with:\n\nSee the examples section for more details.\n\nExamples\n\nWrite nodal results as a binary vtk file. Larger file size, loads quickly.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer. This file is more compressed compressed but\nwill load slower.\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\nRead in the results using pyvista.read(). Plot the ‘Z’ component of\nthe first mode’s -2 nodal diameter nodal displacement.\n\n>>> import pyvista as pv\n>>> grid = pv.read('results.vtk')\n>>> grid.plot(scalars=\"Nodal solution (0, -2)\", component=2)\n\nDo not merge sectors when saving the results and separate sectors into\nmultiple blocks within pyvista.\n\n>>> rst.save_as_vtk('results.vtk', merge_sectors=False)\n>>> grid = pv.read('results.vtk')\n>>> mblock = grid.split_bodies()"},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_stress_strain.html#stress-and-strain-from-a-cyclic-modal-analysis","title":"Stress and Strain from a Cyclic Modal Analysis","text":"Stress and Strain from a Cyclic Modal Analysis\n\nThis example shows how to extract strain and stress from a cyclic\nmodal analysis.\n\nDownload the academic modal analysis file\n\nPlot nodal displacement for result (2, 2), which corresponds to\nthe load step and sub step in fortran indexing.  You could have also\nused the python cumulative index 3.\nrotor._positive_cyclic_dir = True\n\n\n\nExtract the nodal elastic strain for the fourth cumulative result.\nBecause pymapdl-reader uses zero based indexing, we have to input “3” here.\n\nDepending on the version of ANSYS, MAPDL either does or does not\nwrite the duplicate sector for a result.  If MAPDL does not write a\nduplicate sector, pymapdl-reader will search for a duplicate mode and use\nthat as the duplicate sector in order to be able to expand to the\nfull rotor.  Regardless of if there is or isn’t a duplicate sector,\nonly the master sector will be output.\n\nCyclic results extracted from pymapdl-reader may disagree with MAPDL\ndue to several issues/variations when extracting cyclic results\nwithin MAPDL using PowerGraphics.  By default, MAPDL uses\n\\EDGE,,,45, which disables averaging across surface features\nthat exceed 45 degrees, but only writes one value when outputting\nwith PRNSOL.  On the other hand pymapdl-reader always averages,\nso you will see differences between MAPDL and pymapdl-reader in\nthese cases.\n\nPlot the nodal elastic strain in the “Z” direction for result (5, 2).\n\npymapdl-reader can plot the displacements while also plotting the\nstress/strain.  Since modal results may or may not be normalized,\nyou will have to adjust the displacement_factor to scale up or\ndown the displacement to get a reasonable looking result.  Disable\nplotting the displacement by setting show_displacement=False.\n\nAdditionally, you can also save screenshots by setting\nscreenshot to a filename with\nscreenshot='elastic_strain.png'.  If you wish to do this without\nmanually closing the plotting screen, set off_screen=True.  This\ncan help you automate saving screenshots.\n\n\n\nPlot the nodal elastic stress in the “Z” direction for this rotor.\nSince this is plotting the other pair of modes for the 5th loadstep,\nthe displacement of this response is 90 degrees out of phase of\nresult (5, 2)\n\nAvailable stress components are ['Y', 'Z', 'XY', 'YZ', 'XZ']\n\n\n\nYou can also plot the nodal von mises principal stress.  This plot\nshows the principal stress for result (5, 2).\n\nAvailable stress components are ['S1', 'S2', 'S3', 'SINT', 'SEQV'].\n\n\n\nTotal running time of the script: (0 minutes 1.111 seconds)\n\n\n\nDownload Jupyter notebook: academic_sector_stress_strain.ipynb\n\nDownload Python source code: academic_sector_stress_strain.py\n\nDownload zipped: academic_sector_stress_strain.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"user_guide/index.html#user-guide","title":"User Guide","text":"User Guide\n\nThis guide provides a general overview of the basics and usage of\nansys-mapdl-reader.\n\n"},{"objectID":"Home","href":"examples/00-read_binary/load_corner_result.html#cylindrical-nodal-stress","title":"Cylindrical Nodal Stress","text":"Cylindrical Nodal Stress\n\nVisualize the nodal stress in the radial direction.  This is\nequivalent to setting the result coordinate system to cylindrical in\nMAPDL (e.g. RSYS, 1).\n\nDownload a small result file containing the corner of a thick pipe\n\nplot cylindrical nodal stress in the radial direction\n\n\n\nplot cylindrical nodal stress in the theta direction\n\n\n\nPlot cartesian stress in the “X” direction\n\n\n\nTotal running time of the script: (0 minutes 0.883 seconds)\n\n\n\nDownload Jupyter notebook: load_corner_result.ipynb\n\nDownload Python source code: load_corner_result.py\n\nDownload zipped: load_corner_result.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"examples/index.html#examples","title":"Examples","text":"Examples\n\nHere are a series of examples that demonstrate the behavior and usage\nof ansys-mapdl-reader."},{"objectID":"Home","href":"examples/index.html#loading-and-visualizing-result-files","title":"Examples > Loading and Visualizing Result Files","text":"Loading and Visualizing Result Files\n\n/examples/00-read_binary/custom_visualization\n\n/examples/00-read_binary/load_corner_result\n\n/examples/00-read_binary/load_shaft_result\n\n/examples/00-read_binary/load_thermal_result\n\n/examples/00-read_binary/pontoon"},{"objectID":"Home","href":"examples/index.html#cyclic-result-analysis","title":"Examples > Cyclic Result Analysis","text":"Cyclic Result Analysis\n\nThe following examples demonstrate how to load results from and\ndirectly analyze MAPDL result files from a cyclic analysis.\n\n/examples/01-cyclic_results/academic_sector_nd\n\n/examples/01-cyclic_results/academic_sector_stress_strain\n\n/examples/01-cyclic_results/sector_model\n\n\n\nDownload all examples in Python source code: examples_python.zip\n\nDownload all examples in Jupyter notebooks: examples_jupyter.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"api/archive.html#archive-class-and-functions","title":"Archive Class and Functions","text":"Archive Class and Functions\n\n\n\nclass ansys.mapdl.reader.archive.Archive(filename, read_parameters=False, parse_vtk=True, force_linear=False, allowable_types=None, null_unallowed=False, verbose=False, name='', read_eblock=True)\n\nRead a blocked ANSYS archive file or input file.\n\nReads a blocked CDB file and optionally parses it to a vtk grid.\nThis can be used to read in files written from MAPDL using the\nCDWRITE command or input files ('.dat') files written from\nANSYS Workbench.\n\nWrite the archive file using CDWRITE, DB, archive.cdb\n\nParameters\n\nfilename (string, pathlib.Path) – Filename of block formatted cdb file\n\nread_parameters (bool, optional) – Optionally read parameters from the archive file.  Default\nFalse.\n\nparse_vtk (bool, optional) – When True, parse the raw data into to VTK format.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nverbose (bool, optional) – Print out each step when reading the archive file.  Used for\ndebug purposes and defaults to False.\n\nname (str, optional) – Internally used parameter used to have a custom __repr__.\n\nread_eblock (bool, default: True) – Read the element block.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> hex_beam = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> print(hex_beam)\nANSYS Archive File HexBeam.cdb\n  Number of Nodes:              40\n  Number of Elements:           321\n  Number of Element Types:      1\n  Number of Node Components:    2\n  Number of Element Components: 2\n\nPrint the node array\n\n>>> hex_beam.nodes\narray([[0.  , 0.  , 0.  ],\n       [1.  , 0.  , 0.  ],\n       [0.25, 0.  , 0.  ],\n       ...,\n       [0.75, 0.5 , 3.5 ],\n       [0.75, 0.5 , 4.  ],\n       [0.75, 0.5 , 4.5 ]])\n\nRead an ANSYS workbench input file\n\n>>> my_archive = pymapdl_reader.Archive('C:\\Users\\user\\stuff.dat')\n\nNotes\n\nThis class only reads EBLOCK records with SOLID records.  For\nexample, the record EBLOCK,19,SOLID,,3588 will be read, but\nEBLOCK,10,,,3588 will not be read.  Generally, MAPDL will only\nwrite SOLID records and Mechanical Workbench may write SOLID\nrecords.  These additional records will be ignored.\n\n\n\nproperty filename: str\n\nString form of the filename. This property is read-only.\n\n\n\nproperty grid\n\nReturn a pyvista.UnstructuredGrid of the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.grid\nUnstructuredGrid (0x7ffa237f08a0)\n  N Cells:      40\n  N Points:     321\n  X Bounds:     0.000e+00, 1.000e+00\n  Y Bounds:     0.000e+00, 1.000e+00\n  Z Bounds:     0.000e+00, 5.000e+00\n  N Arrays:     13\n\n\n\nproperty parameters\n\nParameters stored in the archive file\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile,\n                                     read_parameters=True)\n>>> archive.parameters\n{}\n\n\n\nproperty pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nplot(off_screen: bool | None = None, full_screen: bool | None = None, screenshot: str | bool | None = None, interactive: bool = True, cpos: CameraPositionOptions | None = None, window_size: list[int] | None = None, show_bounds: bool = False, show_axes: bool | None = None, notebook: bool | None = None, background: ColorLike | None = None, text: str = '', return_img: bool = False, eye_dome_lighting: bool = False, volume: bool = False, parallel_projection: bool = False, jupyter_backend: JupyterBackendOptions | None = None, return_viewer: bool = False, return_cpos: bool = False, jupyter_kwargs: dict | None = None, theme: Theme | None = None, anti_aliasing: Literal['ssaa', 'msaa', 'fxaa'] | bool | None = None, zoom: str | float | None = None, border: bool = False, border_color: ColorLike = 'k', border_width: float = 2.0, ssao: bool = False, **kwargs)\n\nPlot a PyVista, numpy, or vtk object.\n\nAdded in version 0.47: plot can be invoked with the shell command:Run pyvista plot --help for more details on available parameters.Providing multiple files renders them inside the same window.\n\nParameters\n\nvar_item (pyvista.DataSet) – See Plotter.add_mesh for all\nsupported types.\n\noff_screen\n\nbool, optional\n\nPlots off screen when True.  Helpful for saving\nscreenshots without a window popping up.  Defaults to the\nglobal setting pyvista.OFF_SCREEN.\n\nfull_screen\n\nbool, default: pyvista.plotting.themes.Theme.full_screen\n\nOpens window in full screen.  When enabled, ignores\nwindow_size.\n\nscreenshot\n\nstr | bool, optional\n\nSaves screenshot to file when enabled.  See:\nPlotter.screenshot().\nDefault False.\n\nWhen True, takes screenshot and returns numpy array of\nimage.\n\ninteractive\n\nbool, default: pyvista.plotting.themes.Theme.interactive\n\nAllows user to pan and move figure.\n\ncpos\n\nCameraPositionOptions, optional\n\nList of camera position, focal point, and view up.\nSee the pyvista.Plotter.camera_position for concrete examples\non how to use this parameter and cameras_api for a detailed\ndocumentation on pyvista.Camera.\n\nwindow_size\n\nlist[int], default: pyvista.plotting.themes.Theme.window_size\n\nWindow size in pixels.\n\nshow_bounds\n\nbool, default: False\n\nShows mesh bounds when True.\n\nshow_axes\n\nbool, default: pyvista.plotting.themes._AxesConfig.show\n\nShows a vtk axes widget.\n\nnotebook\n\nbool, default: pyvista.plotting.themes.Theme.notebook\n\nWhen True, the resulting plot is placed inline a jupyter\nnotebook.  Assumes a jupyter console is active.\n\nbackground\n\nColorLike, default: pyvista.plotting.themes.Theme.background\n\nColor of the background.\n\ntext\n\nstr, optional\n\nAdds text at the bottom of the plot.\n\nreturn_img\n\nbool, default: False\n\nReturns numpy array of the last image rendered.\n\neye_dome_lighting\n\nbool, optional\n\nEnables eye dome lighting.\n\nvolume\n\nbool, default: False\n\nUse the Plotter.add_volume() method for volume rendering.\n\nparallel_projection\n\nbool, default: False\n\nEnable parallel projection.\n\njupyter_backend\n\nJupyterBackendOptions, optional\n\nJupyter notebook plotting backend to use.\nSee available documentation at pyvista.set_jupyter_backend()\nto see all valid values for this parameter along with a detailed documentation.\n\nDefaults to pyvista.plotting.themes.Theme.jupyter_backend\n\nreturn_viewer\n\nbool, default: False\n\nReturn the jupyterlab viewer, scene, or display object\nwhen plotting with jupyter notebook.\n\nreturn_cpos\n\nbool, default: False\n\nReturn the last camera position from the render window\nwhen enabled.  Defaults to value in theme settings.\n\njupyter_kwargs\n\ndict, optional\n\nKeyword arguments for the Jupyter notebook plotting backend.\nSee customize_trame_toolbar_example for an example\nusing this keyword.\n\ntheme\n\npyvista.plotting.themes.Theme, optional\n\nPlot-specific theme.\n\nanti_aliasing\n\nLiteral[‘ssaa’, ‘msaa’, ‘fxaa’] | bool, optional\n\nEnable or disable anti-aliasing. If True, uses \"msaa\". If False,\ndisables anti_aliasing. If a string, should be one of the following:\n\n\"ssaa\" - Super-Sample Anti-Aliasing\n\n\"msaa\" - Multi-Sample Anti-Aliasing\n\n\"fxaa\" - Fast Approximate Anti-Aliasing\n\nDefaults to pyvista.plotting.themes.Theme.anti_aliasing\n\nzoom\n\nfloat | str, optional\n\nCamera zoom.  Either 'tight' or a float. A value greater than 1\nis a zoom-in, a value less than 1 is a zoom-out.  Must be greater\nthan 0.\n\nborder\n\nbool, default: False\n\nDraw a border around each render window.\n\nborder_color\n\nColorLike, default: “k”\n\nEither a string, rgb list, or hex color string.  For example:\n\ncolor='white'\n\ncolor='w'\n\ncolor=[1.0, 1.0, 1.0]\n\ncolor='#FFFFFF'\n\nborder_width\n\nfloat, default: 2.0\n\nWidth of the border in pixels when enabled.\n\nssao\n\nbool, optional\n\nEnable surface space ambient occlusion (SSAO). See\nPlotter.enable_ssao() for more details.\n\n**kwargs\n\ndict, optional\n\nSee pyvista.Plotter.add_mesh() for additional options.\n\nReturns\n\ncpos (list) – List of camera position, focal point, and view up.\nReturned only when return_cpos=True or set in the\ndefault global or plot theme.  Not returned when in a\njupyter notebook and return_viewer=True.\n\nimage (np.ndarray) – Numpy array of the last image when either return_img=True\nor screenshot=True is set. Not returned when in a\njupyter notebook with return_viewer=True. Optionally\ncontains alpha values. Sized:\n\n[Window height x Window width x 3] if the theme sets\ntransparent_background=False.\n\n[Window height x Window width x 4] if the theme sets\ntransparent_background=True.\n\nwidget (ipywidgets.Widget) – IPython widget when return_viewer=True.\n\nExamples\n\nPlot a simple sphere while showing its edges.\n\n>>> import pyvista as pv\n>>> mesh = pv.Sphere()\n>>> mesh.plot(show_edges=True)\n\nPlot a volume mesh. Color by distance from the center of the\nImageData. Note volume=True is passed.\n\n>>> import numpy as np\n>>> grid = pv.ImageData(dimensions=(32, 32, 32), spacing=(0.5, 0.5, 0.5))\n>>> grid['data'] = np.linalg.norm(grid.center - grid.points, axis=1)\n>>> grid['data'] = np.abs(grid['data'] - grid['data'].max()) ** 3\n>>> grid.plot(volume=True)\n\n\n\nproperty quality\n\nMinimum scaled jacobian cell quality.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.quality\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n\n\n\nansys.mapdl.reader.archive.save_as_archive(filename, grid, mtype_start=1, etype_start=1, real_constant_start=1, mode='w', enum_start=1, nnum_start=1, include_etype_header=True, reset_etype=False, allow_missing=True, include_surface_elements=True, include_solid_elements=True, include_components=True, exclude_missing=False)\n\nWrites FEM as an ANSYS APDL archive file.\n\nThis function supports the following element types:\n\nvtk.VTK_HEXAHEDRON\n\nvtk.VTK_PYRAMID\n\nvtk.VTK_QUADRATIC_HEXAHEDRON\n\nvtk.VTK_QUADRATIC_PYRAMID\n\nvtk.VTK_QUADRATIC_TETRA\n\nvtk.VTK_QUADRATIC_WEDGE\n\nvtk.VTK_QUAD\n\nvtk.VTK_TETRA\n\nvtk.VTK_TRIANGLE\n\nvtk.VTK_VOXEL\n\nvtk.VTK_WEDGE\n\nWill automatically renumber nodes and elements if the FEM does not\ncontain ANSYS node or element numbers.  Node numbers are stored as\na point array \"ansys_node_num\", and cell numbers are stored as\ncell array \"ansys_elem_num\".\n\nParameters\n\nfilename (str, pathlib.Path) – Filename to write archive file.\n\ngrid (pyvista.DataSet) – Any pyvista.DataSet that can be cast to a\npyvista.UnstructuredGrid.\n\nmtype_start (int, optional) – Material number to assign to elements.  Can be set manually by\nadding the cell array “mtype” to the unstructured grid.\n\netype_start (int, optional) – Starting element type number.  Can be manually set by adding\nthe cell array “ansys_etype” to the unstructured grid.\n\nreal_constant_start (int, optional) – Starting real constant to assign to unset cells.  Can be\nmanually set by adding the cell array “ansys_real_constant” to\nthe unstructured grid.\n\nmode (str, optional) – File mode.  See help(open)\n\nenum_start (int, optional) – Starting element number to assign to unset cells.  Can be\nmanually set by adding the cell array “ansys_elem_num” to the\nunstructured grid.\n\nnnum_start (int, optional) – Starting element number to assign to unset points.  Can be\nmanually set by adding the point array “ansys_node_num” to the\nunstructured grid.\n\ninclude_etype_header (bool, optional) – For each element type, includes element type command\n(e.g. “ET, 1, 186”) in the archive file.\n\nreset_etype (bool, optional) – Resets element type.  Element types will automatically be\ndetermined by the shape of the element (i.e. quadradic\ntetrahedrals will be saved as SOLID187, linear hexahedrals as\nSOLID185).  Default True.\n\ninclude_surface_elements (bool, optional) – Includes surface elements when writing the archive file and\nsaves them as SHELL181.\n\ninclude_solid_elements (bool, optional) – Includes solid elements when writing the archive file and\nsaves them as SOLID185, SOLID186, or SOLID187.\n\ninclude_components (bool, optional) – Writes note components to file.  Node components must be\nstored within the unstructured grid as uint8 or bool arrays.\n\nexclude_missing (bool, default: False) – When allow_missing=True, write 0 instead of renumbering\nnodes. This allows you to exclude midside nodes for certain element\ntypes (e.g. SOLID186). Missing midside nodes are identified as\n-1 in the \"ansys_node_num\" array.\n\nExamples\n\nWrite a pyvista.UnstructuredGrid to \"archive.cdb\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from pyvista import examples\n>>> grid = examples.load_hexbeam()\n>>> pymapdl_reader.save_as_archive('archive.cdb', grid)\n\n\n\nansys.mapdl.reader.archive.write_nblock(filename, node_id, pos, angles=None, mode='w')\n\nWrites nodes and node angles to file.\n\nParameters\n\nfilename (str or file handle) – Filename to write node block to.\n\nnode_id (np.ndarray) – ANSYS node numbers.\n\npos (np.ndarray) – Node coordinates.\n\nangles (np.ndarray, optional) – Writes the node angles for each node when included.\n\nmode (str, optional) – Write mode.  Default 'w'.\n\n\n\nansys.mapdl.reader.archive.write_cmblock(filename, items, comp_name, comp_type, digit_width=10, mode='w')\n\nWrites a component block (CMBLOCK) to a file.\n\nParameters\n\nfilename (str or file handle) – File to write CMBLOCK component to.\n\nitems (list or np.ndarray) – Element or node numbers to write.\n\ncomp_name (str) – Name of the component\n\ncomp_type (str) – Component type to write.  Should be either ‘ELEMENT’ or ‘NODE’.\n\ndigit_width (int, optional) – Default 10\n\nmode (str, optional) – Write mode.  Default 'w'."},{"objectID":"Home","href":"api/archive.html#ansys.mapdl.reader.archive.save_as_archive","title":"Archive Class and Functions > Archive Class and Functions > save_as_archive","text":"ansys.mapdl.reader.archive.save_as_archive(filename, grid, mtype_start=1, etype_start=1, real_constant_start=1, mode='w', enum_start=1, nnum_start=1, include_etype_header=True, reset_etype=False, allow_missing=True, include_surface_elements=True, include_solid_elements=True, include_components=True, exclude_missing=False)\n\nWrites FEM as an ANSYS APDL archive file.\n\nThis function supports the following element types:\n\nvtk.VTK_HEXAHEDRON\n\nvtk.VTK_PYRAMID\n\nvtk.VTK_QUADRATIC_HEXAHEDRON\n\nvtk.VTK_QUADRATIC_PYRAMID\n\nvtk.VTK_QUADRATIC_TETRA\n\nvtk.VTK_QUADRATIC_WEDGE\n\nvtk.VTK_QUAD\n\nvtk.VTK_TETRA\n\nvtk.VTK_TRIANGLE\n\nvtk.VTK_VOXEL\n\nvtk.VTK_WEDGE\n\nWill automatically renumber nodes and elements if the FEM does not\ncontain ANSYS node or element numbers.  Node numbers are stored as\na point array \"ansys_node_num\", and cell numbers are stored as\ncell array \"ansys_elem_num\".\n\nParameters\n\nfilename (str, pathlib.Path) – Filename to write archive file.\n\ngrid (pyvista.DataSet) – Any pyvista.DataSet that can be cast to a\npyvista.UnstructuredGrid.\n\nmtype_start (int, optional) – Material number to assign to elements.  Can be set manually by\nadding the cell array “mtype” to the unstructured grid.\n\netype_start (int, optional) – Starting element type number.  Can be manually set by adding\nthe cell array “ansys_etype” to the unstructured grid.\n\nreal_constant_start (int, optional) – Starting real constant to assign to unset cells.  Can be\nmanually set by adding the cell array “ansys_real_constant” to\nthe unstructured grid.\n\nmode (str, optional) – File mode.  See help(open)\n\nenum_start (int, optional) – Starting element number to assign to unset cells.  Can be\nmanually set by adding the cell array “ansys_elem_num” to the\nunstructured grid.\n\nnnum_start (int, optional) – Starting element number to assign to unset points.  Can be\nmanually set by adding the point array “ansys_node_num” to the\nunstructured grid.\n\ninclude_etype_header (bool, optional) – For each element type, includes element type command\n(e.g. “ET, 1, 186”) in the archive file.\n\nreset_etype (bool, optional) – Resets element type.  Element types will automatically be\ndetermined by the shape of the element (i.e. quadradic\ntetrahedrals will be saved as SOLID187, linear hexahedrals as\nSOLID185).  Default True.\n\ninclude_surface_elements (bool, optional) – Includes surface elements when writing the archive file and\nsaves them as SHELL181.\n\ninclude_solid_elements (bool, optional) – Includes solid elements when writing the archive file and\nsaves them as SOLID185, SOLID186, or SOLID187.\n\ninclude_components (bool, optional) – Writes note components to file.  Node components must be\nstored within the unstructured grid as uint8 or bool arrays.\n\nexclude_missing (bool, default: False) – When allow_missing=True, write 0 instead of renumbering\nnodes. This allows you to exclude midside nodes for certain element\ntypes (e.g. SOLID186). Missing midside nodes are identified as\n-1 in the \"ansys_node_num\" array.\n\nExamples\n\nWrite a pyvista.UnstructuredGrid to \"archive.cdb\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from pyvista import examples\n>>> grid = examples.load_hexbeam()\n>>> pymapdl_reader.save_as_archive('archive.cdb', grid)"},{"objectID":"Home","href":"api/archive.html#ansys.mapdl.reader.archive.write_nblock","title":"Archive Class and Functions > Archive Class and Functions > write_nblock","text":"ansys.mapdl.reader.archive.write_nblock(filename, node_id, pos, angles=None, mode='w')\n\nWrites nodes and node angles to file.\n\nParameters\n\nfilename (str or file handle) – Filename to write node block to.\n\nnode_id (np.ndarray) – ANSYS node numbers.\n\npos (np.ndarray) – Node coordinates.\n\nangles (np.ndarray, optional) – Writes the node angles for each node when included.\n\nmode (str, optional) – Write mode.  Default 'w'."},{"objectID":"Home","href":"api/archive.html#ansys.mapdl.reader.archive.write_cmblock","title":"Archive Class and Functions > Archive Class and Functions > write_cmblock","text":"ansys.mapdl.reader.archive.write_cmblock(filename, items, comp_name, comp_type, digit_width=10, mode='w')\n\nWrites a component block (CMBLOCK) to a file.\n\nParameters\n\nfilename (str or file handle) – File to write CMBLOCK component to.\n\nitems (list or np.ndarray) – Element or node numbers to write.\n\ncomp_name (str) – Name of the component\n\ncomp_type (str) – Component type to write.  Should be either ‘ELEMENT’ or ‘NODE’.\n\ndigit_width (int, optional) – Default 10\n\nmode (str, optional) – Write mode.  Default 'w'."},{"objectID":"Home","href":"api/index.html#api-reference","title":"API Reference","text":"API Reference\n\nThis section gives an overview of the API of several public\nPyMAPDL-Reader classes, functions, and attributes.\n\n"},{"objectID":"Home","href":"api/mesh_quality.html#compute-cell-quality","title":"Compute Cell Quality","text":"Compute Cell Quality\n\n\n\nansys.mapdl.reader.cell_quality.quality(grid)\n\nCompute the minimum scaled Jacobian cell quality of an UnstructuredGrid.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nParameters\n\ngrid (pyvista.UnstructuredGrid or pyvista.StructuredGrid) – Structured or Unstructured Grid from pyvista.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> import pyvista as pv\n>>> x = np.arange(-10, 10, 5)\n>>> y = np.arange(-10, 10, 5)\n>>> z = np.arange(-10, 10, 5)\n>>> x, y, z = np.meshgrid(x, y, z)\n>>> grid = pv.StructuredGrid(x, y, z)\n>>> pymapdl_reader.quality(grid)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])"},{"objectID":"Home","href":"api/mesh_quality.html#ansys.mapdl.reader.cell_quality.quality","title":"Compute Cell Quality > Compute Cell Quality > quality","text":"ansys.mapdl.reader.cell_quality.quality(grid)\n\nCompute the minimum scaled Jacobian cell quality of an UnstructuredGrid.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nParameters\n\ngrid (pyvista.UnstructuredGrid or pyvista.StructuredGrid) – Structured or Unstructured Grid from pyvista.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> import pyvista as pv\n>>> x = np.arange(-10, 10, 5)\n>>> y = np.arange(-10, 10, 5)\n>>> z = np.arange(-10, 10, 5)\n>>> x, y, z = np.meshgrid(x, y, z)\n>>> grid = pv.StructuredGrid(x, y, z)\n>>> pymapdl_reader.quality(grid)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])"},{"objectID":"Home","href":"examples/00-read_binary/index.html#loading-and-visualizing-result-files","title":"Loading and Visualizing Result Files","text":"Loading and Visualizing Result Files\n\n/examples/00-read_binary/custom_visualization\n\n/examples/00-read_binary/load_corner_result\n\n/examples/00-read_binary/load_shaft_result\n\n/examples/00-read_binary/load_thermal_result\n\n/examples/00-read_binary/pontoon\n\n"},{"objectID":"Home","href":"examples/01-cyclic_results/sector_model.html#cyclic-model-visualization","title":"Cyclic Model Visualization","text":"Cyclic Model Visualization\n\nVisualize and animate a full cyclic model.  This model is based on the\njetcat rotor.\n\nFirst, load the rotor.  Notice how printing the rotor class reveals\nthe details of the rotor result file.\n\nPlot the rotor and rotor sectors\n\nNote that additional keyword arguments can be passed to the plotting\nfunctions of pymapdl-reader.  See help(pyvista.plot for the\ndocumentation on all the keyword arguments.\n\n\n\n\n\nPlot nodal displacement for result 21.\n\nNote that pymapdl-reader uses 0 based cumulative indexing.  You could also\nuse the (load step, sub step) (4, 3).\n\n"},{"objectID":"Home","href":"examples/01-cyclic_results/sector_model.html#animate-mode-21","title":"Cyclic Model Visualization > Animate Mode 21","text":"Animate Mode 21\n\nDisable movie_filename and increase n_frames for a smoother plot\n\n\n\nTotal running time of the script: (0 minutes 6.291 seconds)\n\n\n\nDownload Jupyter notebook: sector_model.ipynb\n\nDownload Python source code: sector_model.py\n\nDownload zipped: sector_model.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"user_guide/loading_km.html#working-with-a-mapdl-full-file-full","title":"Working with a MAPDL Full File (full)","text":"Working with a MAPDL Full File (full)\n\nThe MAPDL full file is a FORTRAN formatted binary file containing the\nmass and stiffness from an Ansys analysis.  Using pyansys it can be\nloaded into memory as either a sparse or full matrix."},{"objectID":"Home","href":"user_guide/loading_km.html#reading-a-full-file","title":"Working with a MAPDL Full File (full) > Reading a Full File","text":"Reading a Full File\n\nThis example reads in the mass and stiffness matrices associated with\nthe above example.  load_km sorts degrees of freedom such that the\nnodes are ordered from minimum to maximum, and each degree of freedom\n(i.e. X, Y, Z), are sorted within each node.  The matrices k and\nm are sparse by default, but if scipy is not installed, or if\nthe optional parameter as_sparse=False then they will be full\nnumpy arrays.\n\nBy default load_km outputs the upper triangle of both matrices.\nThe constrained nodes of the analysis can be identified by accessing\nfobj.const where the constrained degrees of freedom are True and\nall others are False.  This corresponds to the degrees of reference in\ndof_ref.\n\nBy default dof_ref is unsorted.  To sort these values, set\nsort==True.  It is enabled for this example to allow for plotting\nof the values later on.\n\nANSYS only stores the upper triangular matrix in the full file.  To\ncreate the full matrix:\n\nIf you have scipy installed, you can solve solve for the natural\nfrequencies and mode shapes of a system."},{"objectID":"Home","href":"user_guide/loading_km.html#plotting-a-mode-shape","title":"Working with a MAPDL Full File (full) > Plotting a Mode Shape","text":"Plotting a Mode Shape\n\nYou can also plot the mode shape of this finite element model.  Since\nthe constrained degrees of freedom have been removed from the\nsolution, you have to account for these when displaying the\ndisplacement.\n\nThis example is built into pyansys-mapdl and can be run from\nexamples.solve_km()."},{"objectID":"Home","href":"user_guide/loading_km.html#fullfile-object-methods","title":"Working with a MAPDL Full File (full) > FullFile Object Methods","text":"FullFile Object Methods\n\n\n\nclass ansys.mapdl.reader.full.FullFile(filename: str | Path)\n\nStores the results of an ANSYS full file.\n\nParameters\n\nfilename (str) – Filename of the full file to read.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full)\nPyMAPDL-Reader : MAPDL Full File\nTitle                    : Demo\nVersion                  : 20.1\nPlatform                 : WINDOWS x64\nJobname                  : file\nMatrices                 : 2\nEquations                : 345\nNodes                    : 115\nDegrees of Freedom       : 3\n\n\n\nproperty const\n\nConstrained DOF\nReturns the node number and DOF constrained in ANSYS.\n\nExamples\n\n>>> full.const\narray([], shape=(0, 2), dtype=int32)\n\n\n\nproperty dof_ref\n\nSorted degree of freedom reference.\n\nExamples\n\n>>> full.dof_ref\narray([[  1,   0],\n       [  1,   1],\n       [  1,   2],\n       [115,   0],\n       [115,   1],\n       [115,   2]], dtype=int32)\n\nNotes\n\nObtain the unsorted degree of freedom reference with\n>>> dof_ref, k, m = sparse_full.load_km(sort=False)\n\n\n\nproperty filename\n\nString form of the filename. This property is read-only.\n\n\n\nproperty k\n\nStiffness Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full.k)\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 7002 stored elements in Compressed Sparse Column format>\n\n\n\nload_km(as_sparse=True, sort=False)\n\nLoad and construct mass and stiffness matrices from an\nANSYS full file.\n\nParameters\n\nas_sparse (bool, optional) – Outputs the mass and stiffness matrices as scipy csc\nsparse arrays when True by default.\n\nsort (bool, optional) – Rearranges the k and m matrices such that the rows\ncorrespond to to the sorted rows and columns in dor_ref.\nAlso sorts dor_ref.\n\nReturns\n\ndof_ref ((n x 2) np.int32 array) – This array contains the node and degree corresponding to\neach row and column in the mass and stiffness matrices.\nIn a 3 DOF analysis the dof integers will correspond to:\n0 - x\n1 - y\n2 - z\nSort these values by node number and DOF by enabling the\nsort parameter.\n\nk ((n x n) np.float_ or scipy.csc array) – Stiffness array\n\nm ((n x n) np.float_ or scipy.csc array) – Mass array\n\nExamples\n\n>>> dof_ref, k, m = full.load_km()\n>>> print(k)\n(0, 0)       163408119.6581276\n(0, 1)               0.0423270\n(1, 1)       163408119.6581276\n:       :\n(342, 344)     6590544.8717949\n(343, 344)    -6590544.8717950\n(344, 344)    20426014.9572689\n\nNotes\n\nConstrained entries are removed from the mass and stiffness\nmatrices.\n\nConstrained DOF can be accessed from const, which returns\nthe node number and DOF constrained in ANSYS.\n\n\n\nproperty load_vector\n\nThe load vector\n\nExamples\n\n>>> full.load_vector\narray([0., 0., 0., ..., 0., 0., 0.])\n\n\n\nproperty m\n\nMass Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> full.m\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 2883 stored elements in Compressed Sparse Column format>\n\n\n\nproperty neqn\n\nNumber of equations\n\nExamples\n\n>>> full.neqn\n963\n\n\n\nproperty pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > FullFile","text":"class ansys.mapdl.reader.full.FullFile(filename: str | Path)\n\nStores the results of an ANSYS full file.\n\nParameters\n\nfilename (str) – Filename of the full file to read.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full)\nPyMAPDL-Reader : MAPDL Full File\nTitle                    : Demo\nVersion                  : 20.1\nPlatform                 : WINDOWS x64\nJobname                  : file\nMatrices                 : 2\nEquations                : 345\nNodes                    : 115\nDegrees of Freedom       : 3\n\n\n\nproperty const\n\nConstrained DOF\nReturns the node number and DOF constrained in ANSYS.\n\nExamples\n\n>>> full.const\narray([], shape=(0, 2), dtype=int32)\n\n\n\nproperty dof_ref\n\nSorted degree of freedom reference.\n\nExamples\n\n>>> full.dof_ref\narray([[  1,   0],\n       [  1,   1],\n       [  1,   2],\n       [115,   0],\n       [115,   1],\n       [115,   2]], dtype=int32)\n\nNotes\n\nObtain the unsorted degree of freedom reference with\n>>> dof_ref, k, m = sparse_full.load_km(sort=False)\n\n\n\nproperty filename\n\nString form of the filename. This property is read-only.\n\n\n\nproperty k\n\nStiffness Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full.k)\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 7002 stored elements in Compressed Sparse Column format>\n\n\n\nload_km(as_sparse=True, sort=False)\n\nLoad and construct mass and stiffness matrices from an\nANSYS full file.\n\nParameters\n\nas_sparse (bool, optional) – Outputs the mass and stiffness matrices as scipy csc\nsparse arrays when True by default.\n\nsort (bool, optional) – Rearranges the k and m matrices such that the rows\ncorrespond to to the sorted rows and columns in dor_ref.\nAlso sorts dor_ref.\n\nReturns\n\ndof_ref ((n x 2) np.int32 array) – This array contains the node and degree corresponding to\neach row and column in the mass and stiffness matrices.\nIn a 3 DOF analysis the dof integers will correspond to:\n0 - x\n1 - y\n2 - z\nSort these values by node number and DOF by enabling the\nsort parameter.\n\nk ((n x n) np.float_ or scipy.csc array) – Stiffness array\n\nm ((n x n) np.float_ or scipy.csc array) – Mass array\n\nExamples\n\n>>> dof_ref, k, m = full.load_km()\n>>> print(k)\n(0, 0)       163408119.6581276\n(0, 1)               0.0423270\n(1, 1)       163408119.6581276\n:       :\n(342, 344)     6590544.8717949\n(343, 344)    -6590544.8717950\n(344, 344)    20426014.9572689\n\nNotes\n\nConstrained entries are removed from the mass and stiffness\nmatrices.\n\nConstrained DOF can be accessed from const, which returns\nthe node number and DOF constrained in ANSYS.\n\n\n\nproperty load_vector\n\nThe load vector\n\nExamples\n\n>>> full.load_vector\narray([0., 0., 0., ..., 0., 0., 0.])\n\n\n\nproperty m\n\nMass Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> full.m\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 2883 stored elements in Compressed Sparse Column format>\n\n\n\nproperty neqn\n\nNumber of equations\n\nExamples\n\n>>> full.neqn\n963\n\n\n\nproperty pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.const","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > const","text":"property const\n\nConstrained DOF\nReturns the node number and DOF constrained in ANSYS.\n\nExamples\n\n>>> full.const\narray([], shape=(0, 2), dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.dof_ref","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > dof_ref","text":"property dof_ref\n\nSorted degree of freedom reference.\n\nExamples\n\n>>> full.dof_ref\narray([[  1,   0],\n       [  1,   1],\n       [  1,   2],\n       [115,   0],\n       [115,   1],\n       [115,   2]], dtype=int32)\n\nNotes\n\nObtain the unsorted degree of freedom reference with\n>>> dof_ref, k, m = sparse_full.load_km(sort=False)"},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.filename","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > filename","text":"property filename\n\nString form of the filename. This property is read-only."},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.k","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > k","text":"property k\n\nStiffness Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> full = pymapdl_reader.read_binary('file.rst')\n>>> print(full.k)\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 7002 stored elements in Compressed Sparse Column format>"},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.load_km","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > load_km","text":"load_km(as_sparse=True, sort=False)\n\nLoad and construct mass and stiffness matrices from an\nANSYS full file.\n\nParameters\n\nas_sparse (bool, optional) – Outputs the mass and stiffness matrices as scipy csc\nsparse arrays when True by default.\n\nsort (bool, optional) – Rearranges the k and m matrices such that the rows\ncorrespond to to the sorted rows and columns in dor_ref.\nAlso sorts dor_ref.\n\nReturns\n\ndof_ref ((n x 2) np.int32 array) – This array contains the node and degree corresponding to\neach row and column in the mass and stiffness matrices.\nIn a 3 DOF analysis the dof integers will correspond to:\n0 - x\n1 - y\n2 - z\nSort these values by node number and DOF by enabling the\nsort parameter.\n\nk ((n x n) np.float_ or scipy.csc array) – Stiffness array\n\nm ((n x n) np.float_ or scipy.csc array) – Mass array\n\nExamples\n\n>>> dof_ref, k, m = full.load_km()\n>>> print(k)\n(0, 0)       163408119.6581276\n(0, 1)               0.0423270\n(1, 1)       163408119.6581276\n:       :\n(342, 344)     6590544.8717949\n(343, 344)    -6590544.8717950\n(344, 344)    20426014.9572689\n\nNotes\n\nConstrained entries are removed from the mass and stiffness\nmatrices.\n\nConstrained DOF can be accessed from const, which returns\nthe node number and DOF constrained in ANSYS."},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.load_vector","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > load_vector","text":"property load_vector\n\nThe load vector\n\nExamples\n\n>>> full.load_vector\narray([0., 0., 0., ..., 0., 0., 0.])"},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.m","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > m","text":"property m\n\nMass Matrix corresponding to sorted DOF.\n\nExamples\n\n>>> full.m\n<345x345 sparse matrix of type '<class 'numpy.float64'>'\n        with 2883 stored elements in Compressed Sparse Column format>"},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.neqn","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > neqn","text":"property neqn\n\nNumber of equations\n\nExamples\n\n>>> full.neqn\n963"},{"objectID":"Home","href":"user_guide/loading_km.html#ansys.mapdl.reader.full.FullFile.pathlib_filename","title":"Working with a MAPDL Full File (full) > FullFile Object Methods > pathlib_filename","text":"property pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"index.html#pymapdl-reader---legacy-binary-and-archive-file-reader","title":"PyMAPDL Reader - Legacy Binary and Archive File Reader","text":"PyMAPDL Reader - Legacy Binary and Archive File Reader\n\nThis is the legacy module for reading in binary and ASCII files\ngenerated from MAPDL.\n\nThis Python module allows you to extract data directly from binary\nANSYS v14.5+ files and to display or animate them rapidly using a\nstraightforward API coupled with C libraries based on header files\nprovided by ANSYS.\n\nThe ansys-mapdl-reader module supports the following formats:\n\n*.rst - Structural analysis result file\n\n*.rth - Thermal analysis result file\n\n*.emat - Element matrice data file\n\n*.full - Full stiffness-mass matrix file\n\n*.cdb or *.dat - MAPDL ASCII block archive and\nMechanical Workbench input files\n\nPlease see the ref_example_gallery for several demos using\nansys-mapdl-reader.\n\nThis module will likely change or be depreciated in the future.\n\nYou are encouraged to use the new Data Processing Framework (DPF)\nmodules at DPF-Core and\nDPF-Post as they provide a\nmodern interface to ANSYS result files using a client/server\ninterface using the same software used within ANSYS Workbench, but\nvia a Python client."},{"objectID":"Home","href":"index.html#brief-demo-direct-access-to-binary-files","title":"PyMAPDL Reader - Legacy Binary and Archive File Reader > Brief Demo: Direct Access to Binary Files","text":"Brief Demo: Direct Access to Binary Files\n\nHere’s a quick example code block to show how easy it is to load and\nplots results directly from an ANSYS result file using\nansys-mapdl-reader:\n\n"},{"objectID":"Home","href":"index.html#license-and-acknowledgments","title":"PyMAPDL Reader - Legacy Binary and Archive File Reader > License and Acknowledgments","text":"License and Acknowledgments\n\nThe ansys-mapdl-reader module is licensed under the MIT license."},{"objectID":"Home","href":"examples/00-read_binary/sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:16.125 total execution time for 5 files from examples/00-read_binary:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nsphx_glr_examples_00-read_binary_custom_visualization.py (custom_visualization.py)\n\n00:07.687\n\n0.0\n\nsphx_glr_examples_00-read_binary_load_shaft_result.py (load_shaft_result.py)\n\n00:06.411\n\n0.0\n\nsphx_glr_examples_00-read_binary_load_corner_result.py (load_corner_result.py)\n\n00:00.883\n\n0.0\n\nsphx_glr_examples_00-read_binary_pontoon.py (pontoon.py)\n\n00:00.682\n\n0.0\n\nsphx_glr_examples_00-read_binary_load_thermal_result.py (load_thermal_result.py)\n\n00:00.462\n\n0.0"},{"objectID":"Home","href":"examples/00-read_binary/pontoon.html#shell-static-analysis","title":"Shell Static Analysis","text":"Shell Static Analysis\n\nVisualize a shell static analysis\n\nPrint the pontoon result\n\nPlot the nodal displacement\n\n\n\nprint the available result types\n\nPlot the shell elements\n\n\n\nPlot the elastic strain and show exaggerated displacement\n\n\n\nTotal running time of the script: (0 minutes 0.682 seconds)\n\n\n\nDownload Jupyter notebook: pontoon.ipynb\n\nDownload Python source code: pontoon.py\n\nDownload zipped: pontoon.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"user_guide/loading_emat.html#working-with-a-ansys-element-matrix-file-emat","title":"Working with a ANSYS Element Matrix File (.emat)","text":"Working with a ANSYS Element Matrix File (.emat)\n\nThe ANSYS element matrix file is a FORTRAN formatted binary file\ncontaining the following for each element:\n\nStiffness matrix\n\nMass matrix\n\nDamping matrix\n\nStress stiffening matrix\n\nComplex stiffness matrix\n\nElement force vectors"},{"objectID":"Home","href":"user_guide/loading_emat.html#example","title":"Working with a ANSYS Element Matrix File (.emat) > Example","text":"Example\n\nLoad the element matrix file:\n\nRead a single element from the result file:\n\nThe dictionary element_data contains the entries used to construct\nstiffness, mass, and damping matrices.  If recorded, the dictionary\nwill also applied force vectors."},{"objectID":"Home","href":"user_guide/loading_emat.html#applied-force","title":"Working with a ANSYS Element Matrix File (.emat) > Applied Force","text":"Applied Force\n\nRead accumulated applied force for all nodes:\n\nSee emat_file.nnum for the sorted nodes this applied force corresponds to."},{"objectID":"Home","href":"user_guide/loading_emat.html#dof-reference","title":"Working with a ANSYS Element Matrix File (.emat) > DOF Reference","text":"DOF Reference\n\nEach degree of freedom index from read_element corresponds to a\nphysical degree of freedom.  The table of this correspondence is\nbelow:\n\n\n\n\n\nIndex\n\nDOF\n\n1\n\nUX\n\n2\n\nUY\n\n3\n\nUZ\n\n4\n\nROTX\n\n5\n\nROTY\n\n6\n\nROTZ\n\n7\n\nAX\n\n8\n\nAY\n\n9\n\nAZ\n\n10\n\nVX\n\n11\n\nVY\n\n12\n\nVZ\n\n16\n\nWARP\n\n17\n\nCONC\n\n18\n\nHDSP\n\n19\n\nPRES\n\n20\n\nTEMP\n\n21\n\nVOLT\n\n22\n\nMAG\n\n23\n\nENKE\n\n24\n\nENDS\n\n25\n\nEMF\n\n26\n\nCURR\n\n27 - 32\n\nSpares"},{"objectID":"Home","href":"user_guide/loading_emat.html#ematfile-object-methods","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods","text":"EmatFile Object Methods\n\n\n\nclass ansys.mapdl.reader.emat.EmatFile(filename)\n\nEnables pythonic access to an ANSYS element matrix file.\n\nParameters\n\nfilename (str, pathlib.Path) – File to open.  Generally ends in *.emat.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> emat_file = pymapdl_reader.read_binary('file.emat')\n\n\n\nproperty eeqv\n\nElement equivalence table.  This table equates the number\nused for storage to the actual element number.\n\nNotes\n\nThe ANSYS program stores all element data in the numerical\norder that the SOLUTION processor solves the elements.  This\ntable equates the order number used to the actual element.\n\n\n\nproperty element_matrices_index_table\n\nReturn element matrices index table\n\n\n\nproperty enum\n\nSorted ANSYS element numbers\n\n\n\nproperty filename\n\nString form of the filename. This property is read-only.\n\n\n\nglobal_applied_force()\n\nReturns the applied force for each node.\n\nReturns\n\napplied_force – Applied force with size (n_nodes, n_dof).  Result is\nsorted to correspond with the sorted global nodes array.\n\nReturn type\n\nnp.ndarray\n\n\n\nproperty n_dof\n\nNumber of dofs per node\n\n\n\nproperty n_elements\n\nNumber of elements in the file\n\n\n\nproperty n_nodes\n\nNumber of nodes in the file\n\n\n\nproperty neqv\n\nNodal equivalence table. This table equates the number used\nfor storage to the actual node number.\n\n\n\nproperty nnum\n\nSorted ANSYS node numbers\n\n\n\nproperty pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nread_element(index, stress=True, mass=True, damping=True, stress_stiff=True, applied_force=True, newton_raphson=True, imaginary_load=True)\n\nRead element by index\n\nParameters\n\nindex (int) – Element index.  This is not the element number.  Reference\nthe element equivalency table for the actual element\nnumber.\n\nstress (bool, optional) – Return the stress matrix entries if available.\n\nmass (bool, optional) – Return the mass matrix entries if available.\n\ndamping (bool, optional) – Return the damping matrix entries if available.\n\nstress_stiff (bool, optional) – Return the stress stiffening entries if available.\n\nnewton_raphson (bool, optional) – Return the newton raphson load entries if available.\n\napplied_force (bool, optional) – Return the applied load vector if available.\n\nimaginary_load (bool, optional) – Return the imaginary load vector if available.\n\nReturns\n\ndof_idx (np.ndarray) – DOF index table. This record specifies the DOF locations\nof this element matrix in relation to the global\nmatrix. The index is calculated as (N-1)*NUMDOF+DOF, where\nN is the position number of the node in the nodal\nequivalence table and DOF is the DOF reference number\ngiven above\n\nelement_data (dict) – Dictionary containing the following entries for each of\nthe corresponding inputs when the item is True.\n- ‘stress’ : stress matrix entries\n- ‘mass’ : mass matrix entries\n- ‘damping’ : damping matrix entries\n- ‘stress_stiff’ : stress stiffening matrix entries\n- ‘newton_raphson’ : newton rapson load vector\n- ‘applied_force’ : applied force vector\n- ‘imaginary_load’ : imaginary load vector\n\nNotes\n\nIf the matrix is diagonal, the length of the records will be\nnmrow.  If the matrix is unsymmetric, the length of the\nrecords will be nmrow*nmrow. If the matrix is symmetric, only\nthe lower triangular terms are written and the length of the\nrecords will be (nmrow)*(nmrow+1)/2\n\nRecords are written relative to the dof_idx.  The index is\ncalculated as (N-1)*NUMDOF+DOF, where N is the position number\nof the node in the nodal equivalence table and DOF is the DOF\nreference number given by dof_idx.\n\n\n\nread_element_matrix_header(f_index)\n\nRead element matrix header\n\nParameters\n\nf_indes (int) – Fortran index to the start of the element matrix header.\n\nNotes\n\nstkey - stiffness matrix key\n\n0 - matrix not present\n1 - matrix present\n\nmkey - mass matrix key\n\n0 - matrix not present\n1 - matrix present\n\ndkey - damping matrix key\n\n0 - matrix not present\n1 - matrix present\n\nsskey - stress stiffening matrix key\n\n0 - matrix not present\n1 - matrix present\n\nakey - applied load vector key\n\n0 - vector not used\n1 - vector used\n\nnrkey - newton-raphson(restoring) load\n\n0 - vector not used\n1 - vector used\n\nikey - imaginary load vector key (for complex analyses)\n\n0 - vector not used\n1 - vector used\n\nnmrow - numbers/columns in matrices.\n\nIf the number is negative, the matrices will be written in\nlower triangular form.\n\n\n\nread_header()\n\nRead standard emat file header"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > EmatFile","text":"class ansys.mapdl.reader.emat.EmatFile(filename)\n\nEnables pythonic access to an ANSYS element matrix file.\n\nParameters\n\nfilename (str, pathlib.Path) – File to open.  Generally ends in *.emat.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> emat_file = pymapdl_reader.read_binary('file.emat')\n\n\n\nproperty eeqv\n\nElement equivalence table.  This table equates the number\nused for storage to the actual element number.\n\nNotes\n\nThe ANSYS program stores all element data in the numerical\norder that the SOLUTION processor solves the elements.  This\ntable equates the order number used to the actual element.\n\n\n\nproperty element_matrices_index_table\n\nReturn element matrices index table\n\n\n\nproperty enum\n\nSorted ANSYS element numbers\n\n\n\nproperty filename\n\nString form of the filename. This property is read-only.\n\n\n\nglobal_applied_force()\n\nReturns the applied force for each node.\n\nReturns\n\napplied_force – Applied force with size (n_nodes, n_dof).  Result is\nsorted to correspond with the sorted global nodes array.\n\nReturn type\n\nnp.ndarray\n\n\n\nproperty n_dof\n\nNumber of dofs per node\n\n\n\nproperty n_elements\n\nNumber of elements in the file\n\n\n\nproperty n_nodes\n\nNumber of nodes in the file\n\n\n\nproperty neqv\n\nNodal equivalence table. This table equates the number used\nfor storage to the actual node number.\n\n\n\nproperty nnum\n\nSorted ANSYS node numbers\n\n\n\nproperty pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nread_element(index, stress=True, mass=True, damping=True, stress_stiff=True, applied_force=True, newton_raphson=True, imaginary_load=True)\n\nRead element by index\n\nParameters\n\nindex (int) – Element index.  This is not the element number.  Reference\nthe element equivalency table for the actual element\nnumber.\n\nstress (bool, optional) – Return the stress matrix entries if available.\n\nmass (bool, optional) – Return the mass matrix entries if available.\n\ndamping (bool, optional) – Return the damping matrix entries if available.\n\nstress_stiff (bool, optional) – Return the stress stiffening entries if available.\n\nnewton_raphson (bool, optional) – Return the newton raphson load entries if available.\n\napplied_force (bool, optional) – Return the applied load vector if available.\n\nimaginary_load (bool, optional) – Return the imaginary load vector if available.\n\nReturns\n\ndof_idx (np.ndarray) – DOF index table. This record specifies the DOF locations\nof this element matrix in relation to the global\nmatrix. The index is calculated as (N-1)*NUMDOF+DOF, where\nN is the position number of the node in the nodal\nequivalence table and DOF is the DOF reference number\ngiven above\n\nelement_data (dict) – Dictionary containing the following entries for each of\nthe corresponding inputs when the item is True.\n- ‘stress’ : stress matrix entries\n- ‘mass’ : mass matrix entries\n- ‘damping’ : damping matrix entries\n- ‘stress_stiff’ : stress stiffening matrix entries\n- ‘newton_raphson’ : newton rapson load vector\n- ‘applied_force’ : applied force vector\n- ‘imaginary_load’ : imaginary load vector\n\nNotes\n\nIf the matrix is diagonal, the length of the records will be\nnmrow.  If the matrix is unsymmetric, the length of the\nrecords will be nmrow*nmrow. If the matrix is symmetric, only\nthe lower triangular terms are written and the length of the\nrecords will be (nmrow)*(nmrow+1)/2\n\nRecords are written relative to the dof_idx.  The index is\ncalculated as (N-1)*NUMDOF+DOF, where N is the position number\nof the node in the nodal equivalence table and DOF is the DOF\nreference number given by dof_idx.\n\n\n\nread_element_matrix_header(f_index)\n\nRead element matrix header\n\nParameters\n\nf_indes (int) – Fortran index to the start of the element matrix header.\n\nNotes\n\nstkey - stiffness matrix key\n\n0 - matrix not present\n1 - matrix present\n\nmkey - mass matrix key\n\n0 - matrix not present\n1 - matrix present\n\ndkey - damping matrix key\n\n0 - matrix not present\n1 - matrix present\n\nsskey - stress stiffening matrix key\n\n0 - matrix not present\n1 - matrix present\n\nakey - applied load vector key\n\n0 - vector not used\n1 - vector used\n\nnrkey - newton-raphson(restoring) load\n\n0 - vector not used\n1 - vector used\n\nikey - imaginary load vector key (for complex analyses)\n\n0 - vector not used\n1 - vector used\n\nnmrow - numbers/columns in matrices.\n\nIf the number is negative, the matrices will be written in\nlower triangular form.\n\n\n\nread_header()\n\nRead standard emat file header"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.eeqv","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > eeqv","text":"property eeqv\n\nElement equivalence table.  This table equates the number\nused for storage to the actual element number.\n\nNotes\n\nThe ANSYS program stores all element data in the numerical\norder that the SOLUTION processor solves the elements.  This\ntable equates the order number used to the actual element."},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.element_matrices_index_table","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > element_matrices_index_table","text":"property element_matrices_index_table\n\nReturn element matrices index table"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.enum","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > enum","text":"property enum\n\nSorted ANSYS element numbers"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.filename","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > filename","text":"property filename\n\nString form of the filename. This property is read-only."},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.global_applied_force","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > global_applied_force","text":"global_applied_force()\n\nReturns the applied force for each node.\n\nReturns\n\napplied_force – Applied force with size (n_nodes, n_dof).  Result is\nsorted to correspond with the sorted global nodes array.\n\nReturn type\n\nnp.ndarray"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.n_dof","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > n_dof","text":"property n_dof\n\nNumber of dofs per node"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.n_elements","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > n_elements","text":"property n_elements\n\nNumber of elements in the file"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.n_nodes","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > n_nodes","text":"property n_nodes\n\nNumber of nodes in the file"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.neqv","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > neqv","text":"property neqv\n\nNodal equivalence table. This table equates the number used\nfor storage to the actual node number."},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.nnum","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > nnum","text":"property nnum\n\nSorted ANSYS node numbers"},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.pathlib_filename","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > pathlib_filename","text":"property pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.read_element","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > read_element","text":"read_element(index, stress=True, mass=True, damping=True, stress_stiff=True, applied_force=True, newton_raphson=True, imaginary_load=True)\n\nRead element by index\n\nParameters\n\nindex (int) – Element index.  This is not the element number.  Reference\nthe element equivalency table for the actual element\nnumber.\n\nstress (bool, optional) – Return the stress matrix entries if available.\n\nmass (bool, optional) – Return the mass matrix entries if available.\n\ndamping (bool, optional) – Return the damping matrix entries if available.\n\nstress_stiff (bool, optional) – Return the stress stiffening entries if available.\n\nnewton_raphson (bool, optional) – Return the newton raphson load entries if available.\n\napplied_force (bool, optional) – Return the applied load vector if available.\n\nimaginary_load (bool, optional) – Return the imaginary load vector if available.\n\nReturns\n\ndof_idx (np.ndarray) – DOF index table. This record specifies the DOF locations\nof this element matrix in relation to the global\nmatrix. The index is calculated as (N-1)*NUMDOF+DOF, where\nN is the position number of the node in the nodal\nequivalence table and DOF is the DOF reference number\ngiven above\n\nelement_data (dict) – Dictionary containing the following entries for each of\nthe corresponding inputs when the item is True.\n- ‘stress’ : stress matrix entries\n- ‘mass’ : mass matrix entries\n- ‘damping’ : damping matrix entries\n- ‘stress_stiff’ : stress stiffening matrix entries\n- ‘newton_raphson’ : newton rapson load vector\n- ‘applied_force’ : applied force vector\n- ‘imaginary_load’ : imaginary load vector\n\nNotes\n\nIf the matrix is diagonal, the length of the records will be\nnmrow.  If the matrix is unsymmetric, the length of the\nrecords will be nmrow*nmrow. If the matrix is symmetric, only\nthe lower triangular terms are written and the length of the\nrecords will be (nmrow)*(nmrow+1)/2\n\nRecords are written relative to the dof_idx.  The index is\ncalculated as (N-1)*NUMDOF+DOF, where N is the position number\nof the node in the nodal equivalence table and DOF is the DOF\nreference number given by dof_idx."},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.read_element_matrix_header","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > read_element_matrix_header","text":"read_element_matrix_header(f_index)\n\nRead element matrix header\n\nParameters\n\nf_indes (int) – Fortran index to the start of the element matrix header.\n\nNotes\n\nstkey - stiffness matrix key\n\n0 - matrix not present\n1 - matrix present\n\nmkey - mass matrix key\n\n0 - matrix not present\n1 - matrix present\n\ndkey - damping matrix key\n\n0 - matrix not present\n1 - matrix present\n\nsskey - stress stiffening matrix key\n\n0 - matrix not present\n1 - matrix present\n\nakey - applied load vector key\n\n0 - vector not used\n1 - vector used\n\nnrkey - newton-raphson(restoring) load\n\n0 - vector not used\n1 - vector used\n\nikey - imaginary load vector key (for complex analyses)\n\n0 - vector not used\n1 - vector used\n\nnmrow - numbers/columns in matrices.\n\nIf the number is negative, the matrices will be written in\nlower triangular form."},{"objectID":"Home","href":"user_guide/loading_emat.html#ansys.mapdl.reader.emat.EmatFile.read_header","title":"Working with a ANSYS Element Matrix File (.emat) > EmatFile Object Methods > read_header","text":"read_header()\n\nRead standard emat file header"},{"objectID":"Getting started","href":"getting_started.html#getting-started","title":"Getting started","text":"Getting started\n\nInstallation is simply:\n\nYou can also visit pymapdl-reader\nto download the source or releases from GitHub.\n\nIf you have any installation (or other) issues, please open an issue\nat pymapdl-reader Issues.\n\nThe ansys-mapdl-reader supports 64-Bit Windows, Mac OS, and Linux\nfor Python 3.10 through Python 3.13."},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_nd.html#understanding-nodal-diameters-from-a-cyclic-model-analysis","title":"Understanding Nodal Diameters from a Cyclic Model Analysis","text":"Understanding Nodal Diameters from a Cyclic Model Analysis\n\nThis example shows how to interpret modes from a cyclic analysis from\nMAPDL result file from both single bladed sectors as well as\nmulti-bladed sectors from a modal analysis.\n\nDownload the academic modal analysis file"},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_nd.html#rotor-sector-order","title":"Understanding Nodal Diameters from a Cyclic Model Analysis > Rotor Sector Order","text":"Rotor Sector Order\n\nNote that the sector rotations follow the right-hand rule where the\nX-axis and Y-axis make up the horizontal plane and the Z-axis is\nvertical and positive upwards.  Rotation follows the right-hand\nrule, which looks anti-clockwise when looking downward onto the XY\nplane.\n\n\n\nPlot Nodal Displacement\n\nThis modal analysis contains two modes for each harmonic index.\nSince this is a 24 sector rotor, it will contain the harmonic\nindices from 0 to N/2, which in this case is 12\n\nYou can refer to the result set either using MAPDL’s 1-based indexing\nwhich is (Load-step, sub-step).\n\n\n\nAlternatively, you can refer to the results using cumulative indexing.\n\n"},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_nd.html#understanding-harmonic-indexing","title":"Understanding Nodal Diameters from a Cyclic Model Analysis > Understanding Harmonic Indexing","text":"Understanding Harmonic Indexing\n\nANSYS has great documentation on harmonic indexing within their\ninternal documentation, but for the sake of completeness it will be repeated here.\n\nThe harmonic index used within MAPDL is an integer that determines\nthe variation in the value of a single degree of freedom at points\nspaced at a circumferential angle equal to the sector angle.\n\nFor this academic rotor, when the number of “blades” equals the\nnumber of MAPDL sectors, the harmonic index will always match the\nnodal diameter.  For example, the cumulative result 10 has a\nharmonic index of 5:\n\n\n\nThe same can be done for the simpler nodal diameter 1\n\n"},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_nd.html#multi-bladed-sectors","title":"Understanding Nodal Diameters from a Cyclic Model Analysis > Multi-Bladed Sectors","text":"Multi-Bladed Sectors\n\nWhen there are multiple blades per sector as in the case of the\nfollowing example, the relationship between the harmonic indices and\nnodal diameters becomes more complicated\n\nIn this case, we use the following equation described in the MAPDL\nCyclic Analysis Guide:\nd = m*N ± k\n\nwhere:\n- d is the nodal diameter\n- N is the number of sectors\n- k is the harmonic index\n- m is a set of integers from 0 to infinity\n\nTherefore, for a 6 sector rotor, the first 4 possible nodal diameters at\nharmonic index 1 are:\n\nNormally for a rotor where the number of blades per sector is 1,\nnodal diameters higher than N are simply aliased back to 1 and these\nsolutions do not appear in the results.  However, when the sector\ncontains multiple blades per sector, these results do appear in the\nanalysis since they are not aliased back into a repeated mode."},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_nd.html#plot-the-multi-bladed-sector","title":"Understanding Nodal Diameters from a Cyclic Model Analysis > Plot the Multi-Bladed Sector","text":"Plot the Multi-Bladed Sector\n\nWe can verify these results by analyzing a multi-sector rotor\n\n\n\nWe can then see that the harmonic indices for harmonic index 1\nindeed alias back to the expected nodal diameters in the following\nplots.\n\nCumulative result 8 and harmonic index 1\n\n\n\nCumulative result 10 and harmonic index 5\n\n\n\nCumulative result 13 and harmonic index 7\n\n\n\nCumulative result 15 and harmonic index 11\n\n"},{"objectID":"Home","href":"examples/01-cyclic_results/academic_sector_nd.html#traveling-wave-animation","title":"Understanding Nodal Diameters from a Cyclic Model Analysis > Traveling Wave Animation","text":"Traveling Wave Animation\n\nYou can animate the traveling wave for a cyclic result using\nanimate_nodal_displacement.  For a modal result, be sure to\nmodify displacement_factor to a value that properly scales the\nmodal solution.  Recall that solutions to a modal analysis from\nMAPDL may or may not be scaled to unity or the mass matrix depending\non the settings within the modal analysis.\n\nSet loop=True to allow for a continuous plot, and modify\nn_frames to allow for a smoother or faster plot.  See\nhelp(pyvista.plot) for additional keyword arguments.\n\n\n\nNote how you can plot the backwards traveling wave by selecting the\nsecond mode in the mode pair (3, 2) instead of (3, 1).\n\n\n\nTotal running time of the script: (0 minutes 13.882 seconds)\n\n\n\nDownload Jupyter notebook: academic_sector_nd.ipynb\n\nDownload Python source code: academic_sector_nd.py\n\nDownload zipped: academic_sector_nd.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"user_guide/quality.html#compute-cell-quality","title":"Compute Cell Quality","text":"Compute Cell Quality\n\nCompute the minimum scaled jacoabian of a vtk.Unstructured.Grid,\npyvista.UnstructuredGrid, or pyvista.StructuredGrid."},{"objectID":"Home","href":"user_guide/quality.html#plot-cell-quality","title":"Compute Cell Quality > Plot Cell Quality","text":"Plot Cell Quality\n\nThis built-in example displays the minimum scaled jacobian of each\nelement of a tetrahedral beam:\n\nThis is the source code for the example:"},{"objectID":"Home","href":"user_guide/quality.html#pyansysquality","title":"Compute Cell Quality > pyansys.quality","text":"pyansys.quality\n\n\n\nansys.mapdl.reader.quality(grid)\n\nCompute the minimum scaled Jacobian cell quality of an UnstructuredGrid.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nParameters\n\ngrid (pyvista.UnstructuredGrid or pyvista.StructuredGrid) – Structured or Unstructured Grid from pyvista.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> import pyvista as pv\n>>> x = np.arange(-10, 10, 5)\n>>> y = np.arange(-10, 10, 5)\n>>> z = np.arange(-10, 10, 5)\n>>> x, y, z = np.meshgrid(x, y, z)\n>>> grid = pv.StructuredGrid(x, y, z)\n>>> pymapdl_reader.quality(grid)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])"},{"objectID":"Home","href":"user_guide/quality.html#ansys.mapdl.reader.quality","title":"Compute Cell Quality > pyansys.quality > quality","text":"ansys.mapdl.reader.quality(grid)\n\nCompute the minimum scaled Jacobian cell quality of an UnstructuredGrid.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nParameters\n\ngrid (pyvista.UnstructuredGrid or pyvista.StructuredGrid) – Structured or Unstructured Grid from pyvista.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> import pyvista as pv\n>>> x = np.arange(-10, 10, 5)\n>>> y = np.arange(-10, 10, 5)\n>>> z = np.arange(-10, 10, 5)\n>>> x, y, z = np.meshgrid(x, y, z)\n>>> grid = pv.StructuredGrid(x, y, z)\n>>> pymapdl_reader.quality(grid)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])"},{"objectID":"Home","href":"user_guide/loading_results.html#reading-mapdl-result-files","title":"Reading MAPDL Result Files","text":"Reading MAPDL Result Files\n\nThe ansys-mapdl-reader module supports the following result types from MAPDL:\n\n\".rfl\"\n\n\".rmg\"\n\n\".rst\"\n\n\".rth\"\n\nThe MAPDL result file is a FORTRAN formatted binary file containing\nthe results written from a MAPDL analysis.  The results, at a\nminimum, contain the geometry of the model analyzed along with the\nnodal and element results.  Depending on the analysis, these results\ncould be anything from modal displacements to nodal temperatures.\nThis includes (and is not limited to):\n\nNodal DOF results from a static analysis or modal analysis.\n\nNodal DOF results from a cyclic static or modal analysis.\n\nNodal averaged component stresses (i.e. x, y, z, xy, xz, yz)\n\nNodal principal stresses (i.e. S1, S2, S3, SEQV, SINT)\n\nNodal elastic, plastic, and thermal stress\n\nNodal time history\n\nNodal boundary conditions and force\n\nNodal temperatures\n\nNodal thermal strain\n\nVarious element results (see element_solution_data)\n\nThis module will likely change or depreciated in the future, and you\nare encouraged to checkout the new Data Processing Framework (DPF)\nmodules at DPF-Core and\nDPF-Post as they provide a\nmodern interface to ANSYS result files using a client/server interface\nusing the same software used within ANSYS Workbench, but via a Python\nclient."},{"objectID":"Home","href":"user_guide/loading_results.html#loading-the-result-file","title":"Reading MAPDL Result Files > Loading the Result File","text":"Loading the Result File\n\nAs the MAPDL result files are binary files, the entire file does not\nneed to be loaded into memory in order to retrieve results.  This\nmodule accesses the results through a python object result which you\ncan initialize with:\n\nUpon initialization the Result object contains several\nproperties to include the time values from the analysis, node\nnumbering, element numbering, etc.\n\nThe ansys-mapdl-reader module can determine the correct result\ntype by reading the header of the file, which means that if it is an\nMAPDL binary file, ansys-mapdl-reader can probably read it (at\nleast to some degree.  For example, a thermal result file can be read\nwith"},{"objectID":"Home","href":"user_guide/loading_results.html#result-properties","title":"Reading MAPDL Result Files > Result Properties","text":"Result Properties\n\nThe properties of the Result can be quickly shown by printing the\nresult file with:\n\nTo obtain the time or frequency values of an analysis use:\n\nIndividual results can be obtained with one of the many methods\navailable to the result object.  For example, the nodal displacement\nfor the first result can be accessed with:\n\nThe sorted node and element numbering of a result can be obtained with:"},{"objectID":"Home","href":"user_guide/loading_results.html#mesh","title":"Reading MAPDL Result Files > Mesh","text":"Mesh\n\nThe mesh of the result can be found by querying the mesh property\nof a result, which returns a ansys.mapdl.reader.mesh.Mesh class.\n\nWhich contains the following attributes:\n\n\n\nclass ansys.mapdl.reader.mesh.Mesh(nnum=None, nodes=None, elem=None, elem_off=None, ekey=None, node_comps={}, elem_comps={}, rdat=[], rnum=[], keyopt={})\n\nCommon class between Archive, and result mesh\n\n\n\nproperty ekey\n\nElement type key\n\nArray containing element type numbers in the first column and\nthe element types (like SURF154) in the second column.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.ekey\narray([[  1,  45],\n       [  2,  95],\n       [  3,  92],\n       [ 60, 154]], dtype=int32)\n\n\n\nproperty elem\n\nList of elements containing raw ansys information.\n\nEach element contains 10 items plus the nodes belonging to the\nelement.  The first 10 items are:\n\nFIELD 0 : material reference number\n\nFIELD 1 : element type number\n\nFIELD 2 : real constant reference number\n\nFIELD 3 : section number\n\nFIELD 4 : element coordinate system\n\nFIELD 5 : death flag (0 - alive, 1 - dead)\n\nFIELD 6 : solid model reference\n\nFIELD 7 : coded shape key\n\nFIELD 8 : element number\n\nFIELD 9 : base element number (applicable to reinforcing elements only)\n\nFIELDS 10 - 30 : The nodes belonging to the element in ANSYS numbering.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem\n[array([  1,   4,  19,  15,  63,  91, 286, 240,   3,  18,  17,\n         16,  81, 276, 267, 258,  62,  90, 285, 239],\n array([  4,   2,   8,  19,  91,  44, 147, 286,   5,   7,  21,\n         18, 109, 137, 313, 276,  90,  43, 146, 285],\n array([ 15,  19,  12,  10, 240, 286, 203, 175,  17,  20,  13,\n         14, 267, 304, 221, 230, 239, 285, 202, 174],\n...\n\n\n\nproperty elem_real_constant\n\nReal constant reference for each element.\n\nUse the data within rlblock and rlblock_num to get the\nreal constant datat for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem_real_constant\narray([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        ...,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 61, 61, 61, 61,\n       61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n       61], dtype=int32)\n\n\n\nproperty element_components\n\nElement components for the archive.\n\nOutput is a dictionary of element components.  Each entry is an\narray of MAPDL element numbers corresponding to the element\ncomponent.  The keys are element component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_components\n{'ECOMP1 ': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n                   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n                   dtype=int32),\n'ECOMP2 ': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n                  14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32)}\n\n\n\nelement_coord_system()\n\nElement coordinate system number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_coord_system\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0], dtype=int32)\n\n\n\nproperty enum\n\nANSYS element numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.enum\narray([    1,     2,     3, ...,  9998,  9999, 10000])\n\n\n\nproperty et_id\n\nElement type id (ET) for each element.\n\n\n\nproperty etype\n\nElement type of each element.\n\nThis is the ansys element type for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.etype\narray([ 45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n        45,  45,  45,  45,  45,  45,  45,  45,  92,  92,  92,\n        92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,\n        ...,\n        92,  92,  92,  92,  92, 154, 154, 154, 154, 154, 154,\n       154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n       154], dtype=int32)\n\nNotes\n\nElement types are listed below.  Please see the APDL Element\nReference for more details:\n\nhttps://www.mm.bme.hu/~gyebro/files/vem/ansys_14_element_reference.pdf\n\n\n\nproperty key_option\n\nAdditional key options for element types\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.key_option\n{1: [[1, 11]]}\n\n\n\nproperty material_type\n\nMaterial type index of each element in the archive.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.material_type\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1], dtype=int32)\n\n\n\nproperty n_elem\n\nNumber of nodes\n\n\n\nproperty n_node\n\nNumber of nodes\n\n\n\nproperty nnum\n\nArray of node numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nnum\narray([    1,     2,     3, ..., 19998, 19999, 20000])\n\n\n\nproperty node_angles\n\nNode angles from the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n ...,\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]]\n\n\n\nproperty node_components\n\nNode components for the archive.\n\nOutput is a dictionary of node components.  Each entry is an\narray of MAPDL node numbers corresponding to the node\ncomponent.  The keys are node component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.node_components\n{'NCOMP2  ': array([  1,   2,   3,   4,   5,   6,   7,   8,\n                     14, 15, 16, 17, 18, 19, 20, 21, 43, 44,\n                     62, 63, 64, 81, 82, 90, 91, 92, 93, 94,\n                     118, 119, 120, 121, 122, 123, 124, 125,\n                     126, 137, 147, 148, 149, 150, 151, 152,\n                     153, 165, 166, 167, 193, 194, 195, 202,\n                     203, 204, 205, 206, 207, 221, 240, 258,\n                     267, 268, 276, 277, 278, 285, 286, 287,\n                     304, 305, 306, 313, 314, 315, 316\n                     ], dtype=int32),\n...,\n}\n\n\n\nproperty nodes\n\nArray of nodes.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [1.   0.   0.  ]\n [0.25 0.   0.  ]\n ...,\n [0.75 0.5  3.5 ]\n [0.75 0.5  4.  ]\n [0.75 0.5  4.5 ]]\n\n\n\nproperty rlblock\n\nReal constant data from the RLBLOCK.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rlblock\n[[0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.02 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.01 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005]]\n\n\n\nproperty rlblock_num\n\nIndices from the real constant data\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rnum\narray([60, 61, 62, 63])\n\n\n\nsave(filename, binary=True, force_linear=False, allowable_types=[], null_unallowed=False)\n\nSave the geometry as a vtk file\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of output file. Writer type is inferred from\nthe extension of the filename.\n\nbinary (bool, optional) – If True, write as binary, else ASCII.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nExamples\n\n>>> geom.save('mesh.vtk')\n\nNotes\n\nBinary files write much faster than ASCII and have a smaller\nfile size.\n\n\n\nproperty section\n\nSection number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.section\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1], dtype=int32)\n\n\n\nproperty tshape\n\nTshape of contact elements.\n\n\n\nproperty tshape_key\n\nDict with the mapping between element type and element shape.\n\nTShape is only applicable to contact elements."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh","title":"Reading MAPDL Result Files > Mesh > Mesh","text":"class ansys.mapdl.reader.mesh.Mesh(nnum=None, nodes=None, elem=None, elem_off=None, ekey=None, node_comps={}, elem_comps={}, rdat=[], rnum=[], keyopt={})\n\nCommon class between Archive, and result mesh\n\n\n\nproperty ekey\n\nElement type key\n\nArray containing element type numbers in the first column and\nthe element types (like SURF154) in the second column.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.ekey\narray([[  1,  45],\n       [  2,  95],\n       [  3,  92],\n       [ 60, 154]], dtype=int32)\n\n\n\nproperty elem\n\nList of elements containing raw ansys information.\n\nEach element contains 10 items plus the nodes belonging to the\nelement.  The first 10 items are:\n\nFIELD 0 : material reference number\n\nFIELD 1 : element type number\n\nFIELD 2 : real constant reference number\n\nFIELD 3 : section number\n\nFIELD 4 : element coordinate system\n\nFIELD 5 : death flag (0 - alive, 1 - dead)\n\nFIELD 6 : solid model reference\n\nFIELD 7 : coded shape key\n\nFIELD 8 : element number\n\nFIELD 9 : base element number (applicable to reinforcing elements only)\n\nFIELDS 10 - 30 : The nodes belonging to the element in ANSYS numbering.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem\n[array([  1,   4,  19,  15,  63,  91, 286, 240,   3,  18,  17,\n         16,  81, 276, 267, 258,  62,  90, 285, 239],\n array([  4,   2,   8,  19,  91,  44, 147, 286,   5,   7,  21,\n         18, 109, 137, 313, 276,  90,  43, 146, 285],\n array([ 15,  19,  12,  10, 240, 286, 203, 175,  17,  20,  13,\n         14, 267, 304, 221, 230, 239, 285, 202, 174],\n...\n\n\n\nproperty elem_real_constant\n\nReal constant reference for each element.\n\nUse the data within rlblock and rlblock_num to get the\nreal constant datat for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem_real_constant\narray([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        ...,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 61, 61, 61, 61,\n       61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n       61], dtype=int32)\n\n\n\nproperty element_components\n\nElement components for the archive.\n\nOutput is a dictionary of element components.  Each entry is an\narray of MAPDL element numbers corresponding to the element\ncomponent.  The keys are element component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_components\n{'ECOMP1 ': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n                   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n                   dtype=int32),\n'ECOMP2 ': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n                  14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32)}\n\n\n\nelement_coord_system()\n\nElement coordinate system number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_coord_system\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0], dtype=int32)\n\n\n\nproperty enum\n\nANSYS element numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.enum\narray([    1,     2,     3, ...,  9998,  9999, 10000])\n\n\n\nproperty et_id\n\nElement type id (ET) for each element.\n\n\n\nproperty etype\n\nElement type of each element.\n\nThis is the ansys element type for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.etype\narray([ 45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n        45,  45,  45,  45,  45,  45,  45,  45,  92,  92,  92,\n        92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,\n        ...,\n        92,  92,  92,  92,  92, 154, 154, 154, 154, 154, 154,\n       154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n       154], dtype=int32)\n\nNotes\n\nElement types are listed below.  Please see the APDL Element\nReference for more details:\n\nhttps://www.mm.bme.hu/~gyebro/files/vem/ansys_14_element_reference.pdf\n\n\n\nproperty key_option\n\nAdditional key options for element types\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.key_option\n{1: [[1, 11]]}\n\n\n\nproperty material_type\n\nMaterial type index of each element in the archive.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.material_type\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1], dtype=int32)\n\n\n\nproperty n_elem\n\nNumber of nodes\n\n\n\nproperty n_node\n\nNumber of nodes\n\n\n\nproperty nnum\n\nArray of node numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nnum\narray([    1,     2,     3, ..., 19998, 19999, 20000])\n\n\n\nproperty node_angles\n\nNode angles from the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n ...,\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]]\n\n\n\nproperty node_components\n\nNode components for the archive.\n\nOutput is a dictionary of node components.  Each entry is an\narray of MAPDL node numbers corresponding to the node\ncomponent.  The keys are node component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.node_components\n{'NCOMP2  ': array([  1,   2,   3,   4,   5,   6,   7,   8,\n                     14, 15, 16, 17, 18, 19, 20, 21, 43, 44,\n                     62, 63, 64, 81, 82, 90, 91, 92, 93, 94,\n                     118, 119, 120, 121, 122, 123, 124, 125,\n                     126, 137, 147, 148, 149, 150, 151, 152,\n                     153, 165, 166, 167, 193, 194, 195, 202,\n                     203, 204, 205, 206, 207, 221, 240, 258,\n                     267, 268, 276, 277, 278, 285, 286, 287,\n                     304, 305, 306, 313, 314, 315, 316\n                     ], dtype=int32),\n...,\n}\n\n\n\nproperty nodes\n\nArray of nodes.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [1.   0.   0.  ]\n [0.25 0.   0.  ]\n ...,\n [0.75 0.5  3.5 ]\n [0.75 0.5  4.  ]\n [0.75 0.5  4.5 ]]\n\n\n\nproperty rlblock\n\nReal constant data from the RLBLOCK.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rlblock\n[[0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.02 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.01 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005]]\n\n\n\nproperty rlblock_num\n\nIndices from the real constant data\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rnum\narray([60, 61, 62, 63])\n\n\n\nsave(filename, binary=True, force_linear=False, allowable_types=[], null_unallowed=False)\n\nSave the geometry as a vtk file\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of output file. Writer type is inferred from\nthe extension of the filename.\n\nbinary (bool, optional) – If True, write as binary, else ASCII.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nExamples\n\n>>> geom.save('mesh.vtk')\n\nNotes\n\nBinary files write much faster than ASCII and have a smaller\nfile size.\n\n\n\nproperty section\n\nSection number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.section\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1], dtype=int32)\n\n\n\nproperty tshape\n\nTshape of contact elements.\n\n\n\nproperty tshape_key\n\nDict with the mapping between element type and element shape.\n\nTShape is only applicable to contact elements."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.ekey","title":"Reading MAPDL Result Files > Mesh > ekey","text":"property ekey\n\nElement type key\n\nArray containing element type numbers in the first column and\nthe element types (like SURF154) in the second column.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.ekey\narray([[  1,  45],\n       [  2,  95],\n       [  3,  92],\n       [ 60, 154]], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.elem","title":"Reading MAPDL Result Files > Mesh > elem","text":"property elem\n\nList of elements containing raw ansys information.\n\nEach element contains 10 items plus the nodes belonging to the\nelement.  The first 10 items are:\n\nFIELD 0 : material reference number\n\nFIELD 1 : element type number\n\nFIELD 2 : real constant reference number\n\nFIELD 3 : section number\n\nFIELD 4 : element coordinate system\n\nFIELD 5 : death flag (0 - alive, 1 - dead)\n\nFIELD 6 : solid model reference\n\nFIELD 7 : coded shape key\n\nFIELD 8 : element number\n\nFIELD 9 : base element number (applicable to reinforcing elements only)\n\nFIELDS 10 - 30 : The nodes belonging to the element in ANSYS numbering.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem\n[array([  1,   4,  19,  15,  63,  91, 286, 240,   3,  18,  17,\n         16,  81, 276, 267, 258,  62,  90, 285, 239],\n array([  4,   2,   8,  19,  91,  44, 147, 286,   5,   7,  21,\n         18, 109, 137, 313, 276,  90,  43, 146, 285],\n array([ 15,  19,  12,  10, 240, 286, 203, 175,  17,  20,  13,\n         14, 267, 304, 221, 230, 239, 285, 202, 174],\n..."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.elem_real_constant","title":"Reading MAPDL Result Files > Mesh > elem_real_constant","text":"property elem_real_constant\n\nReal constant reference for each element.\n\nUse the data within rlblock and rlblock_num to get the\nreal constant datat for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem_real_constant\narray([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        ...,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 61, 61, 61, 61,\n       61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n       61], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.element_components","title":"Reading MAPDL Result Files > Mesh > element_components","text":"property element_components\n\nElement components for the archive.\n\nOutput is a dictionary of element components.  Each entry is an\narray of MAPDL element numbers corresponding to the element\ncomponent.  The keys are element component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_components\n{'ECOMP1 ': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n                   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n                   dtype=int32),\n'ECOMP2 ': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n                  14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32)}"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.element_coord_system","title":"Reading MAPDL Result Files > Mesh > element_coord_system","text":"element_coord_system()\n\nElement coordinate system number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_coord_system\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.enum","title":"Reading MAPDL Result Files > Mesh > enum","text":"property enum\n\nANSYS element numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.enum\narray([    1,     2,     3, ...,  9998,  9999, 10000])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.et_id","title":"Reading MAPDL Result Files > Mesh > et_id","text":"property et_id\n\nElement type id (ET) for each element."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.etype","title":"Reading MAPDL Result Files > Mesh > etype","text":"property etype\n\nElement type of each element.\n\nThis is the ansys element type for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.etype\narray([ 45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n        45,  45,  45,  45,  45,  45,  45,  45,  92,  92,  92,\n        92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,\n        ...,\n        92,  92,  92,  92,  92, 154, 154, 154, 154, 154, 154,\n       154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n       154], dtype=int32)\n\nNotes\n\nElement types are listed below.  Please see the APDL Element\nReference for more details:\n\nhttps://www.mm.bme.hu/~gyebro/files/vem/ansys_14_element_reference.pdf"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.key_option","title":"Reading MAPDL Result Files > Mesh > key_option","text":"property key_option\n\nAdditional key options for element types\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.key_option\n{1: [[1, 11]]}"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.material_type","title":"Reading MAPDL Result Files > Mesh > material_type","text":"property material_type\n\nMaterial type index of each element in the archive.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.material_type\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.n_elem","title":"Reading MAPDL Result Files > Mesh > n_elem","text":"property n_elem\n\nNumber of nodes"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.n_node","title":"Reading MAPDL Result Files > Mesh > n_node","text":"property n_node\n\nNumber of nodes"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.nnum","title":"Reading MAPDL Result Files > Mesh > nnum","text":"property nnum\n\nArray of node numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nnum\narray([    1,     2,     3, ..., 19998, 19999, 20000])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.node_angles","title":"Reading MAPDL Result Files > Mesh > node_angles","text":"property node_angles\n\nNode angles from the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n ...,\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]]"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.node_components","title":"Reading MAPDL Result Files > Mesh > node_components","text":"property node_components\n\nNode components for the archive.\n\nOutput is a dictionary of node components.  Each entry is an\narray of MAPDL node numbers corresponding to the node\ncomponent.  The keys are node component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.node_components\n{'NCOMP2  ': array([  1,   2,   3,   4,   5,   6,   7,   8,\n                     14, 15, 16, 17, 18, 19, 20, 21, 43, 44,\n                     62, 63, 64, 81, 82, 90, 91, 92, 93, 94,\n                     118, 119, 120, 121, 122, 123, 124, 125,\n                     126, 137, 147, 148, 149, 150, 151, 152,\n                     153, 165, 166, 167, 193, 194, 195, 202,\n                     203, 204, 205, 206, 207, 221, 240, 258,\n                     267, 268, 276, 277, 278, 285, 286, 287,\n                     304, 305, 306, 313, 314, 315, 316\n                     ], dtype=int32),\n...,\n}"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.nodes","title":"Reading MAPDL Result Files > Mesh > nodes","text":"property nodes\n\nArray of nodes.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [1.   0.   0.  ]\n [0.25 0.   0.  ]\n ...,\n [0.75 0.5  3.5 ]\n [0.75 0.5  4.  ]\n [0.75 0.5  4.5 ]]"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.rlblock","title":"Reading MAPDL Result Files > Mesh > rlblock","text":"property rlblock\n\nReal constant data from the RLBLOCK.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rlblock\n[[0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.02 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.01 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005]]"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.rlblock_num","title":"Reading MAPDL Result Files > Mesh > rlblock_num","text":"property rlblock_num\n\nIndices from the real constant data\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rnum\narray([60, 61, 62, 63])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.save","title":"Reading MAPDL Result Files > Mesh > save","text":"save(filename, binary=True, force_linear=False, allowable_types=[], null_unallowed=False)\n\nSave the geometry as a vtk file\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of output file. Writer type is inferred from\nthe extension of the filename.\n\nbinary (bool, optional) – If True, write as binary, else ASCII.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nExamples\n\n>>> geom.save('mesh.vtk')\n\nNotes\n\nBinary files write much faster than ASCII and have a smaller\nfile size."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.section","title":"Reading MAPDL Result Files > Mesh > section","text":"property section\n\nSection number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.section\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.tshape","title":"Reading MAPDL Result Files > Mesh > tshape","text":"property tshape\n\nTshape of contact elements."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.mesh.Mesh.tshape_key","title":"Reading MAPDL Result Files > Mesh > tshape_key","text":"property tshape_key\n\nDict with the mapping between element type and element shape.\n\nTShape is only applicable to contact elements."},{"objectID":"Home","href":"user_guide/loading_results.html#coordinate-systems","title":"Reading MAPDL Result Files > Coordinate Systems","text":"Coordinate Systems\n\nNon-default coordinate systems are always saved to a MAPDL result\nfile.  The coordinate system is zero indexed and individual coordinate\nsystems can be accessed with:\n\nA 4x4 transformation matrix can be constructed by concatenating the\ntransformation matrix and the origin into one array.  For example:\n\nSee parse_coordinate_system for more details regarding the\ncontents of the coordinate systems stored in the result file."},{"objectID":"Home","href":"user_guide/loading_results.html#accessing-solution-results","title":"Reading MAPDL Result Files > Accessing Solution Results","text":"Accessing Solution Results\n\nYou can obtain detailed information using solution_info for each result:\n\nThis yields:\n\nThe DOF solution for an analysis for each node in the analysis can be\nobtained using the code block below.  These results correspond to the\nnode numbers in the result file.  This array is sized by the number of\nnodes by the number of degrees of freedom.\n\nStress can be obtained as well using the below code.  The nodal stress\nis computed in the same manner as MAPDL by averaging the stress\nevaluated at that node for all attached elements.\n\nElement stress can be obtained using the following segment of code.\nEnsure that the element results are expanded for a modal analysis\nwithin ANSYS with:\n\nThis block of code shows how you can access the non-averaged stresses\nfor the first result from a modal analysis.\n\nThese stresses can be verified using MAPDL using:\n\nWhich are identical to the results from MAPDL:"},{"objectID":"Home","href":"user_guide/loading_results.html#loading-a-results-from-a-modal-analysis-result-file","title":"Reading MAPDL Result Files > Loading a Results from a Modal Analysis Result File","text":"Loading a Results from a Modal Analysis Result File\n\nThis example reads in binary results from a modal analysis of a beam\nfrom ANSYS.  This section of code does not rely on VTK and can be\nused with only numpy installed.\n\nGet the 1st bending mode shape.  Results are ordered based on the\nsorted node numbering.  Note that results are zero indexed."},{"objectID":"Home","href":"user_guide/loading_results.html#accessing-element-solution-data","title":"Reading MAPDL Result Files > Accessing Element Solution Data","text":"Accessing Element Solution Data\n\nIndividual element results for the entire solution can be accessed\nusing the element_solution_data method.  For example, to get the\nvolume of each element:"},{"objectID":"Home","href":"user_guide/loading_results.html#animiating-a-modal-solution","title":"Reading MAPDL Result Files > Animiating a Modal Solution","text":"Animiating a Modal Solution\n\nSolutions from a modal analysis can be animated using\nanimate_nodal_solution.  For example:"},{"objectID":"Home","href":"user_guide/loading_results.html#plotting-nodal-results","title":"Reading MAPDL Result Files > Plotting Nodal Results","text":"Plotting Nodal Results\n\nAs the geometry of the model is contained within the result file, you\ncan plot the result without having to load any additional geometry.\nBelow, displacement for the first mode of the modal analysis beam is\nplotted using VTK.\n\nHere, we plot the displacement of Mode 0 in the x direction:\n\nResults can be plotted non-interactively and screenshots saved by\nsetting up the camera and saving the result.  This can help with the\nvisualization and post-processing of a batch result.\n\nFirst, get the camera position from an interactive plot:\n\nThen generate the plot:\n\nStress can be plotted as well using the below code.  The nodal stress\nis computed in the same manner that ANSYS uses by to determine the\nstress at each node by averaging the stress evaluated at that node for\nall attached elements.  For now, only component stresses can be\ndisplayed.\n\nNodal stress can also be generated non-interactively with:"},{"objectID":"Home","href":"user_guide/loading_results.html#animating-a-modal-solution","title":"Reading MAPDL Result Files > Animating a Modal Solution","text":"Animating a Modal Solution\n\nMode shapes from a modal analysis can be animated using\nanimate_nodal_solution:\n\nIf you wish to save the animation to a file, specify the\nmovie_filename and animate it with:"},{"objectID":"Home","href":"user_guide/loading_results.html#results-from-a-cyclic-analysis","title":"Reading MAPDL Result Files > Results from a Cyclic Analysis","text":"Results from a Cyclic Analysis\n\nThe ansys-mapdl-reader module can load and display the results of\na cyclic analysis:\n\nYou can reference the load step table and harmonic index tables by\nprinting the result header dictionary keys 'ls_table' and\n'hindex':\n\nWhere each harmonic index entry corresponds a cumulative index.  For\nexample, result number 11 is the first mode for the 2nd harmonic\nindex:\n\nAlternatively, the result number can be obtained by using:\n\nUsing this indexing method, repeated modes are indexed by the same\nmode index.  To access the other repeated mode, use a negative\nharmonic index.  Should a result not exist, ansys-mapdl-reader\nwill return which modes are available:\n\nResults from a cyclic analysis require additional post processing to\nbe interpreted correctly.  Mode shapes are stored within the result\nfile as unprocessed parts of the real and imaginary parts of a modal\nsolution.  ansys-mapdl-reader combines these values into a single\ncomplex array and then returns the real result of that array.\n\nSometimes it is necessary to determine the maximum displacement of a\nmode.  To do so, return the complex solution with:\n\nSee help(result.nodal_solution) for more details.\n\nThe real displacement of the sector is always the real component of\nthe mode shape ms, and this can be varied by multiplying the mode\nshape by a complex value for a given phase.\n\nThe results of a single sector can be displayed as well using the\nplot_nodal_solution\n\nThe phase of the result can be changed by modifying the phase\noption.  See help(result.plot_nodal_solution) for details on its\nimplementation."},{"objectID":"Home","href":"user_guide/loading_results.html#exporting-to-paraview","title":"Reading MAPDL Result Files > Exporting to ParaView","text":"Exporting to ParaView\n\nParaView is a visualization application that can be used for rapid\ngeneration of plots and graphs using VTK through a GUI.\nansys-mapdl-reader can translate the MAPDL result files to\nParaView compatible files containing the geometry and nodal results\nfrom the analysis:\n\nThe vtk xml file can now be loaded using ParaView.  This screenshot\nshows the nodal displacement of the first result from the result file\nplotted within ParaView.  Within the\nvtk file are two point arrays (NodalResult and nodal_stress)\nfor each result in the result file.  The nodal result values will\ndepend on the analysis type, while nodal stress will always be the\nnode average stress in the Sx, Sy Sz, Sxy, Syz, and Sxz directions."},{"objectID":"Home","href":"user_guide/loading_results.html#result-object-methods","title":"Reading MAPDL Result Files > Result Object Methods","text":"Result Object Methods\n\n\n\nclass ansys.mapdl.reader.rst.Result(filename, read_mesh=True, parse_vtk=True, **kwargs)\n\nReads a binary ANSYS result file.\n\nParameters\n\nfilename (str, pathlib.Path, optional) – Filename of the ANSYS binary result file.\n\nignore_cyclic (bool, optional) – Ignores any cyclic properties.\n\nread_mesh (bool, optional) – Debug parameter.  Set to False to disable reading in the\nmesh from the result file.\n\nparse_vtk (bool, optional) – Set to False to skip the parsing the mesh as a VTK\nUnstructuredGrid, which might take a long time for large models.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n\n\n\nanimate_nodal_displacement(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)\n\n\n\nanimate_nodal_solution(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)\n\n\n\nanimate_nodal_solution_set(rnums=None, comp='norm', node_components=None, element_components=None, sel_type_all=True, loop=True, movie_filename=None, add_text=True, fps=20, **kwargs)\n\nAnimate a set of nodal solutions.\n\nAnimates the scalars of all the result sets.  Best when used\nwith a series of static analyses.\n\nrnums\n\ncollection.Iterable\n\nRange or list containing the zero based indexed cumulative\nresult numbers to animate.\n\ncomp\n\nstr, optional\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.  Not\napplicable for a thermal analysis.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.\n\nmovie_filename\n\nstr, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported.  See\nimagio.get_writer.  A single loop of the mode will be\nrecorded.\n\nadd_text\n\nbool, optional\n\nAdds information about the result to the animation.\n\nfps\n\nint, optional\n\nFrames per second.  Defaults to 20 and limited to hardware\ncapabilities and model density. Carries over to movies\ncreated by providing the movie_filename argument,\nbut not to gifs.\n\nkwargs\n\noptional keyword arguments, optional\n\nSee help(pyvista.Plot) for additional keyword arguments.\n\nExamples\n\nAnimate all results\n\n>>> rst.animate_nodal_solution_set()\n\nAnimate every 50th result in a set of results and save to a\ngif.  Use the “zx” camera position to view the ZX plane from\nthe top down.\n\n>>> rsets = range(0, rst.nsets, 50)\n>>> rst.animate_nodal_solution_set(rsets,\n...                                scalar_bar_args={'title': 'My Animation'},\n...                                lighting=False, cpos='zx',\n...                                movie_filename='example.gif')\n\n\n\nproperty available_results\n\nAvailable result types.\n\nExamples\n\n>>> rst.available_results\nAvailable Results:\nENS : Nodal stresses\nENG : Element energies and volume\nEEL : Nodal elastic strains\nEPL : Nodal plastic strains\nETH : Nodal thermal strains (includes swelling strains)\nEUL : Element euler angles\nENL : Nodal nonlinear items, e.g. equivalent plastic strains\nEPT : Nodal temperatures\nNSL : Nodal displacements\nRF  : Nodal reaction forces\n\n\n\ncs_4x4(cs_cord, as_vtk_matrix=False)\n\nReturn a 4x4 transformation matrix for a given coordinate system.\n\nParameters\n\ncs_cord (int) – Coordinate system index.\n\nas_vtk_matrix (bool, default: False) – Return the transformation matrix as a vtkMatrix4x4.\n\nReturns\n\nMatrix or vtkMatrix4x4 depending on the value of as_vtk_matrix.\n\nReturn type\n\nnp.ndarray | vtk.vtkMatrix4x4\n\nNotes\n\nValues 11 and greater correspond to local coordinate systems\n\nExamples\n\nReturn the transformation matrix for coordinate system 1.\n\n>>> tmat = rst.cs_4x4(1)\n>>> tmat\narray([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]])\n\nReturn the transformation matrix for coordinate system 5. This\ncorresponds to CSYS, 5, the cylindrical with global Cartesian Y as\nthe axis of rotation.\n\n>>> tmat = rst.cs_4x4(5)\n>>> tmat\narray([[ 1.,  0.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.]])\n\n\n\ncylindrical_nodal_stress(rnum, nodes=None)\n\nRetrieves the stresses for each node in the solution in the\ncylindrical coordinate system as the following values:\n\nR, THETA, Z, RTHETA, THETAZ, and RZ\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at R, THETA, Z, RTHETA, THETAZ, RZ averaged\nat each corner node where R is radial.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.cylindrical_nodal_stress(0)\n\nReturn the cylindrical nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS commands:\nRSYS, 1\nPRNSOL, S\n\n\n\nproperty element_components\n\nDictionary of ansys element components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.element_components\n{'ECOMP1': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], dtype=int32),\n'ECOMP2': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n        14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32),\n'ELEM_COMP': array([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        16, 17, 18, 19, 20], dtype=int32)}\n\n\n\nelement_lookup(element_id)\n\nIndex of the element the element within the result mesh\n\n\n\nelement_solution_data(rnum, datatype, sort=True, **kwargs)\n\nRetrieves element solution data.  Similar to ETABLE.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ndatatype (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nsort (bool) – Sort results by element number.  Default True.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – Element numbers.\n\nelement_data (list) – List with one data item for each element.\n\nenode (list) – Node numbers corresponding to each element.\nresults.  One list entry for each element.\n\nNotes\n\nSee ANSYS element documentation for available items for each\nelement type.  See:\n\nhttps://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_elem/\n\nExamples\n\nRetrieve “LS” solution results from an PIPE59 element for result set 1\n\n>>> enum, edata, enode = result.element_solution_data(0, datatype='ENS')\n>>> enum[0]  # first element number\n>>> enode[0]  # nodes belonging to element 1\n>>> edata[0]  # data belonging to element 1\narray([ -4266.19   ,   -376.18857,  -8161.785  , -64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,   2202.7085 ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,   1557.55   ,\n       -40042.613  ,   -376.62527,  -8171.2603 ,      0.     ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,  -2202.7085 ,\n        21018.164  ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        31494.537  ,   -376.62527,  -8171.2603 ,      0.     ,\n        21018.164  ,   -376.62527,  -8171.2603 ,   1557.55   ],\n      dtype=float32)\n\nThis data corresponds to the results you would obtain directly\nfrom MAPDL with ESOL commands:\n\n>>> ansys.esol(nvar='2', elem=enum[0], node=enode[0][0], item='LS', comp=1)\n>>> ansys.vget(par='SD_LOC1', ir='2', tstrt='1') # store in a variable\n>>> ansys.read_float_parameter('SD_LOC1(1)')\n-4266.19\n\n\n\nelement_stress(rnum, principal=False, in_element_coord_sys=False, **kwargs)\n\nRetrieves the element component stresses.\n\nEquivalent ANSYS command: PRESOL, S\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nprincipal (bool, optional) – Returns principal stresses instead of component stresses.\nDefault False.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – ANSYS element numbers corresponding to each element.\n\nelement_stress (list) – Stresses at each element for each node for Sx Sy Sz Sxy\nSyz Sxz or SIGMA1, SIGMA2, SIGMA3, SINT, SEQV when\nprincipal is True.\n\nenode (list) – Node numbers corresponding to each element’s stress\nresults.  One list entry for each element.\n\nExamples\n\nElement component stress for the first result set.\n\n>>> rst.element_stress(0)\n\nElement principal stress for the first result set.\n\n>>> enum, element_stress, enode = result.element_stress(0, principal=True)\n\nNotes\n\nShell stresses for element 181 are returned for top and bottom\nlayers.  Results are ordered such that the top layer and then\nthe bottom layer is reported.\n\n\n\nproperty filename: str\n\nString form of the filename. This property is read-only.\n\n\n\nproperty materials\n\nResult file material properties.\n\nReturns\n\nDictionary of Materials.  Keys are the material numbers,\nand each material is a dictionary of the material\nproperrties of that material with only the valid entries filled.\n\nReturn type\n\ndict\n\nNotes\n\nMaterial properties:\n\nEX : Elastic modulus, element x direction (Force/Area)\n\nEY : Elastic modulus, element y direction (Force/Area)\n\nEZ : Elastic modulus, element z direction (Force/Area)\n\nALPX : Coefficient of thermal expansion, element x direction (Strain/Temp)\n\nALPY : Coefficient of thermal expansion, element y direction (Strain/Temp)\n\nALPZ : Coefficient of thermal expansion, element z direction (Strain/Temp)\n\nREFT : Reference temperature (as a property) [TREF]\n\nPRXY : Major Poisson’s ratio, x-y plane\n\nPRYZ : Major Poisson’s ratio, y-z plane\n\nPRX  Z : Major Poisson’s ratio, x-z plane\n\nNUXY : Minor Poisson’s ratio, x-y plane\n\nNUYZ : Minor Poisson’s ratio, y-z plane\n\nNUXZ : Minor Poisson’s ratio, x-z plane\n\nGXY : Shear modulus, x-y plane (Force/Area)\n\nGYZ : Shear modulus, y-z plane (Force/Area)\n\nGXZ : Shear modulus, x-z plane (Force/Area)\n\nDAMP : K matrix multiplier for damping [BETAD] (Time)\n\nMU\n\nCoefficient of friction (or, for FLUID29 and FLUID30\n\nelements, boundary admittance)\n\nDENS : Mass density (Mass/Vol)\n\nC : Specific heat (Heat/Mass*Temp)\n\nENTH : Enthalpy (e DENS*C d(Temp)) (Heat/Vol)\n\nKXX\n\nThermal conductivity, element x direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKYY\n\nThermal conductivity, element y direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKZZ\n\nThermal conductivity, element z direction\n\n(Heat*Length / (Time*Area*Temp))\n\nHF : Convection (or film) coefficient (Heat / (Time*Area*Temp))\n\nEMIS : Emissivity\n\nQRATE : Heat generation rate (MASS71 element only) (Heat/Time)\n\nVISC : Viscosity (Force*Time / Length2)\n\nSONC : Sonic velocity (FLUID29 and FLUID30 elements only) (Length/Time)\n\nRSVX : Electrical resistivity, element x direction (Resistance*Area / Length)\n\nRSVY : Electrical resistivity, element y direction (Resistance*Area / Length)\n\nRSVZ : Electrical resistivity, element z direction (Resistance*Area / Length)\n\nPERX : Electric permittivity, element x direction (Charge2 / (Force*Length))\n\nPERY : Electric permittivity, element y direction (Charge2 / (Force*Length))\n\nPERZ : Electric permittivity, element z direction (Charge2 / (Force*Length))\n\nMURX : Magnetic relative permeability, element x direction\n\nMURY : Magnetic relative permeability, element y direction\n\nMURZ : Magnetic relative permeability, element z direction\n\nMGXX : Magnetic coercive force, element x direction (Charge / (Length*Time))\n\nMGYY : Magnetic coercive force, element y direction (Charge / (Length*Time))\n\nMGZZ : Magnetic coercive force, element z direction (Charge / (Length*Time))\n\nMaterials may contain the key \"stress_failure_criteria\", which\ncontains failure criteria information for temperature-dependent stress\nlimits. This includes the following keys:\n\nXTEN : Allowable tensile stress or strain in the x-direction. (Must\nbe positive.)\n\nXCMP : Allowable compressive stress or strain in the\nx-direction. (Defaults to negative of XTEN.)\n\nYTEN : Allowable tensile stress or strain in the y-direction. (Must\nbe positive.)\n\nYCMP : Allowable compressive stress or strain in the\ny-direction. (Defaults to negative of YTEN.)\n\nZTEN : Allowable tensile stress or strain in the z-direction. (Must\nbe positive.)\n\nZCMP : Allowable compressive stress or strain in the\nz-direction. (Defaults to negative of ZTEN.)\n\nXY : Allowable XY stress or shear strain. (Must be positive.)\n\nYZ : Allowable YZ stress or shear strain. (Must be positive.)\n\nXZ : Allowable XZ stress or shear strain. (Must be positive.)\n\nXYCP : XY coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nYZCP : YZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZCP : XZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZIT : XZ tensile inclination parameter for Puck failure index (default =\n0.0)\n\nXZIC : XZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIT : YZ tensile inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIC : YZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nExamples\n\nReturn the material properties from the example result\nfile. Note that the keys of rst.materials is the material\ntype.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.materials\n{1: {'EX': 16900000.0, 'NUXY': 0.31, 'DENS': 0.00041408}}\n\n\n\nproperty mesh\n\nMesh from result file.\n\nExamples\n\n>>> rst.mesh\nANSYS Mesh\n  Number of Nodes:              1448\n  Number of Elements:           226\n  Number of Element Types:      1\n  Number of Node Components:    0\n  Number of Element Components: 0\n\n\n\nproperty n_results\n\nNumber of results\n\n\n\nproperty n_sector\n\nNumber of sectors\n\n\n\nnodal_acceleration(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal accelerations.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_acceleration(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_boundary_conditions(rnum)\n\nNodal boundary conditions for a given result number.\n\nThese nodal boundary conditions are generally set with the\nAPDL command D.  For example, D, 25, UX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with boundary conditions.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith boundary conditions.  See rst.result_dof for the\ndegrees of freedom associated with each index.\n\nbc (np.ndarray) – Boundary conditions.\n\nExamples\n\nPrint the boundary conditions where:\n- Node 3 is fixed\n- Node 25 has UX=0.001\n- Node 26 has UY=0.0011\n- Node 27 has UZ=0.0012\n\n>>> rst.nodal_boundary_conditions(0)\n(array([ 3,  3,  3, 25, 26, 27], dtype=int32),\narray([1, 2, 3, 1, 2, 3], dtype=int32),\narray([0.    , 0.    , 0.    , 0.001 , 0.0011, 0.0012]))\n\n\n\nnodal_displacement(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_elastic_strain(rnum, nodes=None)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nEquivalent MAPDL command: PRNSOL, EPEL\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nelastic_strain (np.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0)\n\nReturn the nodal elastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal elastic strain just for the nodes from 20 through 50.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_input_force(rnum)\n\nNodal input force for a given result number.\n\nNodal input force is generally set with the APDL command\nF.  For example, F, 25, FX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with nodal forces.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith input force.  See rst.result_dof for the degrees\nof freedom associated with each index.\n\nforce (np.ndarray) – Nodal input force.\n\nExamples\n\nPrint the nodal input force where:\n- Node 25 has FX=20\n- Node 26 has FY=30\n- Node 27 has FZ=40\n\n>>> rst.nodal_input_force(0)\n(array([ 71,  52, 127], dtype=int32),\n array([2, 1, 3], dtype=int32),\n array([30., 20., 40.]))\n\n\n\nnodal_plastic_strain(rnum, nodes=None)\n\nNodal component plastic strains.\n\nThis record contains strains in the order:\nX, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains are always values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nplastic_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0)\n\nReturn the nodal plastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal plastic strain just for the nodes from 20\nthrough 50.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes=range(20, 51))\n\n\n\nnodal_reaction_forces(rnum)\n\nNodal reaction forces.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nrforces (np.ndarray) – Nodal reaction forces for each degree of freedom.\n\nnnum (np.ndarray) – Node numbers corresponding to the reaction forces.  Node\nnumbers may be repeated if there is more than one degree\nof freedom for each node.\n\ndof (np.ndarray) – Degree of freedom corresponding to each node using the\nMAPDL degree of freedom reference table.  See\nrst.result_dof for the corresponding degrees of\nfreedom for a given solution.\n\nExamples\n\nGet the nodal reaction forces for the first result and print\nthe reaction forces of a single node.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rforces, nnum, dof = rst.nodal_reaction_forces(0)\n>>> dof_ref = rst.result_dof(0)\n>>> rforces[:3], nnum[:3], dof[:3], dof_ref\n(array([  24102.21376091, -109357.01854005,   22899.5303263 ]),\n array([4142, 4142, 4142]),\n array([1, 2, 3], dtype=int32),\n ['UX', 'UY', 'UZ'])\n\n\n\nnodal_solution(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_static_forces(rnum, nodes=None)\n\nReturn the nodal forces averaged at the nodes.\n\nNodal forces are computed on an element by element basis, and\nthis method averages the nodal forces for each element for\neach node.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nforces (np.ndarray) – Averaged nodal forces.  Array is sized [nnod x numdof]\nwhere nnod is the number of nodes and numdof is the\nnumber of degrees of freedom for this solution.\n\nExamples\n\nLoad the nodal static forces for the first result using the\nexample hexahedral result file.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> nnum, forces = rst.nodal_static_forces(0)\n\nReturn the nodal static forces just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes='MY_COMPONENT')\n\nReturn the nodal static forces just for the nodes from 20 through 50.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a a nodal will be NAN.  These are generally\nmidside (quadratic) nodes.\n\n\n\nnodal_stress(rnum, nodes=None)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at X, Y, Z, XY, YZ, XZ averaged at each corner\nnode.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.nodal_stress(0)\n\nReturn the nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS command: PRNSOL, S\n\n\n\nnodal_temperature(rnum, nodes=None, **kwargs)\n\nRetrieves the temperature for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL command: PRNSOL, TEMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, temp = rst.nodal_temperature(0)\n\nReturn the temperature just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, temp = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the temperature just for the nodes from 20 through 50.\n\n>>> nnum, temp = rst.nodal_solution(0, nodes=range(20, 51))\n\n\n\nnodal_thermal_strain(rnum, nodes=None)\n\nNodal component thermal strain.\n\nThis record contains strains in the order X, Y, Z, XY, YZ, XZ,\nEQV, and eswell (element swelling strain).  Thermal strains\nare always values at the integration points moved to the\nnodes.\n\nEquivalent MAPDL command: PRNSOL, EPTH, COMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nReturn the nodal thermal strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal thermal strain just for the nodes from 20 through 50.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes=range(20, 51))\n\n\n\nnodal_time_history(solution_type='NSL', in_nodal_coord_sys=False)\n\nThe DOF solution for each node for all result sets.\n\nThe nodal results are returned returned in the global\ncartesian coordinate system or nodal coordinate system.\n\nParameters\n\nsolution_type (str, optional) – The solution type.  Must be either nodal displacements\n('NSL'), nodal velocities ('VEL') or nodal\naccelerations ('ACC').\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate system.\nDefault False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Nodal solution for all result sets.  Array is sized\nrst.nsets x nnod x Sumdof, which is the number of\ntime steps by number of nodes by degrees of freedom.\n\n\n\nnodal_velocity(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal velocities.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_velocity(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nproperty node_components\n\nDictionary of ansys node components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.node_components.keys()\ndict_keys(['ECOMP1', 'ECOMP2', 'ELEM_COMP'])\n>>> rst.node_components['NODE_COMP']\narray([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n      20], dtype=int32)\n\n\n\noverwrite_element_solution_record(data, rnum, solution_type, element_id)\n\nOverwrite element solution record.\n\nThis method replaces solution data for of an element at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\ndata (list or np.ndarray) – Data that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nelement_id (int) – Ansys element number (e.g. 1)\n\nExamples\n\nOverwrite the elastic strain record for element 1 for the\nfirst result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = np.random.random(56)\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL', 1)\n\n\n\noverwrite_element_solution_records(element_data, rnum, solution_type)\n\nOverwrite element solution record.\n\nThis method replaces solution data for a set of elements at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\nelement_data (dict) – Dictionary of results that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nExamples\n\nOverwrite the elastic strain record for elements 1 and 2 with\nfor the first result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = {1: np.random.random(56),\n            2: np.random.random(56)}\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL')\n\n\n\nparse_coordinate_system()\n\nReads in coordinate system information from a binary result file.\n\nReturns\n\nc_systems – Dictionary containing one entry for each defined coordinate system.\nIf no non-standard coordinate systems have been defined, an empty\ndictionary will be returned.  First coordinate system is assumed to\nbe global cartesian.\n\nReturn type\n\ndict\n\nNotes\n\neuler angles : [THXY, THYZ, THZX]\n\nFirst rotation about local Z (positive X toward Y).\n\nSecond rotation about local X (positive Y toward Z).\n\nThird rotation about local Y (positive Z toward X).\n\nPAR1\nUsed for elliptical, spheroidal, or toroidal systems. If KCS =\n1 or 2, PAR1 is the ratio of the ellipse Y-axis radius to\nX-axis radius (defaults to 1.0 (circle)). If KCS = 3, PAR1 is\nthe major radius of the torus.\n\nPAR2\nUsed for spheroidal systems. If KCS = 2, PAR2 = ratio of\nellipse Z-axis radius to X-axis radius (defaults to 1.0\n(circle)).\n\nCoordinate system type:\n\n0: Cartesian\n\n1: Cylindrical (circular or elliptical)\n\n2: Spherical (or spheroidal)\n\n3: Toroidal\n\n\n\nparse_step_substep(user_input)\n\nConverts (step, substep) to a cumulative index\n\n\n\nproperty pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nplot(node_components=None, element_components=None, sel_type_all=True, **kwargs)\n\nPlot result geometry\n\nParameters\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rst.plot()\n\nPlot just the element component ‘ROTOR_SHAFT’\n\n>>> rst.plot(element_components='ROTOR_SHAFT')\n\nPlot two node components\n>>> rst.plot(node_components=[‘MY_COMPONENT’, ‘MY_OTHER_COMPONENT’])\n\n\n\nplot_cylindrical_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal_stress in the cylindrical coordinate system.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"R\"\n- \"THETA\"\n- \"Z\"\n- \"RTHETA\"\n- \"THETAZ\"\n- \"RZ\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal stress in the radial direction.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_cylindrical_nodal_stress(0, 'R')\n\n\n\nplot_element_result(rnum, result_type, item_index, in_element_coord_sys=False, **kwargs)\n\nPlot an element result.\n\nParameters\n\nrnum (int) – Result number.\n\nresult_type (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nitem_index (int) – Index of the data item for each node within the element.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\nReturns\n\nnnum (np.ndarray) – ANSYS node numbers\n\nresult (np.ndarray) – Array of result data\n\n\n\nplot_nodal_displacement(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)\n\n\n\nplot_nodal_elastic_strain(rnum, comp, scalar_bar_args={'title': 'EQV Nodal Elastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal elastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_elastic_strain(0)\n\n\n\nplot_nodal_plastic_strain(rnum, comp, scalar_bar_args={'title': 'Nodal Plastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nExamples\n\nPlot plastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_plastic_strain(0)\n\n\n\nplot_nodal_solution(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)\n\n\n\nplot_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the stresses at each node in the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – 3 x 3 vtk camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the X component nodal stress while showing displacement.\n\n>>> rst.plot_nodal_stress(0, comp='x', show_displacement=True)\n\n\n\nplot_nodal_temperature(rnum, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal temperature\n\nParameters\n\nrnum (int) – Result number\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot temperature of a result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_nodal_temperature(0)\n\nPlot while showing edges and disabling lighting\n\n>>> result.plot_nodal_temperature(0, show_edges=True, lighting=False)\n\n\n\nplot_nodal_thermal_strain(rnum, comp=None, scalar_bar_args={'title': 'Nodal Thermal Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component thermal strains.\n\nEquivalent MAPDL command: PLNSOL, EPTH, COMP\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot thermal strain for result 0 of verification manual example 33.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_thermal_strain(0)\n\n\n\nplot_principal_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the equivalent von mises stress.\n\n>>> rst.plot_principal_nodal_stress(0, comp='SEQV')\n\n\n\nprincipal_nodal_stress(rnum, nodes=None)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nExamples\n\nLoad the principal nodal stress for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.principal_nodal_stress(0)\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\nInternal averaging algorithm averages the component values\nfrom the elements at a common node and then calculates the\nprincipal using the averaged value.\n\nSee the MAPDL AVPRIN command for more details.\nansys-mapdl-reader uses the default AVPRIN, 0 option.\n\n\n\nresult_dof(rnum)\n\nReturn a list of degrees of freedom for a given result number.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\ndof – List of degrees of freedom.\n\nReturn type\n\nlist\n\nExamples\n\n>>> rst.result_dof(0)\n['UX', 'UY', 'UZ']\n\n\n\nsave_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nExamples\n\nWrite nodal results as a binary vtk file.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result.\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\n\n\nproperty section_data\n\nThe section data from the result file\n\nReturns\n\nsection_data – Dictionary of the section data with the section numbers as\nkeys.\n\nReturn type\n\ndict\n\nNotes\n\nThere is limited documentation on how ANSYS stores the\nsections within a result file, and as such it may be difficult\nto interpret the section data for a given model.\n\n\n\nsolution_info(rnum)\n\nReturn an informative dictionary of solution data for a\nresult.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nheader – Double precision solution header data.\n\nReturn type\n\ndict\n\nExamples\n\nExtract the solution info from a sample example result file.\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_pontoon()\n>>> rst.solution_info(0)\n{'cgcent': [],\n 'fatjack': [],\n 'timfrq': 44.85185724963714,\n 'lfacto': 1.0,\n 'lfactn': 1.0,\n 'cptime': 3586.4873046875,\n 'tref': 71.6,\n 'tunif': 71.6,\n 'tbulk': 293.0,\n 'volbase': 0.0,\n 'tstep': 0.0,\n '__unused': 0.0,\n 'accel_x': 0.0,\n 'accel_y': 0.0,\n 'accel_z': 0.0,\n 'omega_v_x': 0.0,\n 'omega_v_y': 0.0,\n 'omega_v_z': 0.0,\n 'omega_a_x': 0.0,\n 'omega_a_y': 0.0,\n 'omega_a_z': 0.0,\n 'omegacg_v_x': 0.0,\n 'omegacg_v_y': 0.0,\n 'omegacg_v_z': 0.0,\n 'omegacg_a_x': 0.0,\n 'omegacg_a_y': 0.0,\n 'omegacg_a_z': 0.0,\n 'dval1': 0.0,\n 'pCnvVal': 0.0}\n\nNotes\n\nThe keys of the solution header are described below:\n\ntimfrq\n\nTime value (or frequency value, for a modal or\n\nharmonic analysis)\n\nlfacto\n\nthe “old” load factor (used in ramping a load\n\nbetween old and new values)\n\nlfactn  : The “new” load factor\n\ncptime  : Elapsed CPU time (in seconds)\n\ntref    : The reference temperature\n\ntunif   : The uniform temperature\n\ntbulk   : Bulk temp for FLOTRAN film coefs.\n\nVolBase : Initial total volume for VOF\n\ntstep   : Time Step size for FLOTRAN analysis\n\n0.0     : Position not used\n\naccel   : Linear acceleration terms\n\nomega\n\nAngular velocity (first 3 terms) and angular acceleration\n\n(second 3 terms)\n\nomegacg\n\nAngular velocity (first 3 terms) and angular\n\nacceleration (second 3 terms) these\nvelocity/acceleration terms are computed about the\ncenter of gravity\n\ncgcent  : (X,y,z) location of center of gravity\n\nfatjack : Fatjack ocean wave data (wave height and period)\n\ndval1\n\nIf pmeth=0: FATJACK ocean wave direction\n\nif pmeth=1: p-method convergence values\n\npCnvVal : P-method convergence values\n\n\n\ntext_result_table(rnum)\n\nReturns a text result table for plotting\n\n\n\nproperty version\n\nThe version of MAPDL used to generate this result file.\n\nExamples\n\n>>> rst.version\n20.1\n\n\n\nwrite_tables(filename: str | Path)\n\nWrite binary tables to ASCII.  Assumes int32\n\nParameters\n\nfilename (str, pathlib.Path) – Filename to write the tables to.\n\nExamples\n\n>>> rst.write_tables('tables.txt')\n\n\n\nclass ansys.mapdl.reader.cyclic_reader.CyclicResult(filename, read_mesh: bool = True)\n\nAdds cyclic functionality to the result class\n\n\n\nanimate_nodal_displacement(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )\n\n\n\nanimate_nodal_solution(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )\n\n\n\nproperty full_rotor\n\nUnstructuredGrid of the full replicated rotor\n\n\n\nharmonic_index_to_cumulative(hindex, mode)\n\nConverts a harmonic index and a 0 index mode number to a\ncumulative result index.\n\nHarmonic indices are stored as positive and negative pairs for\nmodes other than 0 and N/nsectors.\n\nParameters\n\nhindex (int) – Harmonic index.  Must be less than or equal to nsectors/2.\nMay be positive or negative\n\nmode (int) – Mode number.  0 based indexing.  Access mode pairs by with\na negative/positive harmonic index.\n\nReturns\n\nrnum – Cumulative index number.  Zero based indexing.\n\nReturn type\n\nint\n\n\n\nproperty harmonic_indices\n\nHarmonic indices of the result file.\n\nHarmonic index is simply the Nodal Diameter of the mode.  This\nis defined as the number of complete sine waves that pass\nthrough the circumference.\n\nExamples\n\n>>> rst.harmonic_indices\narray([ 0,  0,  0,  0,  0,  0, -1,  1, -1,  1,  1, -1,\n       -2,  2, -2,  2, -2,  2,  3,  3,  3,  3,  3,  3], dtype=int32)\n\n\n\nproperty mode_table\n\nUnique modes for cyclic results\n\n\n\nnodal_displacement(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1).\n\n\n\nnodal_elastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in radians.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nelastic_strain (numpy.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> nnum, elastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_plastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component plastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nplastic_strain (numpy.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first result.\n\n>>> nnum, plastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_solution(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1).\n\n\n\nnodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at Sx Sy Sz Sxy Syz Sxz averaged at each corner\nnode.  For the corresponding node numbers, see where\nresult is the result object.\n\nExamples\n\n>>> nnum, stress = rst.nodal_stress(0)\n\nNotes\n\nNodes without a stress value will be NAN.\n\n\n\nnodal_temperature(rnum, full_rotor=False)\n\nRetrieves the temperature for each node in the solution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL commands:\nPRNSOL, TEMP\nPRNSOL, BFE\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> nnum, stress = rst.nodal_temperature(0)\n\n\n\nnodal_thermal_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component thermal strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV, and eswell\n(element swelling strain).  Thermal strains are always values\nat the integration points moved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first result.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nplot(**kwargs)\n\nPlot the full rotor geometry.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot()\n\nSave a screenshot of the rotor\n\n>>> rst.plot(screenshot='rotor.png')\n\n\n\nplot_nodal_elastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal elastic strain for an academic rotor.\n\n>>> result.plot_nodal_elastic_strain(0, 'X')\n\n\n\nplot_nodal_plastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal plastic strain for an academic rotor\n\n>>> result.plot_nodal_plastic_strain(0)\n\n\n\nplot_nodal_solution(rnum, comp='norm', phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal solution (generally displacement).\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are ‘x’, ‘y’, ‘z’,\nand ‘norm’, corresponding to the x direction, y direction,\nz direction, and the normalized direction:\n(x**2 + y**2 + z**2)**0.5\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the displacement of the first cyclic result.\n\n>>> result.plot_nodal_solution(0)\n\n\n\nplot_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal stress of a given component\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the \"Z\" nodal stress of the first cyclic result.\n\n>>> result.plot_nodal_stress(0, comp=\"Z\")\n\n\n\nplot_nodal_temperature(rnum, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, overlay_wireframe=False, add_text=True, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal temperature.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand the sector solution and plot the full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal temperature of a rotor for the first result.\n\n>>> result.plot_nodal_temperature(0)\n\n\n\nplot_nodal_thermal_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal thermal strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\" (element swelling strain)\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0.\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal thermal strain for an academic rotor\n\n>>> rst.plot_nodal_thermal_strain(0)\n\n\n\nplot_principal_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the von Mises stress of the first cyclic result.\n\n>>> result.plot_principal_nodal_stress(0, comp='SEQV')\n\n\n\nplot_sectors(**kwargs)\n\nPlot the full rotor and individually color the sectors.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot_sectors()\n\nSave a screenshot of the sectors\n\n>>> rst.plot_sectors(screenshot='sectors.png')\n\n\n\nprincipal_nodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\n\n\nsave_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True, expand_cyclic=True, merge_sectors=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nexpand_cyclic (bool, default: True.) – When True, expands cyclic results by writing out the result as\na full cyclic result rather than as a single cyclic sector.\n\nmerge_sectors (bool, default: False) – When expand_cyclic is True and this parameter is True,\nsectors will be merged to create one unified grid. Set this to\nFalse to not merge nodes between sectors.\n\nNotes\n\nNodal solutions are stored within the point_data attribute of the\nunstructured grid and can be accessed after reading in the result with\npyvista with:\n\nSee the examples section for more details.\n\nExamples\n\nWrite nodal results as a binary vtk file. Larger file size, loads quickly.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer. This file is more compressed compressed but\nwill load slower.\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\nRead in the results using pyvista.read(). Plot the ‘Z’ component of\nthe first mode’s -2 nodal diameter nodal displacement.\n\n>>> import pyvista as pv\n>>> grid = pv.read('results.vtk')\n>>> grid.plot(scalars=\"Nodal solution (0, -2)\", component=2)\n\nDo not merge sectors when saving the results and separate sectors into\nmultiple blocks within pyvista.\n\n>>> rst.save_as_vtk('results.vtk', merge_sectors=False)\n>>> grid = pv.read('results.vtk')\n>>> mblock = grid.split_bodies()"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result","title":"Reading MAPDL Result Files > Result Object Methods > Result","text":"class ansys.mapdl.reader.rst.Result(filename, read_mesh=True, parse_vtk=True, **kwargs)\n\nReads a binary ANSYS result file.\n\nParameters\n\nfilename (str, pathlib.Path, optional) – Filename of the ANSYS binary result file.\n\nignore_cyclic (bool, optional) – Ignores any cyclic properties.\n\nread_mesh (bool, optional) – Debug parameter.  Set to False to disable reading in the\nmesh from the result file.\n\nparse_vtk (bool, optional) – Set to False to skip the parsing the mesh as a VTK\nUnstructuredGrid, which might take a long time for large models.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n\n\n\nanimate_nodal_displacement(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)\n\n\n\nanimate_nodal_solution(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)\n\n\n\nanimate_nodal_solution_set(rnums=None, comp='norm', node_components=None, element_components=None, sel_type_all=True, loop=True, movie_filename=None, add_text=True, fps=20, **kwargs)\n\nAnimate a set of nodal solutions.\n\nAnimates the scalars of all the result sets.  Best when used\nwith a series of static analyses.\n\nrnums\n\ncollection.Iterable\n\nRange or list containing the zero based indexed cumulative\nresult numbers to animate.\n\ncomp\n\nstr, optional\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.  Not\napplicable for a thermal analysis.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.\n\nmovie_filename\n\nstr, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported.  See\nimagio.get_writer.  A single loop of the mode will be\nrecorded.\n\nadd_text\n\nbool, optional\n\nAdds information about the result to the animation.\n\nfps\n\nint, optional\n\nFrames per second.  Defaults to 20 and limited to hardware\ncapabilities and model density. Carries over to movies\ncreated by providing the movie_filename argument,\nbut not to gifs.\n\nkwargs\n\noptional keyword arguments, optional\n\nSee help(pyvista.Plot) for additional keyword arguments.\n\nExamples\n\nAnimate all results\n\n>>> rst.animate_nodal_solution_set()\n\nAnimate every 50th result in a set of results and save to a\ngif.  Use the “zx” camera position to view the ZX plane from\nthe top down.\n\n>>> rsets = range(0, rst.nsets, 50)\n>>> rst.animate_nodal_solution_set(rsets,\n...                                scalar_bar_args={'title': 'My Animation'},\n...                                lighting=False, cpos='zx',\n...                                movie_filename='example.gif')\n\n\n\nproperty available_results\n\nAvailable result types.\n\nExamples\n\n>>> rst.available_results\nAvailable Results:\nENS : Nodal stresses\nENG : Element energies and volume\nEEL : Nodal elastic strains\nEPL : Nodal plastic strains\nETH : Nodal thermal strains (includes swelling strains)\nEUL : Element euler angles\nENL : Nodal nonlinear items, e.g. equivalent plastic strains\nEPT : Nodal temperatures\nNSL : Nodal displacements\nRF  : Nodal reaction forces\n\n\n\ncs_4x4(cs_cord, as_vtk_matrix=False)\n\nReturn a 4x4 transformation matrix for a given coordinate system.\n\nParameters\n\ncs_cord (int) – Coordinate system index.\n\nas_vtk_matrix (bool, default: False) – Return the transformation matrix as a vtkMatrix4x4.\n\nReturns\n\nMatrix or vtkMatrix4x4 depending on the value of as_vtk_matrix.\n\nReturn type\n\nnp.ndarray | vtk.vtkMatrix4x4\n\nNotes\n\nValues 11 and greater correspond to local coordinate systems\n\nExamples\n\nReturn the transformation matrix for coordinate system 1.\n\n>>> tmat = rst.cs_4x4(1)\n>>> tmat\narray([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]])\n\nReturn the transformation matrix for coordinate system 5. This\ncorresponds to CSYS, 5, the cylindrical with global Cartesian Y as\nthe axis of rotation.\n\n>>> tmat = rst.cs_4x4(5)\n>>> tmat\narray([[ 1.,  0.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.]])\n\n\n\ncylindrical_nodal_stress(rnum, nodes=None)\n\nRetrieves the stresses for each node in the solution in the\ncylindrical coordinate system as the following values:\n\nR, THETA, Z, RTHETA, THETAZ, and RZ\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at R, THETA, Z, RTHETA, THETAZ, RZ averaged\nat each corner node where R is radial.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.cylindrical_nodal_stress(0)\n\nReturn the cylindrical nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS commands:\nRSYS, 1\nPRNSOL, S\n\n\n\nproperty element_components\n\nDictionary of ansys element components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.element_components\n{'ECOMP1': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], dtype=int32),\n'ECOMP2': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n        14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32),\n'ELEM_COMP': array([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        16, 17, 18, 19, 20], dtype=int32)}\n\n\n\nelement_lookup(element_id)\n\nIndex of the element the element within the result mesh\n\n\n\nelement_solution_data(rnum, datatype, sort=True, **kwargs)\n\nRetrieves element solution data.  Similar to ETABLE.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ndatatype (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nsort (bool) – Sort results by element number.  Default True.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – Element numbers.\n\nelement_data (list) – List with one data item for each element.\n\nenode (list) – Node numbers corresponding to each element.\nresults.  One list entry for each element.\n\nNotes\n\nSee ANSYS element documentation for available items for each\nelement type.  See:\n\nhttps://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_elem/\n\nExamples\n\nRetrieve “LS” solution results from an PIPE59 element for result set 1\n\n>>> enum, edata, enode = result.element_solution_data(0, datatype='ENS')\n>>> enum[0]  # first element number\n>>> enode[0]  # nodes belonging to element 1\n>>> edata[0]  # data belonging to element 1\narray([ -4266.19   ,   -376.18857,  -8161.785  , -64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,   2202.7085 ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,   1557.55   ,\n       -40042.613  ,   -376.62527,  -8171.2603 ,      0.     ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,  -2202.7085 ,\n        21018.164  ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        31494.537  ,   -376.62527,  -8171.2603 ,      0.     ,\n        21018.164  ,   -376.62527,  -8171.2603 ,   1557.55   ],\n      dtype=float32)\n\nThis data corresponds to the results you would obtain directly\nfrom MAPDL with ESOL commands:\n\n>>> ansys.esol(nvar='2', elem=enum[0], node=enode[0][0], item='LS', comp=1)\n>>> ansys.vget(par='SD_LOC1', ir='2', tstrt='1') # store in a variable\n>>> ansys.read_float_parameter('SD_LOC1(1)')\n-4266.19\n\n\n\nelement_stress(rnum, principal=False, in_element_coord_sys=False, **kwargs)\n\nRetrieves the element component stresses.\n\nEquivalent ANSYS command: PRESOL, S\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nprincipal (bool, optional) – Returns principal stresses instead of component stresses.\nDefault False.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – ANSYS element numbers corresponding to each element.\n\nelement_stress (list) – Stresses at each element for each node for Sx Sy Sz Sxy\nSyz Sxz or SIGMA1, SIGMA2, SIGMA3, SINT, SEQV when\nprincipal is True.\n\nenode (list) – Node numbers corresponding to each element’s stress\nresults.  One list entry for each element.\n\nExamples\n\nElement component stress for the first result set.\n\n>>> rst.element_stress(0)\n\nElement principal stress for the first result set.\n\n>>> enum, element_stress, enode = result.element_stress(0, principal=True)\n\nNotes\n\nShell stresses for element 181 are returned for top and bottom\nlayers.  Results are ordered such that the top layer and then\nthe bottom layer is reported.\n\n\n\nproperty filename: str\n\nString form of the filename. This property is read-only.\n\n\n\nproperty materials\n\nResult file material properties.\n\nReturns\n\nDictionary of Materials.  Keys are the material numbers,\nand each material is a dictionary of the material\nproperrties of that material with only the valid entries filled.\n\nReturn type\n\ndict\n\nNotes\n\nMaterial properties:\n\nEX : Elastic modulus, element x direction (Force/Area)\n\nEY : Elastic modulus, element y direction (Force/Area)\n\nEZ : Elastic modulus, element z direction (Force/Area)\n\nALPX : Coefficient of thermal expansion, element x direction (Strain/Temp)\n\nALPY : Coefficient of thermal expansion, element y direction (Strain/Temp)\n\nALPZ : Coefficient of thermal expansion, element z direction (Strain/Temp)\n\nREFT : Reference temperature (as a property) [TREF]\n\nPRXY : Major Poisson’s ratio, x-y plane\n\nPRYZ : Major Poisson’s ratio, y-z plane\n\nPRX  Z : Major Poisson’s ratio, x-z plane\n\nNUXY : Minor Poisson’s ratio, x-y plane\n\nNUYZ : Minor Poisson’s ratio, y-z plane\n\nNUXZ : Minor Poisson’s ratio, x-z plane\n\nGXY : Shear modulus, x-y plane (Force/Area)\n\nGYZ : Shear modulus, y-z plane (Force/Area)\n\nGXZ : Shear modulus, x-z plane (Force/Area)\n\nDAMP : K matrix multiplier for damping [BETAD] (Time)\n\nMU\n\nCoefficient of friction (or, for FLUID29 and FLUID30\n\nelements, boundary admittance)\n\nDENS : Mass density (Mass/Vol)\n\nC : Specific heat (Heat/Mass*Temp)\n\nENTH : Enthalpy (e DENS*C d(Temp)) (Heat/Vol)\n\nKXX\n\nThermal conductivity, element x direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKYY\n\nThermal conductivity, element y direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKZZ\n\nThermal conductivity, element z direction\n\n(Heat*Length / (Time*Area*Temp))\n\nHF : Convection (or film) coefficient (Heat / (Time*Area*Temp))\n\nEMIS : Emissivity\n\nQRATE : Heat generation rate (MASS71 element only) (Heat/Time)\n\nVISC : Viscosity (Force*Time / Length2)\n\nSONC : Sonic velocity (FLUID29 and FLUID30 elements only) (Length/Time)\n\nRSVX : Electrical resistivity, element x direction (Resistance*Area / Length)\n\nRSVY : Electrical resistivity, element y direction (Resistance*Area / Length)\n\nRSVZ : Electrical resistivity, element z direction (Resistance*Area / Length)\n\nPERX : Electric permittivity, element x direction (Charge2 / (Force*Length))\n\nPERY : Electric permittivity, element y direction (Charge2 / (Force*Length))\n\nPERZ : Electric permittivity, element z direction (Charge2 / (Force*Length))\n\nMURX : Magnetic relative permeability, element x direction\n\nMURY : Magnetic relative permeability, element y direction\n\nMURZ : Magnetic relative permeability, element z direction\n\nMGXX : Magnetic coercive force, element x direction (Charge / (Length*Time))\n\nMGYY : Magnetic coercive force, element y direction (Charge / (Length*Time))\n\nMGZZ : Magnetic coercive force, element z direction (Charge / (Length*Time))\n\nMaterials may contain the key \"stress_failure_criteria\", which\ncontains failure criteria information for temperature-dependent stress\nlimits. This includes the following keys:\n\nXTEN : Allowable tensile stress or strain in the x-direction. (Must\nbe positive.)\n\nXCMP : Allowable compressive stress or strain in the\nx-direction. (Defaults to negative of XTEN.)\n\nYTEN : Allowable tensile stress or strain in the y-direction. (Must\nbe positive.)\n\nYCMP : Allowable compressive stress or strain in the\ny-direction. (Defaults to negative of YTEN.)\n\nZTEN : Allowable tensile stress or strain in the z-direction. (Must\nbe positive.)\n\nZCMP : Allowable compressive stress or strain in the\nz-direction. (Defaults to negative of ZTEN.)\n\nXY : Allowable XY stress or shear strain. (Must be positive.)\n\nYZ : Allowable YZ stress or shear strain. (Must be positive.)\n\nXZ : Allowable XZ stress or shear strain. (Must be positive.)\n\nXYCP : XY coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nYZCP : YZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZCP : XZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZIT : XZ tensile inclination parameter for Puck failure index (default =\n0.0)\n\nXZIC : XZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIT : YZ tensile inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIC : YZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nExamples\n\nReturn the material properties from the example result\nfile. Note that the keys of rst.materials is the material\ntype.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.materials\n{1: {'EX': 16900000.0, 'NUXY': 0.31, 'DENS': 0.00041408}}\n\n\n\nproperty mesh\n\nMesh from result file.\n\nExamples\n\n>>> rst.mesh\nANSYS Mesh\n  Number of Nodes:              1448\n  Number of Elements:           226\n  Number of Element Types:      1\n  Number of Node Components:    0\n  Number of Element Components: 0\n\n\n\nproperty n_results\n\nNumber of results\n\n\n\nproperty n_sector\n\nNumber of sectors\n\n\n\nnodal_acceleration(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal accelerations.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_acceleration(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_boundary_conditions(rnum)\n\nNodal boundary conditions for a given result number.\n\nThese nodal boundary conditions are generally set with the\nAPDL command D.  For example, D, 25, UX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with boundary conditions.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith boundary conditions.  See rst.result_dof for the\ndegrees of freedom associated with each index.\n\nbc (np.ndarray) – Boundary conditions.\n\nExamples\n\nPrint the boundary conditions where:\n- Node 3 is fixed\n- Node 25 has UX=0.001\n- Node 26 has UY=0.0011\n- Node 27 has UZ=0.0012\n\n>>> rst.nodal_boundary_conditions(0)\n(array([ 3,  3,  3, 25, 26, 27], dtype=int32),\narray([1, 2, 3, 1, 2, 3], dtype=int32),\narray([0.    , 0.    , 0.    , 0.001 , 0.0011, 0.0012]))\n\n\n\nnodal_displacement(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_elastic_strain(rnum, nodes=None)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nEquivalent MAPDL command: PRNSOL, EPEL\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nelastic_strain (np.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0)\n\nReturn the nodal elastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal elastic strain just for the nodes from 20 through 50.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_input_force(rnum)\n\nNodal input force for a given result number.\n\nNodal input force is generally set with the APDL command\nF.  For example, F, 25, FX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with nodal forces.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith input force.  See rst.result_dof for the degrees\nof freedom associated with each index.\n\nforce (np.ndarray) – Nodal input force.\n\nExamples\n\nPrint the nodal input force where:\n- Node 25 has FX=20\n- Node 26 has FY=30\n- Node 27 has FZ=40\n\n>>> rst.nodal_input_force(0)\n(array([ 71,  52, 127], dtype=int32),\n array([2, 1, 3], dtype=int32),\n array([30., 20., 40.]))\n\n\n\nnodal_plastic_strain(rnum, nodes=None)\n\nNodal component plastic strains.\n\nThis record contains strains in the order:\nX, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains are always values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nplastic_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0)\n\nReturn the nodal plastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal plastic strain just for the nodes from 20\nthrough 50.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes=range(20, 51))\n\n\n\nnodal_reaction_forces(rnum)\n\nNodal reaction forces.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nrforces (np.ndarray) – Nodal reaction forces for each degree of freedom.\n\nnnum (np.ndarray) – Node numbers corresponding to the reaction forces.  Node\nnumbers may be repeated if there is more than one degree\nof freedom for each node.\n\ndof (np.ndarray) – Degree of freedom corresponding to each node using the\nMAPDL degree of freedom reference table.  See\nrst.result_dof for the corresponding degrees of\nfreedom for a given solution.\n\nExamples\n\nGet the nodal reaction forces for the first result and print\nthe reaction forces of a single node.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rforces, nnum, dof = rst.nodal_reaction_forces(0)\n>>> dof_ref = rst.result_dof(0)\n>>> rforces[:3], nnum[:3], dof[:3], dof_ref\n(array([  24102.21376091, -109357.01854005,   22899.5303263 ]),\n array([4142, 4142, 4142]),\n array([1, 2, 3], dtype=int32),\n ['UX', 'UY', 'UZ'])\n\n\n\nnodal_solution(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_static_forces(rnum, nodes=None)\n\nReturn the nodal forces averaged at the nodes.\n\nNodal forces are computed on an element by element basis, and\nthis method averages the nodal forces for each element for\neach node.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nforces (np.ndarray) – Averaged nodal forces.  Array is sized [nnod x numdof]\nwhere nnod is the number of nodes and numdof is the\nnumber of degrees of freedom for this solution.\n\nExamples\n\nLoad the nodal static forces for the first result using the\nexample hexahedral result file.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> nnum, forces = rst.nodal_static_forces(0)\n\nReturn the nodal static forces just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes='MY_COMPONENT')\n\nReturn the nodal static forces just for the nodes from 20 through 50.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a a nodal will be NAN.  These are generally\nmidside (quadratic) nodes.\n\n\n\nnodal_stress(rnum, nodes=None)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at X, Y, Z, XY, YZ, XZ averaged at each corner\nnode.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.nodal_stress(0)\n\nReturn the nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS command: PRNSOL, S\n\n\n\nnodal_temperature(rnum, nodes=None, **kwargs)\n\nRetrieves the temperature for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL command: PRNSOL, TEMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, temp = rst.nodal_temperature(0)\n\nReturn the temperature just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, temp = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the temperature just for the nodes from 20 through 50.\n\n>>> nnum, temp = rst.nodal_solution(0, nodes=range(20, 51))\n\n\n\nnodal_thermal_strain(rnum, nodes=None)\n\nNodal component thermal strain.\n\nThis record contains strains in the order X, Y, Z, XY, YZ, XZ,\nEQV, and eswell (element swelling strain).  Thermal strains\nare always values at the integration points moved to the\nnodes.\n\nEquivalent MAPDL command: PRNSOL, EPTH, COMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nReturn the nodal thermal strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal thermal strain just for the nodes from 20 through 50.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes=range(20, 51))\n\n\n\nnodal_time_history(solution_type='NSL', in_nodal_coord_sys=False)\n\nThe DOF solution for each node for all result sets.\n\nThe nodal results are returned returned in the global\ncartesian coordinate system or nodal coordinate system.\n\nParameters\n\nsolution_type (str, optional) – The solution type.  Must be either nodal displacements\n('NSL'), nodal velocities ('VEL') or nodal\naccelerations ('ACC').\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate system.\nDefault False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Nodal solution for all result sets.  Array is sized\nrst.nsets x nnod x Sumdof, which is the number of\ntime steps by number of nodes by degrees of freedom.\n\n\n\nnodal_velocity(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal velocities.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_velocity(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nproperty node_components\n\nDictionary of ansys node components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.node_components.keys()\ndict_keys(['ECOMP1', 'ECOMP2', 'ELEM_COMP'])\n>>> rst.node_components['NODE_COMP']\narray([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n      20], dtype=int32)\n\n\n\noverwrite_element_solution_record(data, rnum, solution_type, element_id)\n\nOverwrite element solution record.\n\nThis method replaces solution data for of an element at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\ndata (list or np.ndarray) – Data that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nelement_id (int) – Ansys element number (e.g. 1)\n\nExamples\n\nOverwrite the elastic strain record for element 1 for the\nfirst result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = np.random.random(56)\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL', 1)\n\n\n\noverwrite_element_solution_records(element_data, rnum, solution_type)\n\nOverwrite element solution record.\n\nThis method replaces solution data for a set of elements at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\nelement_data (dict) – Dictionary of results that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nExamples\n\nOverwrite the elastic strain record for elements 1 and 2 with\nfor the first result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = {1: np.random.random(56),\n            2: np.random.random(56)}\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL')\n\n\n\nparse_coordinate_system()\n\nReads in coordinate system information from a binary result file.\n\nReturns\n\nc_systems – Dictionary containing one entry for each defined coordinate system.\nIf no non-standard coordinate systems have been defined, an empty\ndictionary will be returned.  First coordinate system is assumed to\nbe global cartesian.\n\nReturn type\n\ndict\n\nNotes\n\neuler angles : [THXY, THYZ, THZX]\n\nFirst rotation about local Z (positive X toward Y).\n\nSecond rotation about local X (positive Y toward Z).\n\nThird rotation about local Y (positive Z toward X).\n\nPAR1\nUsed for elliptical, spheroidal, or toroidal systems. If KCS =\n1 or 2, PAR1 is the ratio of the ellipse Y-axis radius to\nX-axis radius (defaults to 1.0 (circle)). If KCS = 3, PAR1 is\nthe major radius of the torus.\n\nPAR2\nUsed for spheroidal systems. If KCS = 2, PAR2 = ratio of\nellipse Z-axis radius to X-axis radius (defaults to 1.0\n(circle)).\n\nCoordinate system type:\n\n0: Cartesian\n\n1: Cylindrical (circular or elliptical)\n\n2: Spherical (or spheroidal)\n\n3: Toroidal\n\n\n\nparse_step_substep(user_input)\n\nConverts (step, substep) to a cumulative index\n\n\n\nproperty pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nplot(node_components=None, element_components=None, sel_type_all=True, **kwargs)\n\nPlot result geometry\n\nParameters\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rst.plot()\n\nPlot just the element component ‘ROTOR_SHAFT’\n\n>>> rst.plot(element_components='ROTOR_SHAFT')\n\nPlot two node components\n>>> rst.plot(node_components=[‘MY_COMPONENT’, ‘MY_OTHER_COMPONENT’])\n\n\n\nplot_cylindrical_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal_stress in the cylindrical coordinate system.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"R\"\n- \"THETA\"\n- \"Z\"\n- \"RTHETA\"\n- \"THETAZ\"\n- \"RZ\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal stress in the radial direction.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_cylindrical_nodal_stress(0, 'R')\n\n\n\nplot_element_result(rnum, result_type, item_index, in_element_coord_sys=False, **kwargs)\n\nPlot an element result.\n\nParameters\n\nrnum (int) – Result number.\n\nresult_type (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nitem_index (int) – Index of the data item for each node within the element.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\nReturns\n\nnnum (np.ndarray) – ANSYS node numbers\n\nresult (np.ndarray) – Array of result data\n\n\n\nplot_nodal_displacement(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)\n\n\n\nplot_nodal_elastic_strain(rnum, comp, scalar_bar_args={'title': 'EQV Nodal Elastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal elastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_elastic_strain(0)\n\n\n\nplot_nodal_plastic_strain(rnum, comp, scalar_bar_args={'title': 'Nodal Plastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nExamples\n\nPlot plastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_plastic_strain(0)\n\n\n\nplot_nodal_solution(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)\n\n\n\nplot_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the stresses at each node in the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – 3 x 3 vtk camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the X component nodal stress while showing displacement.\n\n>>> rst.plot_nodal_stress(0, comp='x', show_displacement=True)\n\n\n\nplot_nodal_temperature(rnum, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal temperature\n\nParameters\n\nrnum (int) – Result number\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot temperature of a result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_nodal_temperature(0)\n\nPlot while showing edges and disabling lighting\n\n>>> result.plot_nodal_temperature(0, show_edges=True, lighting=False)\n\n\n\nplot_nodal_thermal_strain(rnum, comp=None, scalar_bar_args={'title': 'Nodal Thermal Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component thermal strains.\n\nEquivalent MAPDL command: PLNSOL, EPTH, COMP\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot thermal strain for result 0 of verification manual example 33.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_thermal_strain(0)\n\n\n\nplot_principal_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the equivalent von mises stress.\n\n>>> rst.plot_principal_nodal_stress(0, comp='SEQV')\n\n\n\nprincipal_nodal_stress(rnum, nodes=None)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nExamples\n\nLoad the principal nodal stress for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.principal_nodal_stress(0)\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\nInternal averaging algorithm averages the component values\nfrom the elements at a common node and then calculates the\nprincipal using the averaged value.\n\nSee the MAPDL AVPRIN command for more details.\nansys-mapdl-reader uses the default AVPRIN, 0 option.\n\n\n\nresult_dof(rnum)\n\nReturn a list of degrees of freedom for a given result number.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\ndof – List of degrees of freedom.\n\nReturn type\n\nlist\n\nExamples\n\n>>> rst.result_dof(0)\n['UX', 'UY', 'UZ']\n\n\n\nsave_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nExamples\n\nWrite nodal results as a binary vtk file.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result.\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\n\n\nproperty section_data\n\nThe section data from the result file\n\nReturns\n\nsection_data – Dictionary of the section data with the section numbers as\nkeys.\n\nReturn type\n\ndict\n\nNotes\n\nThere is limited documentation on how ANSYS stores the\nsections within a result file, and as such it may be difficult\nto interpret the section data for a given model.\n\n\n\nsolution_info(rnum)\n\nReturn an informative dictionary of solution data for a\nresult.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nheader – Double precision solution header data.\n\nReturn type\n\ndict\n\nExamples\n\nExtract the solution info from a sample example result file.\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_pontoon()\n>>> rst.solution_info(0)\n{'cgcent': [],\n 'fatjack': [],\n 'timfrq': 44.85185724963714,\n 'lfacto': 1.0,\n 'lfactn': 1.0,\n 'cptime': 3586.4873046875,\n 'tref': 71.6,\n 'tunif': 71.6,\n 'tbulk': 293.0,\n 'volbase': 0.0,\n 'tstep': 0.0,\n '__unused': 0.0,\n 'accel_x': 0.0,\n 'accel_y': 0.0,\n 'accel_z': 0.0,\n 'omega_v_x': 0.0,\n 'omega_v_y': 0.0,\n 'omega_v_z': 0.0,\n 'omega_a_x': 0.0,\n 'omega_a_y': 0.0,\n 'omega_a_z': 0.0,\n 'omegacg_v_x': 0.0,\n 'omegacg_v_y': 0.0,\n 'omegacg_v_z': 0.0,\n 'omegacg_a_x': 0.0,\n 'omegacg_a_y': 0.0,\n 'omegacg_a_z': 0.0,\n 'dval1': 0.0,\n 'pCnvVal': 0.0}\n\nNotes\n\nThe keys of the solution header are described below:\n\ntimfrq\n\nTime value (or frequency value, for a modal or\n\nharmonic analysis)\n\nlfacto\n\nthe “old” load factor (used in ramping a load\n\nbetween old and new values)\n\nlfactn  : The “new” load factor\n\ncptime  : Elapsed CPU time (in seconds)\n\ntref    : The reference temperature\n\ntunif   : The uniform temperature\n\ntbulk   : Bulk temp for FLOTRAN film coefs.\n\nVolBase : Initial total volume for VOF\n\ntstep   : Time Step size for FLOTRAN analysis\n\n0.0     : Position not used\n\naccel   : Linear acceleration terms\n\nomega\n\nAngular velocity (first 3 terms) and angular acceleration\n\n(second 3 terms)\n\nomegacg\n\nAngular velocity (first 3 terms) and angular\n\nacceleration (second 3 terms) these\nvelocity/acceleration terms are computed about the\ncenter of gravity\n\ncgcent  : (X,y,z) location of center of gravity\n\nfatjack : Fatjack ocean wave data (wave height and period)\n\ndval1\n\nIf pmeth=0: FATJACK ocean wave direction\n\nif pmeth=1: p-method convergence values\n\npCnvVal : P-method convergence values\n\n\n\ntext_result_table(rnum)\n\nReturns a text result table for plotting\n\n\n\nproperty version\n\nThe version of MAPDL used to generate this result file.\n\nExamples\n\n>>> rst.version\n20.1\n\n\n\nwrite_tables(filename: str | Path)\n\nWrite binary tables to ASCII.  Assumes int32\n\nParameters\n\nfilename (str, pathlib.Path) – Filename to write the tables to.\n\nExamples\n\n>>> rst.write_tables('tables.txt')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.animate_nodal_displacement","title":"Reading MAPDL Result Files > Result Object Methods > animate_nodal_displacement","text":"animate_nodal_displacement(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.animate_nodal_solution","title":"Reading MAPDL Result Files > Result Object Methods > animate_nodal_solution","text":"animate_nodal_solution(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.animate_nodal_solution_set","title":"Reading MAPDL Result Files > Result Object Methods > animate_nodal_solution_set","text":"animate_nodal_solution_set(rnums=None, comp='norm', node_components=None, element_components=None, sel_type_all=True, loop=True, movie_filename=None, add_text=True, fps=20, **kwargs)\n\nAnimate a set of nodal solutions.\n\nAnimates the scalars of all the result sets.  Best when used\nwith a series of static analyses.\n\nrnums\n\ncollection.Iterable\n\nRange or list containing the zero based indexed cumulative\nresult numbers to animate.\n\ncomp\n\nstr, optional\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.  Not\napplicable for a thermal analysis.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.\n\nmovie_filename\n\nstr, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported.  See\nimagio.get_writer.  A single loop of the mode will be\nrecorded.\n\nadd_text\n\nbool, optional\n\nAdds information about the result to the animation.\n\nfps\n\nint, optional\n\nFrames per second.  Defaults to 20 and limited to hardware\ncapabilities and model density. Carries over to movies\ncreated by providing the movie_filename argument,\nbut not to gifs.\n\nkwargs\n\noptional keyword arguments, optional\n\nSee help(pyvista.Plot) for additional keyword arguments.\n\nExamples\n\nAnimate all results\n\n>>> rst.animate_nodal_solution_set()\n\nAnimate every 50th result in a set of results and save to a\ngif.  Use the “zx” camera position to view the ZX plane from\nthe top down.\n\n>>> rsets = range(0, rst.nsets, 50)\n>>> rst.animate_nodal_solution_set(rsets,\n...                                scalar_bar_args={'title': 'My Animation'},\n...                                lighting=False, cpos='zx',\n...                                movie_filename='example.gif')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.available_results","title":"Reading MAPDL Result Files > Result Object Methods > available_results","text":"property available_results\n\nAvailable result types.\n\nExamples\n\n>>> rst.available_results\nAvailable Results:\nENS : Nodal stresses\nENG : Element energies and volume\nEEL : Nodal elastic strains\nEPL : Nodal plastic strains\nETH : Nodal thermal strains (includes swelling strains)\nEUL : Element euler angles\nENL : Nodal nonlinear items, e.g. equivalent plastic strains\nEPT : Nodal temperatures\nNSL : Nodal displacements\nRF  : Nodal reaction forces"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.cs_4x4","title":"Reading MAPDL Result Files > Result Object Methods > cs_4x4","text":"cs_4x4(cs_cord, as_vtk_matrix=False)\n\nReturn a 4x4 transformation matrix for a given coordinate system.\n\nParameters\n\ncs_cord (int) – Coordinate system index.\n\nas_vtk_matrix (bool, default: False) – Return the transformation matrix as a vtkMatrix4x4.\n\nReturns\n\nMatrix or vtkMatrix4x4 depending on the value of as_vtk_matrix.\n\nReturn type\n\nnp.ndarray | vtk.vtkMatrix4x4\n\nNotes\n\nValues 11 and greater correspond to local coordinate systems\n\nExamples\n\nReturn the transformation matrix for coordinate system 1.\n\n>>> tmat = rst.cs_4x4(1)\n>>> tmat\narray([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]])\n\nReturn the transformation matrix for coordinate system 5. This\ncorresponds to CSYS, 5, the cylindrical with global Cartesian Y as\nthe axis of rotation.\n\n>>> tmat = rst.cs_4x4(5)\n>>> tmat\narray([[ 1.,  0.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.]])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.cylindrical_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > cylindrical_nodal_stress","text":"cylindrical_nodal_stress(rnum, nodes=None)\n\nRetrieves the stresses for each node in the solution in the\ncylindrical coordinate system as the following values:\n\nR, THETA, Z, RTHETA, THETAZ, and RZ\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at R, THETA, Z, RTHETA, THETAZ, RZ averaged\nat each corner node where R is radial.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.cylindrical_nodal_stress(0)\n\nReturn the cylindrical nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS commands:\nRSYS, 1\nPRNSOL, S"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.element_components","title":"Reading MAPDL Result Files > Result Object Methods > element_components","text":"property element_components\n\nDictionary of ansys element components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.element_components\n{'ECOMP1': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], dtype=int32),\n'ECOMP2': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n        14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32),\n'ELEM_COMP': array([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        16, 17, 18, 19, 20], dtype=int32)}"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.element_lookup","title":"Reading MAPDL Result Files > Result Object Methods > element_lookup","text":"element_lookup(element_id)\n\nIndex of the element the element within the result mesh"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.element_solution_data","title":"Reading MAPDL Result Files > Result Object Methods > element_solution_data","text":"element_solution_data(rnum, datatype, sort=True, **kwargs)\n\nRetrieves element solution data.  Similar to ETABLE.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ndatatype (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nsort (bool) – Sort results by element number.  Default True.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – Element numbers.\n\nelement_data (list) – List with one data item for each element.\n\nenode (list) – Node numbers corresponding to each element.\nresults.  One list entry for each element.\n\nNotes\n\nSee ANSYS element documentation for available items for each\nelement type.  See:\n\nhttps://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_elem/\n\nExamples\n\nRetrieve “LS” solution results from an PIPE59 element for result set 1\n\n>>> enum, edata, enode = result.element_solution_data(0, datatype='ENS')\n>>> enum[0]  # first element number\n>>> enode[0]  # nodes belonging to element 1\n>>> edata[0]  # data belonging to element 1\narray([ -4266.19   ,   -376.18857,  -8161.785  , -64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,   2202.7085 ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,   1557.55   ,\n       -40042.613  ,   -376.62527,  -8171.2603 ,      0.     ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,  -2202.7085 ,\n        21018.164  ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        31494.537  ,   -376.62527,  -8171.2603 ,      0.     ,\n        21018.164  ,   -376.62527,  -8171.2603 ,   1557.55   ],\n      dtype=float32)\n\nThis data corresponds to the results you would obtain directly\nfrom MAPDL with ESOL commands:\n\n>>> ansys.esol(nvar='2', elem=enum[0], node=enode[0][0], item='LS', comp=1)\n>>> ansys.vget(par='SD_LOC1', ir='2', tstrt='1') # store in a variable\n>>> ansys.read_float_parameter('SD_LOC1(1)')\n-4266.19"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.element_stress","title":"Reading MAPDL Result Files > Result Object Methods > element_stress","text":"element_stress(rnum, principal=False, in_element_coord_sys=False, **kwargs)\n\nRetrieves the element component stresses.\n\nEquivalent ANSYS command: PRESOL, S\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nprincipal (bool, optional) – Returns principal stresses instead of component stresses.\nDefault False.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – ANSYS element numbers corresponding to each element.\n\nelement_stress (list) – Stresses at each element for each node for Sx Sy Sz Sxy\nSyz Sxz or SIGMA1, SIGMA2, SIGMA3, SINT, SEQV when\nprincipal is True.\n\nenode (list) – Node numbers corresponding to each element’s stress\nresults.  One list entry for each element.\n\nExamples\n\nElement component stress for the first result set.\n\n>>> rst.element_stress(0)\n\nElement principal stress for the first result set.\n\n>>> enum, element_stress, enode = result.element_stress(0, principal=True)\n\nNotes\n\nShell stresses for element 181 are returned for top and bottom\nlayers.  Results are ordered such that the top layer and then\nthe bottom layer is reported."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.filename","title":"Reading MAPDL Result Files > Result Object Methods > filename","text":"property filename: str\n\nString form of the filename. This property is read-only."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.materials","title":"Reading MAPDL Result Files > Result Object Methods > materials","text":"property materials\n\nResult file material properties.\n\nReturns\n\nDictionary of Materials.  Keys are the material numbers,\nand each material is a dictionary of the material\nproperrties of that material with only the valid entries filled.\n\nReturn type\n\ndict\n\nNotes\n\nMaterial properties:\n\nEX : Elastic modulus, element x direction (Force/Area)\n\nEY : Elastic modulus, element y direction (Force/Area)\n\nEZ : Elastic modulus, element z direction (Force/Area)\n\nALPX : Coefficient of thermal expansion, element x direction (Strain/Temp)\n\nALPY : Coefficient of thermal expansion, element y direction (Strain/Temp)\n\nALPZ : Coefficient of thermal expansion, element z direction (Strain/Temp)\n\nREFT : Reference temperature (as a property) [TREF]\n\nPRXY : Major Poisson’s ratio, x-y plane\n\nPRYZ : Major Poisson’s ratio, y-z plane\n\nPRX  Z : Major Poisson’s ratio, x-z plane\n\nNUXY : Minor Poisson’s ratio, x-y plane\n\nNUYZ : Minor Poisson’s ratio, y-z plane\n\nNUXZ : Minor Poisson’s ratio, x-z plane\n\nGXY : Shear modulus, x-y plane (Force/Area)\n\nGYZ : Shear modulus, y-z plane (Force/Area)\n\nGXZ : Shear modulus, x-z plane (Force/Area)\n\nDAMP : K matrix multiplier for damping [BETAD] (Time)\n\nMU\n\nCoefficient of friction (or, for FLUID29 and FLUID30\n\nelements, boundary admittance)\n\nDENS : Mass density (Mass/Vol)\n\nC : Specific heat (Heat/Mass*Temp)\n\nENTH : Enthalpy (e DENS*C d(Temp)) (Heat/Vol)\n\nKXX\n\nThermal conductivity, element x direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKYY\n\nThermal conductivity, element y direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKZZ\n\nThermal conductivity, element z direction\n\n(Heat*Length / (Time*Area*Temp))\n\nHF : Convection (or film) coefficient (Heat / (Time*Area*Temp))\n\nEMIS : Emissivity\n\nQRATE : Heat generation rate (MASS71 element only) (Heat/Time)\n\nVISC : Viscosity (Force*Time / Length2)\n\nSONC : Sonic velocity (FLUID29 and FLUID30 elements only) (Length/Time)\n\nRSVX : Electrical resistivity, element x direction (Resistance*Area / Length)\n\nRSVY : Electrical resistivity, element y direction (Resistance*Area / Length)\n\nRSVZ : Electrical resistivity, element z direction (Resistance*Area / Length)\n\nPERX : Electric permittivity, element x direction (Charge2 / (Force*Length))\n\nPERY : Electric permittivity, element y direction (Charge2 / (Force*Length))\n\nPERZ : Electric permittivity, element z direction (Charge2 / (Force*Length))\n\nMURX : Magnetic relative permeability, element x direction\n\nMURY : Magnetic relative permeability, element y direction\n\nMURZ : Magnetic relative permeability, element z direction\n\nMGXX : Magnetic coercive force, element x direction (Charge / (Length*Time))\n\nMGYY : Magnetic coercive force, element y direction (Charge / (Length*Time))\n\nMGZZ : Magnetic coercive force, element z direction (Charge / (Length*Time))\n\nMaterials may contain the key \"stress_failure_criteria\", which\ncontains failure criteria information for temperature-dependent stress\nlimits. This includes the following keys:\n\nXTEN : Allowable tensile stress or strain in the x-direction. (Must\nbe positive.)\n\nXCMP : Allowable compressive stress or strain in the\nx-direction. (Defaults to negative of XTEN.)\n\nYTEN : Allowable tensile stress or strain in the y-direction. (Must\nbe positive.)\n\nYCMP : Allowable compressive stress or strain in the\ny-direction. (Defaults to negative of YTEN.)\n\nZTEN : Allowable tensile stress or strain in the z-direction. (Must\nbe positive.)\n\nZCMP : Allowable compressive stress or strain in the\nz-direction. (Defaults to negative of ZTEN.)\n\nXY : Allowable XY stress or shear strain. (Must be positive.)\n\nYZ : Allowable YZ stress or shear strain. (Must be positive.)\n\nXZ : Allowable XZ stress or shear strain. (Must be positive.)\n\nXYCP : XY coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nYZCP : YZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZCP : XZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZIT : XZ tensile inclination parameter for Puck failure index (default =\n0.0)\n\nXZIC : XZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIT : YZ tensile inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIC : YZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nExamples\n\nReturn the material properties from the example result\nfile. Note that the keys of rst.materials is the material\ntype.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.materials\n{1: {'EX': 16900000.0, 'NUXY': 0.31, 'DENS': 0.00041408}}"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.mesh","title":"Reading MAPDL Result Files > Result Object Methods > mesh","text":"property mesh\n\nMesh from result file.\n\nExamples\n\n>>> rst.mesh\nANSYS Mesh\n  Number of Nodes:              1448\n  Number of Elements:           226\n  Number of Element Types:      1\n  Number of Node Components:    0\n  Number of Element Components: 0"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.n_results","title":"Reading MAPDL Result Files > Result Object Methods > n_results","text":"property n_results\n\nNumber of results"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.n_sector","title":"Reading MAPDL Result Files > Result Object Methods > n_sector","text":"property n_sector\n\nNumber of sectors"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_acceleration","title":"Reading MAPDL Result Files > Result Object Methods > nodal_acceleration","text":"nodal_acceleration(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal accelerations.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_acceleration(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_boundary_conditions","title":"Reading MAPDL Result Files > Result Object Methods > nodal_boundary_conditions","text":"nodal_boundary_conditions(rnum)\n\nNodal boundary conditions for a given result number.\n\nThese nodal boundary conditions are generally set with the\nAPDL command D.  For example, D, 25, UX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with boundary conditions.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith boundary conditions.  See rst.result_dof for the\ndegrees of freedom associated with each index.\n\nbc (np.ndarray) – Boundary conditions.\n\nExamples\n\nPrint the boundary conditions where:\n- Node 3 is fixed\n- Node 25 has UX=0.001\n- Node 26 has UY=0.0011\n- Node 27 has UZ=0.0012\n\n>>> rst.nodal_boundary_conditions(0)\n(array([ 3,  3,  3, 25, 26, 27], dtype=int32),\narray([1, 2, 3, 1, 2, 3], dtype=int32),\narray([0.    , 0.    , 0.    , 0.001 , 0.0011, 0.0012]))"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_displacement","title":"Reading MAPDL Result Files > Result Object Methods > nodal_displacement","text":"nodal_displacement(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_elastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > nodal_elastic_strain","text":"nodal_elastic_strain(rnum, nodes=None)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nEquivalent MAPDL command: PRNSOL, EPEL\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nelastic_strain (np.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0)\n\nReturn the nodal elastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal elastic strain just for the nodes from 20 through 50.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a strain will be NAN."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_input_force","title":"Reading MAPDL Result Files > Result Object Methods > nodal_input_force","text":"nodal_input_force(rnum)\n\nNodal input force for a given result number.\n\nNodal input force is generally set with the APDL command\nF.  For example, F, 25, FX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with nodal forces.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith input force.  See rst.result_dof for the degrees\nof freedom associated with each index.\n\nforce (np.ndarray) – Nodal input force.\n\nExamples\n\nPrint the nodal input force where:\n- Node 25 has FX=20\n- Node 26 has FY=30\n- Node 27 has FZ=40\n\n>>> rst.nodal_input_force(0)\n(array([ 71,  52, 127], dtype=int32),\n array([2, 1, 3], dtype=int32),\n array([30., 20., 40.]))"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_plastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > nodal_plastic_strain","text":"nodal_plastic_strain(rnum, nodes=None)\n\nNodal component plastic strains.\n\nThis record contains strains in the order:\nX, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains are always values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nplastic_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0)\n\nReturn the nodal plastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal plastic strain just for the nodes from 20\nthrough 50.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes=range(20, 51))"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_reaction_forces","title":"Reading MAPDL Result Files > Result Object Methods > nodal_reaction_forces","text":"nodal_reaction_forces(rnum)\n\nNodal reaction forces.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nrforces (np.ndarray) – Nodal reaction forces for each degree of freedom.\n\nnnum (np.ndarray) – Node numbers corresponding to the reaction forces.  Node\nnumbers may be repeated if there is more than one degree\nof freedom for each node.\n\ndof (np.ndarray) – Degree of freedom corresponding to each node using the\nMAPDL degree of freedom reference table.  See\nrst.result_dof for the corresponding degrees of\nfreedom for a given solution.\n\nExamples\n\nGet the nodal reaction forces for the first result and print\nthe reaction forces of a single node.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rforces, nnum, dof = rst.nodal_reaction_forces(0)\n>>> dof_ref = rst.result_dof(0)\n>>> rforces[:3], nnum[:3], dof[:3], dof_ref\n(array([  24102.21376091, -109357.01854005,   22899.5303263 ]),\n array([4142, 4142, 4142]),\n array([1, 2, 3], dtype=int32),\n ['UX', 'UY', 'UZ'])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_solution","title":"Reading MAPDL Result Files > Result Object Methods > nodal_solution","text":"nodal_solution(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_static_forces","title":"Reading MAPDL Result Files > Result Object Methods > nodal_static_forces","text":"nodal_static_forces(rnum, nodes=None)\n\nReturn the nodal forces averaged at the nodes.\n\nNodal forces are computed on an element by element basis, and\nthis method averages the nodal forces for each element for\neach node.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nforces (np.ndarray) – Averaged nodal forces.  Array is sized [nnod x numdof]\nwhere nnod is the number of nodes and numdof is the\nnumber of degrees of freedom for this solution.\n\nExamples\n\nLoad the nodal static forces for the first result using the\nexample hexahedral result file.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> nnum, forces = rst.nodal_static_forces(0)\n\nReturn the nodal static forces just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes='MY_COMPONENT')\n\nReturn the nodal static forces just for the nodes from 20 through 50.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a a nodal will be NAN.  These are generally\nmidside (quadratic) nodes."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > nodal_stress","text":"nodal_stress(rnum, nodes=None)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at X, Y, Z, XY, YZ, XZ averaged at each corner\nnode.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.nodal_stress(0)\n\nReturn the nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS command: PRNSOL, S"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_temperature","title":"Reading MAPDL Result Files > Result Object Methods > nodal_temperature","text":"nodal_temperature(rnum, nodes=None, **kwargs)\n\nRetrieves the temperature for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL command: PRNSOL, TEMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, temp = rst.nodal_temperature(0)\n\nReturn the temperature just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, temp = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the temperature just for the nodes from 20 through 50.\n\n>>> nnum, temp = rst.nodal_solution(0, nodes=range(20, 51))"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_thermal_strain","title":"Reading MAPDL Result Files > Result Object Methods > nodal_thermal_strain","text":"nodal_thermal_strain(rnum, nodes=None)\n\nNodal component thermal strain.\n\nThis record contains strains in the order X, Y, Z, XY, YZ, XZ,\nEQV, and eswell (element swelling strain).  Thermal strains\nare always values at the integration points moved to the\nnodes.\n\nEquivalent MAPDL command: PRNSOL, EPTH, COMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nReturn the nodal thermal strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal thermal strain just for the nodes from 20 through 50.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes=range(20, 51))"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_time_history","title":"Reading MAPDL Result Files > Result Object Methods > nodal_time_history","text":"nodal_time_history(solution_type='NSL', in_nodal_coord_sys=False)\n\nThe DOF solution for each node for all result sets.\n\nThe nodal results are returned returned in the global\ncartesian coordinate system or nodal coordinate system.\n\nParameters\n\nsolution_type (str, optional) – The solution type.  Must be either nodal displacements\n('NSL'), nodal velocities ('VEL') or nodal\naccelerations ('ACC').\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate system.\nDefault False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Nodal solution for all result sets.  Array is sized\nrst.nsets x nnod x Sumdof, which is the number of\ntime steps by number of nodes by degrees of freedom."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.nodal_velocity","title":"Reading MAPDL Result Files > Result Object Methods > nodal_velocity","text":"nodal_velocity(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal velocities.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_velocity(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.node_components","title":"Reading MAPDL Result Files > Result Object Methods > node_components","text":"property node_components\n\nDictionary of ansys node components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.node_components.keys()\ndict_keys(['ECOMP1', 'ECOMP2', 'ELEM_COMP'])\n>>> rst.node_components['NODE_COMP']\narray([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n      20], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.overwrite_element_solution_record","title":"Reading MAPDL Result Files > Result Object Methods > overwrite_element_solution_record","text":"overwrite_element_solution_record(data, rnum, solution_type, element_id)\n\nOverwrite element solution record.\n\nThis method replaces solution data for of an element at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\ndata (list or np.ndarray) – Data that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nelement_id (int) – Ansys element number (e.g. 1)\n\nExamples\n\nOverwrite the elastic strain record for element 1 for the\nfirst result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = np.random.random(56)\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL', 1)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.overwrite_element_solution_records","title":"Reading MAPDL Result Files > Result Object Methods > overwrite_element_solution_records","text":"overwrite_element_solution_records(element_data, rnum, solution_type)\n\nOverwrite element solution record.\n\nThis method replaces solution data for a set of elements at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\nelement_data (dict) – Dictionary of results that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nExamples\n\nOverwrite the elastic strain record for elements 1 and 2 with\nfor the first result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = {1: np.random.random(56),\n            2: np.random.random(56)}\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.parse_coordinate_system","title":"Reading MAPDL Result Files > Result Object Methods > parse_coordinate_system","text":"parse_coordinate_system()\n\nReads in coordinate system information from a binary result file.\n\nReturns\n\nc_systems – Dictionary containing one entry for each defined coordinate system.\nIf no non-standard coordinate systems have been defined, an empty\ndictionary will be returned.  First coordinate system is assumed to\nbe global cartesian.\n\nReturn type\n\ndict\n\nNotes\n\neuler angles : [THXY, THYZ, THZX]\n\nFirst rotation about local Z (positive X toward Y).\n\nSecond rotation about local X (positive Y toward Z).\n\nThird rotation about local Y (positive Z toward X).\n\nPAR1\nUsed for elliptical, spheroidal, or toroidal systems. If KCS =\n1 or 2, PAR1 is the ratio of the ellipse Y-axis radius to\nX-axis radius (defaults to 1.0 (circle)). If KCS = 3, PAR1 is\nthe major radius of the torus.\n\nPAR2\nUsed for spheroidal systems. If KCS = 2, PAR2 = ratio of\nellipse Z-axis radius to X-axis radius (defaults to 1.0\n(circle)).\n\nCoordinate system type:\n\n0: Cartesian\n\n1: Cylindrical (circular or elliptical)\n\n2: Spherical (or spheroidal)\n\n3: Toroidal"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.parse_step_substep","title":"Reading MAPDL Result Files > Result Object Methods > parse_step_substep","text":"parse_step_substep(user_input)\n\nConverts (step, substep) to a cumulative index"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.pathlib_filename","title":"Reading MAPDL Result Files > Result Object Methods > pathlib_filename","text":"property pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot","title":"Reading MAPDL Result Files > Result Object Methods > plot","text":"plot(node_components=None, element_components=None, sel_type_all=True, **kwargs)\n\nPlot result geometry\n\nParameters\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rst.plot()\n\nPlot just the element component ‘ROTOR_SHAFT’\n\n>>> rst.plot(element_components='ROTOR_SHAFT')\n\nPlot two node components\n>>> rst.plot(node_components=[‘MY_COMPONENT’, ‘MY_OTHER_COMPONENT’])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_cylindrical_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > plot_cylindrical_nodal_stress","text":"plot_cylindrical_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal_stress in the cylindrical coordinate system.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"R\"\n- \"THETA\"\n- \"Z\"\n- \"RTHETA\"\n- \"THETAZ\"\n- \"RZ\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal stress in the radial direction.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_cylindrical_nodal_stress(0, 'R')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_element_result","title":"Reading MAPDL Result Files > Result Object Methods > plot_element_result","text":"plot_element_result(rnum, result_type, item_index, in_element_coord_sys=False, **kwargs)\n\nPlot an element result.\n\nParameters\n\nrnum (int) – Result number.\n\nresult_type (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nitem_index (int) – Index of the data item for each node within the element.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\nReturns\n\nnnum (np.ndarray) – ANSYS node numbers\n\nresult (np.ndarray) – Array of result data"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_displacement","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_displacement","text":"plot_nodal_displacement(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_elastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_elastic_strain","text":"plot_nodal_elastic_strain(rnum, comp, scalar_bar_args={'title': 'EQV Nodal Elastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal elastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_elastic_strain(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_plastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_plastic_strain","text":"plot_nodal_plastic_strain(rnum, comp, scalar_bar_args={'title': 'Nodal Plastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nExamples\n\nPlot plastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_plastic_strain(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_solution","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_solution","text":"plot_nodal_solution(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_stress","text":"plot_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the stresses at each node in the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – 3 x 3 vtk camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the X component nodal stress while showing displacement.\n\n>>> rst.plot_nodal_stress(0, comp='x', show_displacement=True)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_temperature","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_temperature","text":"plot_nodal_temperature(rnum, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal temperature\n\nParameters\n\nrnum (int) – Result number\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot temperature of a result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_nodal_temperature(0)\n\nPlot while showing edges and disabling lighting\n\n>>> result.plot_nodal_temperature(0, show_edges=True, lighting=False)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_nodal_thermal_strain","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_thermal_strain","text":"plot_nodal_thermal_strain(rnum, comp=None, scalar_bar_args={'title': 'Nodal Thermal Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component thermal strains.\n\nEquivalent MAPDL command: PLNSOL, EPTH, COMP\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot thermal strain for result 0 of verification manual example 33.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_thermal_strain(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.plot_principal_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > plot_principal_nodal_stress","text":"plot_principal_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the equivalent von mises stress.\n\n>>> rst.plot_principal_nodal_stress(0, comp='SEQV')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.principal_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > principal_nodal_stress","text":"principal_nodal_stress(rnum, nodes=None)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nExamples\n\nLoad the principal nodal stress for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.principal_nodal_stress(0)\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\nInternal averaging algorithm averages the component values\nfrom the elements at a common node and then calculates the\nprincipal using the averaged value.\n\nSee the MAPDL AVPRIN command for more details.\nansys-mapdl-reader uses the default AVPRIN, 0 option."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.result_dof","title":"Reading MAPDL Result Files > Result Object Methods > result_dof","text":"result_dof(rnum)\n\nReturn a list of degrees of freedom for a given result number.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\ndof – List of degrees of freedom.\n\nReturn type\n\nlist\n\nExamples\n\n>>> rst.result_dof(0)\n['UX', 'UY', 'UZ']"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.save_as_vtk","title":"Reading MAPDL Result Files > Result Object Methods > save_as_vtk","text":"save_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nExamples\n\nWrite nodal results as a binary vtk file.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result.\n\n>>> rst.save_as_vtk('results.vtk', [0], [])"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.section_data","title":"Reading MAPDL Result Files > Result Object Methods > section_data","text":"property section_data\n\nThe section data from the result file\n\nReturns\n\nsection_data – Dictionary of the section data with the section numbers as\nkeys.\n\nReturn type\n\ndict\n\nNotes\n\nThere is limited documentation on how ANSYS stores the\nsections within a result file, and as such it may be difficult\nto interpret the section data for a given model."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.solution_info","title":"Reading MAPDL Result Files > Result Object Methods > solution_info","text":"solution_info(rnum)\n\nReturn an informative dictionary of solution data for a\nresult.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nheader – Double precision solution header data.\n\nReturn type\n\ndict\n\nExamples\n\nExtract the solution info from a sample example result file.\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_pontoon()\n>>> rst.solution_info(0)\n{'cgcent': [],\n 'fatjack': [],\n 'timfrq': 44.85185724963714,\n 'lfacto': 1.0,\n 'lfactn': 1.0,\n 'cptime': 3586.4873046875,\n 'tref': 71.6,\n 'tunif': 71.6,\n 'tbulk': 293.0,\n 'volbase': 0.0,\n 'tstep': 0.0,\n '__unused': 0.0,\n 'accel_x': 0.0,\n 'accel_y': 0.0,\n 'accel_z': 0.0,\n 'omega_v_x': 0.0,\n 'omega_v_y': 0.0,\n 'omega_v_z': 0.0,\n 'omega_a_x': 0.0,\n 'omega_a_y': 0.0,\n 'omega_a_z': 0.0,\n 'omegacg_v_x': 0.0,\n 'omegacg_v_y': 0.0,\n 'omegacg_v_z': 0.0,\n 'omegacg_a_x': 0.0,\n 'omegacg_a_y': 0.0,\n 'omegacg_a_z': 0.0,\n 'dval1': 0.0,\n 'pCnvVal': 0.0}\n\nNotes\n\nThe keys of the solution header are described below:\n\ntimfrq\n\nTime value (or frequency value, for a modal or\n\nharmonic analysis)\n\nlfacto\n\nthe “old” load factor (used in ramping a load\n\nbetween old and new values)\n\nlfactn  : The “new” load factor\n\ncptime  : Elapsed CPU time (in seconds)\n\ntref    : The reference temperature\n\ntunif   : The uniform temperature\n\ntbulk   : Bulk temp for FLOTRAN film coefs.\n\nVolBase : Initial total volume for VOF\n\ntstep   : Time Step size for FLOTRAN analysis\n\n0.0     : Position not used\n\naccel   : Linear acceleration terms\n\nomega\n\nAngular velocity (first 3 terms) and angular acceleration\n\n(second 3 terms)\n\nomegacg\n\nAngular velocity (first 3 terms) and angular\n\nacceleration (second 3 terms) these\nvelocity/acceleration terms are computed about the\ncenter of gravity\n\ncgcent  : (X,y,z) location of center of gravity\n\nfatjack : Fatjack ocean wave data (wave height and period)\n\ndval1\n\nIf pmeth=0: FATJACK ocean wave direction\n\nif pmeth=1: p-method convergence values\n\npCnvVal : P-method convergence values"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.text_result_table","title":"Reading MAPDL Result Files > Result Object Methods > text_result_table","text":"text_result_table(rnum)\n\nReturns a text result table for plotting"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.version","title":"Reading MAPDL Result Files > Result Object Methods > version","text":"property version\n\nThe version of MAPDL used to generate this result file.\n\nExamples\n\n>>> rst.version\n20.1"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.rst.Result.write_tables","title":"Reading MAPDL Result Files > Result Object Methods > write_tables","text":"write_tables(filename: str | Path)\n\nWrite binary tables to ASCII.  Assumes int32\n\nParameters\n\nfilename (str, pathlib.Path) – Filename to write the tables to.\n\nExamples\n\n>>> rst.write_tables('tables.txt')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult","title":"Reading MAPDL Result Files > Result Object Methods > CyclicResult","text":"class ansys.mapdl.reader.cyclic_reader.CyclicResult(filename, read_mesh: bool = True)\n\nAdds cyclic functionality to the result class\n\n\n\nanimate_nodal_displacement(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )\n\n\n\nanimate_nodal_solution(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )\n\n\n\nproperty full_rotor\n\nUnstructuredGrid of the full replicated rotor\n\n\n\nharmonic_index_to_cumulative(hindex, mode)\n\nConverts a harmonic index and a 0 index mode number to a\ncumulative result index.\n\nHarmonic indices are stored as positive and negative pairs for\nmodes other than 0 and N/nsectors.\n\nParameters\n\nhindex (int) – Harmonic index.  Must be less than or equal to nsectors/2.\nMay be positive or negative\n\nmode (int) – Mode number.  0 based indexing.  Access mode pairs by with\na negative/positive harmonic index.\n\nReturns\n\nrnum – Cumulative index number.  Zero based indexing.\n\nReturn type\n\nint\n\n\n\nproperty harmonic_indices\n\nHarmonic indices of the result file.\n\nHarmonic index is simply the Nodal Diameter of the mode.  This\nis defined as the number of complete sine waves that pass\nthrough the circumference.\n\nExamples\n\n>>> rst.harmonic_indices\narray([ 0,  0,  0,  0,  0,  0, -1,  1, -1,  1,  1, -1,\n       -2,  2, -2,  2, -2,  2,  3,  3,  3,  3,  3,  3], dtype=int32)\n\n\n\nproperty mode_table\n\nUnique modes for cyclic results\n\n\n\nnodal_displacement(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1).\n\n\n\nnodal_elastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in radians.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nelastic_strain (numpy.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> nnum, elastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_plastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component plastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nplastic_strain (numpy.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first result.\n\n>>> nnum, plastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_solution(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1).\n\n\n\nnodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at Sx Sy Sz Sxy Syz Sxz averaged at each corner\nnode.  For the corresponding node numbers, see where\nresult is the result object.\n\nExamples\n\n>>> nnum, stress = rst.nodal_stress(0)\n\nNotes\n\nNodes without a stress value will be NAN.\n\n\n\nnodal_temperature(rnum, full_rotor=False)\n\nRetrieves the temperature for each node in the solution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL commands:\nPRNSOL, TEMP\nPRNSOL, BFE\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> nnum, stress = rst.nodal_temperature(0)\n\n\n\nnodal_thermal_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component thermal strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV, and eswell\n(element swelling strain).  Thermal strains are always values\nat the integration points moved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first result.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nplot(**kwargs)\n\nPlot the full rotor geometry.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot()\n\nSave a screenshot of the rotor\n\n>>> rst.plot(screenshot='rotor.png')\n\n\n\nplot_nodal_elastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal elastic strain for an academic rotor.\n\n>>> result.plot_nodal_elastic_strain(0, 'X')\n\n\n\nplot_nodal_plastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal plastic strain for an academic rotor\n\n>>> result.plot_nodal_plastic_strain(0)\n\n\n\nplot_nodal_solution(rnum, comp='norm', phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal solution (generally displacement).\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are ‘x’, ‘y’, ‘z’,\nand ‘norm’, corresponding to the x direction, y direction,\nz direction, and the normalized direction:\n(x**2 + y**2 + z**2)**0.5\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the displacement of the first cyclic result.\n\n>>> result.plot_nodal_solution(0)\n\n\n\nplot_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal stress of a given component\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the \"Z\" nodal stress of the first cyclic result.\n\n>>> result.plot_nodal_stress(0, comp=\"Z\")\n\n\n\nplot_nodal_temperature(rnum, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, overlay_wireframe=False, add_text=True, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal temperature.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand the sector solution and plot the full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal temperature of a rotor for the first result.\n\n>>> result.plot_nodal_temperature(0)\n\n\n\nplot_nodal_thermal_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal thermal strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\" (element swelling strain)\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0.\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal thermal strain for an academic rotor\n\n>>> rst.plot_nodal_thermal_strain(0)\n\n\n\nplot_principal_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the von Mises stress of the first cyclic result.\n\n>>> result.plot_principal_nodal_stress(0, comp='SEQV')\n\n\n\nplot_sectors(**kwargs)\n\nPlot the full rotor and individually color the sectors.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot_sectors()\n\nSave a screenshot of the sectors\n\n>>> rst.plot_sectors(screenshot='sectors.png')\n\n\n\nprincipal_nodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\n\n\nsave_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True, expand_cyclic=True, merge_sectors=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nexpand_cyclic (bool, default: True.) – When True, expands cyclic results by writing out the result as\na full cyclic result rather than as a single cyclic sector.\n\nmerge_sectors (bool, default: False) – When expand_cyclic is True and this parameter is True,\nsectors will be merged to create one unified grid. Set this to\nFalse to not merge nodes between sectors.\n\nNotes\n\nNodal solutions are stored within the point_data attribute of the\nunstructured grid and can be accessed after reading in the result with\npyvista with:\n\nSee the examples section for more details.\n\nExamples\n\nWrite nodal results as a binary vtk file. Larger file size, loads quickly.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer. This file is more compressed compressed but\nwill load slower.\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\nRead in the results using pyvista.read(). Plot the ‘Z’ component of\nthe first mode’s -2 nodal diameter nodal displacement.\n\n>>> import pyvista as pv\n>>> grid = pv.read('results.vtk')\n>>> grid.plot(scalars=\"Nodal solution (0, -2)\", component=2)\n\nDo not merge sectors when saving the results and separate sectors into\nmultiple blocks within pyvista.\n\n>>> rst.save_as_vtk('results.vtk', merge_sectors=False)\n>>> grid = pv.read('results.vtk')\n>>> mblock = grid.split_bodies()"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.animate_nodal_displacement","title":"Reading MAPDL Result Files > Result Object Methods > animate_nodal_displacement","text":"animate_nodal_displacement(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.animate_nodal_solution","title":"Reading MAPDL Result Files > Result Object Methods > animate_nodal_solution","text":"animate_nodal_solution(rnum, comp='norm', displacement_factor=0.1, n_frames=180, add_text=True, loop=True, movie_filename=None, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Component of displacement to display.  Options are ‘x’,\n‘y’, ‘z’, or ‘norm’, which correspond to the x , y, z, or\nthe normalized direction (x**2 + y**2 + z**2)**0.5\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nn_frames (int, optional) – Number of “frames” between each full cycle.\n\nshow_phase (bool, optional) – Shows the phase at each frame.\n\nadd_text (bool, optional) – Includes result information at the top left-hand corner of the\nplot. Set font size with the font_size parameter.\n\ninterpolate_before_map (bool, optional) – Leaving this at default generally results in a better plot.\n\nmovie_filename (str, optional) – Filename of the movie to open.  Filename should end in mp4,\nbut other filetypes may be supported.  See imagio.get_writer.\nA single loop of the mode will be recorded.\n\nkwargs (optional keyword arguments, optional) – See pyvista.plot() for additional keyword arguments.\n\nExamples\n\nGenerate a movie of a mode shape while plotting off-screen.\n\n>>> from ansys.mapdl.reader import read_binary\n>>> rst = read_binary(\"academic_rotor.rst\")\n>>> rst.animate_nodal_displacement(\n...     (3, 2),\n...     displacement_factor=0.02,\n...     movie_filename=\"movie.mp4\",\n...     off_screen=True\n... )"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.full_rotor","title":"Reading MAPDL Result Files > Result Object Methods > full_rotor","text":"property full_rotor\n\nUnstructuredGrid of the full replicated rotor"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.harmonic_index_to_cumulative","title":"Reading MAPDL Result Files > Result Object Methods > harmonic_index_to_cumulative","text":"harmonic_index_to_cumulative(hindex, mode)\n\nConverts a harmonic index and a 0 index mode number to a\ncumulative result index.\n\nHarmonic indices are stored as positive and negative pairs for\nmodes other than 0 and N/nsectors.\n\nParameters\n\nhindex (int) – Harmonic index.  Must be less than or equal to nsectors/2.\nMay be positive or negative\n\nmode (int) – Mode number.  0 based indexing.  Access mode pairs by with\na negative/positive harmonic index.\n\nReturns\n\nrnum – Cumulative index number.  Zero based indexing.\n\nReturn type\n\nint"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.harmonic_indices","title":"Reading MAPDL Result Files > Result Object Methods > harmonic_indices","text":"property harmonic_indices\n\nHarmonic indices of the result file.\n\nHarmonic index is simply the Nodal Diameter of the mode.  This\nis defined as the number of complete sine waves that pass\nthrough the circumference.\n\nExamples\n\n>>> rst.harmonic_indices\narray([ 0,  0,  0,  0,  0,  0, -1,  1, -1,  1,  1, -1,\n       -2,  2, -2,  2, -2,  2,  3,  3,  3,  3,  3,  3], dtype=int32)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.mode_table","title":"Reading MAPDL Result Files > Result Object Methods > mode_table","text":"property mode_table\n\nUnique modes for cyclic results"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_displacement","title":"Reading MAPDL Result Files > Result Object Methods > nodal_displacement","text":"nodal_displacement(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1)."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_elastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > nodal_elastic_strain","text":"nodal_elastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in radians.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nelastic_strain (numpy.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> nnum, elastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_plastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > nodal_plastic_strain","text":"nodal_plastic_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component plastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nplastic_strain (numpy.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first result.\n\n>>> nnum, plastic_strain = rst.nodal_stress(0)\n\nNotes\n\nNodes without a strain will be NAN."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_solution","title":"Reading MAPDL Result Files > Result Object Methods > nodal_solution","text":"nodal_solution(rnum, phase=0, full_rotor=False, as_complex=False)\n\nReturn the DOF solution for each node in the global cartesian coordinate system.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float, optional) – Phase to rotate sector result in radians.\n\nfull_rotor (bool, optional) – Expands the single sector solution for the full rotor.\nSectors are rotated counter-clockwise about the axis of\nrotation.  Default False.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of master sector.\n\nresult (numpy.ndarray) – Result is (nnod x numdof), nnod is the number of nodes in\na sector and numdof is the number of degrees of freedom.\nWhen full_rotor is True the array will be (nSector x nnod\nx numdof).\n\nExamples\n\nVisualize the 1st nodal diameter mode.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_academic_rotor()\n>>> result.nodal_solution((2, 1))\n\nSame result but uses Python (zero based) cumulative indexing\n\n>>> result.nodal_solution(2)\n\nNotes\n\nSomewhere between v15.0 and v18.2 ANSYS stopped writing the\nduplicate sector to the result file and instead records results in\npairs (i.e. harmonic index 1, -1)."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > nodal_stress","text":"nodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at Sx Sy Sz Sxy Syz Sxz averaged at each corner\nnode.  For the corresponding node numbers, see where\nresult is the result object.\n\nExamples\n\n>>> nnum, stress = rst.nodal_stress(0)\n\nNotes\n\nNodes without a stress value will be NAN."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_temperature","title":"Reading MAPDL Result Files > Result Object Methods > nodal_temperature","text":"nodal_temperature(rnum, full_rotor=False)\n\nRetrieves the temperature for each node in the solution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL commands:\nPRNSOL, TEMP\nPRNSOL, BFE\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> nnum, stress = rst.nodal_temperature(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.nodal_thermal_strain","title":"Reading MAPDL Result Files > Result Object Methods > nodal_thermal_strain","text":"nodal_thermal_strain(rnum, phase=0, as_complex=False, full_rotor=False)\n\nNodal component thermal strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV, and eswell\n(element swelling strain).  Thermal strains are always values\nat the integration points moved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Reports stress as a complex result.  Real and imaginary\nstresses correspond to the stress of the main and repeated\nsector.  Stress can be “rotated” using the phase\nparameter.\n\nfull_rotor (bool, optional) – Expands the results to the full rotor when True.  Default\nFalse.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first result.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nNotes\n\nNodes without a strain will be NAN."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot","title":"Reading MAPDL Result Files > Result Object Methods > plot","text":"plot(**kwargs)\n\nPlot the full rotor geometry.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot()\n\nSave a screenshot of the rotor\n\n>>> rst.plot(screenshot='rotor.png')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_nodal_elastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_elastic_strain","text":"plot_nodal_elastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal elastic strain for an academic rotor.\n\n>>> result.plot_nodal_elastic_strain(0, 'X')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_nodal_plastic_strain","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_plastic_strain","text":"plot_nodal_plastic_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal plastic strain for an academic rotor\n\n>>> result.plot_nodal_plastic_strain(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_nodal_solution","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_solution","text":"plot_nodal_solution(rnum, comp='norm', phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal solution (generally displacement).\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are ‘x’, ‘y’, ‘z’,\nand ‘norm’, corresponding to the x direction, y direction,\nz direction, and the normalized direction:\n(x**2 + y**2 + z**2)**0.5\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the displacement of the first cyclic result.\n\n>>> result.plot_nodal_solution(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_stress","text":"plot_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, overlay_wireframe=False, add_text=True, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal stress of a given component\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the \"Z\" nodal stress of the first cyclic result.\n\n>>> result.plot_nodal_stress(0, comp=\"Z\")"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_nodal_temperature","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_temperature","text":"plot_nodal_temperature(rnum, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1.0, node_components=None, overlay_wireframe=False, add_text=True, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal temperature.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nfull_rotor (bool, optional) – Expand the sector solution and plot the full rotor.\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal temperature of a rotor for the first result.\n\n>>> result.plot_nodal_temperature(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_nodal_thermal_strain","title":"Reading MAPDL Result Files > Result Object Methods > plot_nodal_thermal_strain","text":"plot_nodal_thermal_strain(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal thermal strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\" (element swelling strain)\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0.\n\nfull_rotor (bool, optional) – Expand the sector solution to the full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot nodal thermal strain for an academic rotor\n\n>>> rst.plot_nodal_thermal_strain(0)"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_principal_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > plot_principal_nodal_stress","text":"plot_principal_nodal_stress(rnum, comp=None, phase=0, full_rotor=True, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, add_text=True, overlay_wireframe=False, treat_nan_as_zero=False, **kwargs)\n\nPlot the nodal principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nphase (float, optional) – Phase angle of the modal result in radians.  Only valid\nwhen full_rotor is True.  Default 0\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the von Mises stress of the first cyclic result.\n\n>>> result.plot_principal_nodal_stress(0, comp='SEQV')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.plot_sectors","title":"Reading MAPDL Result Files > Result Object Methods > plot_sectors","text":"plot_sectors(**kwargs)\n\nPlot the full rotor and individually color the sectors.\n\nParameters\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_academic_rotor()\n>>> rst.plot_sectors()\n\nSave a screenshot of the sectors\n\n>>> rst.plot_sectors(screenshot='sectors.png')"},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.principal_nodal_stress","title":"Reading MAPDL Result Files > Result Object Methods > principal_nodal_stress","text":"principal_nodal_stress(rnum, phase=0, as_complex=False, full_rotor=False)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nphase (float) – Phase adjustment of the stress in degrees.\n\nas_complex (bool, optional) – Returns result as a complex number, otherwise as the real\npart rotated by phase.  Default False.\n\nfull_rotor (bool, optional) – Expand sector solution to full rotor.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress."},{"objectID":"Home","href":"user_guide/loading_results.html#ansys.mapdl.reader.cyclic_reader.CyclicResult.save_as_vtk","title":"Reading MAPDL Result Files > Result Object Methods > save_as_vtk","text":"save_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True, expand_cyclic=True, merge_sectors=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nexpand_cyclic (bool, default: True.) – When True, expands cyclic results by writing out the result as\na full cyclic result rather than as a single cyclic sector.\n\nmerge_sectors (bool, default: False) – When expand_cyclic is True and this parameter is True,\nsectors will be merged to create one unified grid. Set this to\nFalse to not merge nodes between sectors.\n\nNotes\n\nNodal solutions are stored within the point_data attribute of the\nunstructured grid and can be accessed after reading in the result with\npyvista with:\n\nSee the examples section for more details.\n\nExamples\n\nWrite nodal results as a binary vtk file. Larger file size, loads quickly.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer. This file is more compressed compressed but\nwill load slower.\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result:\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\nRead in the results using pyvista.read(). Plot the ‘Z’ component of\nthe first mode’s -2 nodal diameter nodal displacement.\n\n>>> import pyvista as pv\n>>> grid = pv.read('results.vtk')\n>>> grid.plot(scalars=\"Nodal solution (0, -2)\", component=2)\n\nDo not merge sectors when saving the results and separate sectors into\nmultiple blocks within pyvista.\n\n>>> rst.save_as_vtk('results.vtk', merge_sectors=False)\n>>> grid = pv.read('results.vtk')\n>>> mblock = grid.split_bodies()"},{"objectID":"Home","href":"examples/sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:00.000 total execution time for 0 files from examples:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nN/A\n\nN/A\n\nN/A"},{"objectID":"Home","href":"api/rst.html#result-class","title":"Result Class","text":"Result Class\n\n\n\nclass ansys.mapdl.reader.rst.Result(filename, read_mesh=True, parse_vtk=True, **kwargs)\n\nReads a binary ANSYS result file.\n\nParameters\n\nfilename (str, pathlib.Path, optional) – Filename of the ANSYS binary result file.\n\nignore_cyclic (bool, optional) – Ignores any cyclic properties.\n\nread_mesh (bool, optional) – Debug parameter.  Set to False to disable reading in the\nmesh from the result file.\n\nparse_vtk (bool, optional) – Set to False to skip the parsing the mesh as a VTK\nUnstructuredGrid, which might take a long time for large models.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n\n\n\nanimate_nodal_displacement(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)\n\n\n\nanimate_nodal_solution(rnum, comp='norm', node_components=None, element_components=None, sel_type_all=True, add_text=True, displacement_factor=0.1, n_frames=100, loop=True, movie_filename=None, progress_bar=True, **kwargs)\n\nAnimate nodal solution.\n\nAssumes nodal solution is a displacement array from a modal or static\nsolution.\n\nrnum\n\nint or list\n\nCumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp\n\nstr, default: “norm”\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nadd_text\n\nbool, optional\n\nAdds information about the result.\n\ndisplacement_factor\n\nfloat, optional\n\nIncreases or decreases displacement by a factor.\n\nn_frames\n\nint, optional\n\nNumber of “frames” between each full cycle.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.  Automatically disabled when\noff_screen=True and movie_filename is set.\n\nmovie_filename\n\nstr, pathlib.Path, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported like\n\"gif\".  See imagio.get_writer.  A single loop of\nthe mode will be recorded.\n\nprogress_bar\n\nbool, default: True\n\nDisplays a progress bar when generating a movie while\noff_screen=True.\n\nkwargs\n\noptional keyword arguments\n\nSee pyvista.plot() for additional keyword arguments.\n\nExamples\n\nAnimate the first result interactively.\n\n>>> rst.animate_nodal_solution(0)\n\nAnimate second result while displaying the x scalars\nwithout looping\n\n>>> rst.animate_nodal_solution(1, comp='x', loop=False)\n\nAnimate the second result and save as a movie.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4')\n\nAnimate the second result and save as a movie in the background.\n\n>>> rst.animate_nodal_solution(0, movie_filename='disp.mp4', off_screen=True)\n\nDisable plotting within the notebook.\n\n>>> rst.animate_nodal_solution(0, notebook=False)\n\n\n\nanimate_nodal_solution_set(rnums=None, comp='norm', node_components=None, element_components=None, sel_type_all=True, loop=True, movie_filename=None, add_text=True, fps=20, **kwargs)\n\nAnimate a set of nodal solutions.\n\nAnimates the scalars of all the result sets.  Best when used\nwith a series of static analyses.\n\nrnums\n\ncollection.Iterable\n\nRange or list containing the zero based indexed cumulative\nresult numbers to animate.\n\ncomp\n\nstr, optional\n\nScalar component to display.  Options are 'x',\n'y', 'z', and 'norm', and None.  Not\napplicable for a thermal analysis.\n\nnode_components\n\nlist, optional\n\nAccepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components\n\nlist, optional\n\nAccepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all\n\nbool, optional\n\nIf node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\nloop\n\nbool, optional\n\nLoop the animation.  Default True.  Disable this to\nanimate once and close.\n\nmovie_filename\n\nstr, optional\n\nFilename of the movie to open.  Filename should end in\n'mp4', but other filetypes may be supported.  See\nimagio.get_writer.  A single loop of the mode will be\nrecorded.\n\nadd_text\n\nbool, optional\n\nAdds information about the result to the animation.\n\nfps\n\nint, optional\n\nFrames per second.  Defaults to 20 and limited to hardware\ncapabilities and model density. Carries over to movies\ncreated by providing the movie_filename argument,\nbut not to gifs.\n\nkwargs\n\noptional keyword arguments, optional\n\nSee help(pyvista.Plot) for additional keyword arguments.\n\nExamples\n\nAnimate all results\n\n>>> rst.animate_nodal_solution_set()\n\nAnimate every 50th result in a set of results and save to a\ngif.  Use the “zx” camera position to view the ZX plane from\nthe top down.\n\n>>> rsets = range(0, rst.nsets, 50)\n>>> rst.animate_nodal_solution_set(rsets,\n...                                scalar_bar_args={'title': 'My Animation'},\n...                                lighting=False, cpos='zx',\n...                                movie_filename='example.gif')\n\n\n\nproperty available_results\n\nAvailable result types.\n\nExamples\n\n>>> rst.available_results\nAvailable Results:\nENS : Nodal stresses\nENG : Element energies and volume\nEEL : Nodal elastic strains\nEPL : Nodal plastic strains\nETH : Nodal thermal strains (includes swelling strains)\nEUL : Element euler angles\nENL : Nodal nonlinear items, e.g. equivalent plastic strains\nEPT : Nodal temperatures\nNSL : Nodal displacements\nRF  : Nodal reaction forces\n\n\n\ncs_4x4(cs_cord, as_vtk_matrix=False)\n\nReturn a 4x4 transformation matrix for a given coordinate system.\n\nParameters\n\ncs_cord (int) – Coordinate system index.\n\nas_vtk_matrix (bool, default: False) – Return the transformation matrix as a vtkMatrix4x4.\n\nReturns\n\nMatrix or vtkMatrix4x4 depending on the value of as_vtk_matrix.\n\nReturn type\n\nnp.ndarray | vtk.vtkMatrix4x4\n\nNotes\n\nValues 11 and greater correspond to local coordinate systems\n\nExamples\n\nReturn the transformation matrix for coordinate system 1.\n\n>>> tmat = rst.cs_4x4(1)\n>>> tmat\narray([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]])\n\nReturn the transformation matrix for coordinate system 5. This\ncorresponds to CSYS, 5, the cylindrical with global Cartesian Y as\nthe axis of rotation.\n\n>>> tmat = rst.cs_4x4(5)\n>>> tmat\narray([[ 1.,  0.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.]])\n\n\n\ncylindrical_nodal_stress(rnum, nodes=None)\n\nRetrieves the stresses for each node in the solution in the\ncylindrical coordinate system as the following values:\n\nR, THETA, Z, RTHETA, THETAZ, and RZ\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at R, THETA, Z, RTHETA, THETAZ, RZ averaged\nat each corner node where R is radial.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.cylindrical_nodal_stress(0)\n\nReturn the cylindrical nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.cylindrical_nodal_stress(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS commands:\nRSYS, 1\nPRNSOL, S\n\n\n\nproperty element_components\n\nDictionary of ansys element components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.element_components\n{'ECOMP1': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], dtype=int32),\n'ECOMP2': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n        14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32),\n'ELEM_COMP': array([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        16, 17, 18, 19, 20], dtype=int32)}\n\n\n\nelement_lookup(element_id)\n\nIndex of the element the element within the result mesh\n\n\n\nelement_solution_data(rnum, datatype, sort=True, **kwargs)\n\nRetrieves element solution data.  Similar to ETABLE.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ndatatype (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nsort (bool) – Sort results by element number.  Default True.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – Element numbers.\n\nelement_data (list) – List with one data item for each element.\n\nenode (list) – Node numbers corresponding to each element.\nresults.  One list entry for each element.\n\nNotes\n\nSee ANSYS element documentation for available items for each\nelement type.  See:\n\nhttps://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_elem/\n\nExamples\n\nRetrieve “LS” solution results from an PIPE59 element for result set 1\n\n>>> enum, edata, enode = result.element_solution_data(0, datatype='ENS')\n>>> enum[0]  # first element number\n>>> enode[0]  # nodes belonging to element 1\n>>> edata[0]  # data belonging to element 1\narray([ -4266.19   ,   -376.18857,  -8161.785  , -64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  64706.766  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,  45754.594  ,\n        -4266.19   ,   -376.18857,  -8161.785  ,      0.     ,\n        -4266.19   ,   -376.18857,  -8161.785  , -45754.594  ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,   2202.7085 ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,   1557.55   ,\n       -40042.613  ,   -376.62527,  -8171.2603 ,      0.     ,\n       -29566.24   ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        -4274.038  ,   -376.62527,  -8171.2603 ,  -2202.7085 ,\n        21018.164  ,   -376.62527,  -8171.2603 ,  -1557.55   ,\n        31494.537  ,   -376.62527,  -8171.2603 ,      0.     ,\n        21018.164  ,   -376.62527,  -8171.2603 ,   1557.55   ],\n      dtype=float32)\n\nThis data corresponds to the results you would obtain directly\nfrom MAPDL with ESOL commands:\n\n>>> ansys.esol(nvar='2', elem=enum[0], node=enode[0][0], item='LS', comp=1)\n>>> ansys.vget(par='SD_LOC1', ir='2', tstrt='1') # store in a variable\n>>> ansys.read_float_parameter('SD_LOC1(1)')\n-4266.19\n\n\n\nelement_stress(rnum, principal=False, in_element_coord_sys=False, **kwargs)\n\nRetrieves the element component stresses.\n\nEquivalent ANSYS command: PRESOL, S\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nprincipal (bool, optional) – Returns principal stresses instead of component stresses.\nDefault False.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\n**kwargs (optional keyword arguments) – Hidden options for distributed result files.\n\nReturns\n\nenum (np.ndarray) – ANSYS element numbers corresponding to each element.\n\nelement_stress (list) – Stresses at each element for each node for Sx Sy Sz Sxy\nSyz Sxz or SIGMA1, SIGMA2, SIGMA3, SINT, SEQV when\nprincipal is True.\n\nenode (list) – Node numbers corresponding to each element’s stress\nresults.  One list entry for each element.\n\nExamples\n\nElement component stress for the first result set.\n\n>>> rst.element_stress(0)\n\nElement principal stress for the first result set.\n\n>>> enum, element_stress, enode = result.element_stress(0, principal=True)\n\nNotes\n\nShell stresses for element 181 are returned for top and bottom\nlayers.  Results are ordered such that the top layer and then\nthe bottom layer is reported.\n\n\n\nproperty filename: str\n\nString form of the filename. This property is read-only.\n\n\n\nproperty materials\n\nResult file material properties.\n\nReturns\n\nDictionary of Materials.  Keys are the material numbers,\nand each material is a dictionary of the material\nproperrties of that material with only the valid entries filled.\n\nReturn type\n\ndict\n\nNotes\n\nMaterial properties:\n\nEX : Elastic modulus, element x direction (Force/Area)\n\nEY : Elastic modulus, element y direction (Force/Area)\n\nEZ : Elastic modulus, element z direction (Force/Area)\n\nALPX : Coefficient of thermal expansion, element x direction (Strain/Temp)\n\nALPY : Coefficient of thermal expansion, element y direction (Strain/Temp)\n\nALPZ : Coefficient of thermal expansion, element z direction (Strain/Temp)\n\nREFT : Reference temperature (as a property) [TREF]\n\nPRXY : Major Poisson’s ratio, x-y plane\n\nPRYZ : Major Poisson’s ratio, y-z plane\n\nPRX  Z : Major Poisson’s ratio, x-z plane\n\nNUXY : Minor Poisson’s ratio, x-y plane\n\nNUYZ : Minor Poisson’s ratio, y-z plane\n\nNUXZ : Minor Poisson’s ratio, x-z plane\n\nGXY : Shear modulus, x-y plane (Force/Area)\n\nGYZ : Shear modulus, y-z plane (Force/Area)\n\nGXZ : Shear modulus, x-z plane (Force/Area)\n\nDAMP : K matrix multiplier for damping [BETAD] (Time)\n\nMU\n\nCoefficient of friction (or, for FLUID29 and FLUID30\n\nelements, boundary admittance)\n\nDENS : Mass density (Mass/Vol)\n\nC : Specific heat (Heat/Mass*Temp)\n\nENTH : Enthalpy (e DENS*C d(Temp)) (Heat/Vol)\n\nKXX\n\nThermal conductivity, element x direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKYY\n\nThermal conductivity, element y direction\n\n(Heat*Length / (Time*Area*Temp))\n\nKZZ\n\nThermal conductivity, element z direction\n\n(Heat*Length / (Time*Area*Temp))\n\nHF : Convection (or film) coefficient (Heat / (Time*Area*Temp))\n\nEMIS : Emissivity\n\nQRATE : Heat generation rate (MASS71 element only) (Heat/Time)\n\nVISC : Viscosity (Force*Time / Length2)\n\nSONC : Sonic velocity (FLUID29 and FLUID30 elements only) (Length/Time)\n\nRSVX : Electrical resistivity, element x direction (Resistance*Area / Length)\n\nRSVY : Electrical resistivity, element y direction (Resistance*Area / Length)\n\nRSVZ : Electrical resistivity, element z direction (Resistance*Area / Length)\n\nPERX : Electric permittivity, element x direction (Charge2 / (Force*Length))\n\nPERY : Electric permittivity, element y direction (Charge2 / (Force*Length))\n\nPERZ : Electric permittivity, element z direction (Charge2 / (Force*Length))\n\nMURX : Magnetic relative permeability, element x direction\n\nMURY : Magnetic relative permeability, element y direction\n\nMURZ : Magnetic relative permeability, element z direction\n\nMGXX : Magnetic coercive force, element x direction (Charge / (Length*Time))\n\nMGYY : Magnetic coercive force, element y direction (Charge / (Length*Time))\n\nMGZZ : Magnetic coercive force, element z direction (Charge / (Length*Time))\n\nMaterials may contain the key \"stress_failure_criteria\", which\ncontains failure criteria information for temperature-dependent stress\nlimits. This includes the following keys:\n\nXTEN : Allowable tensile stress or strain in the x-direction. (Must\nbe positive.)\n\nXCMP : Allowable compressive stress or strain in the\nx-direction. (Defaults to negative of XTEN.)\n\nYTEN : Allowable tensile stress or strain in the y-direction. (Must\nbe positive.)\n\nYCMP : Allowable compressive stress or strain in the\ny-direction. (Defaults to negative of YTEN.)\n\nZTEN : Allowable tensile stress or strain in the z-direction. (Must\nbe positive.)\n\nZCMP : Allowable compressive stress or strain in the\nz-direction. (Defaults to negative of ZTEN.)\n\nXY : Allowable XY stress or shear strain. (Must be positive.)\n\nYZ : Allowable YZ stress or shear strain. (Must be positive.)\n\nXZ : Allowable XZ stress or shear strain. (Must be positive.)\n\nXYCP : XY coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nYZCP : YZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZCP : XZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]\n\nXZIT : XZ tensile inclination parameter for Puck failure index (default =\n0.0)\n\nXZIC : XZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIT : YZ tensile inclination parameter for Puck failure index\n(default = 0.0)\n\nYZIC : YZ compressive inclination parameter for Puck failure index\n(default = 0.0)\n\nExamples\n\nReturn the material properties from the example result\nfile. Note that the keys of rst.materials is the material\ntype.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.materials\n{1: {'EX': 16900000.0, 'NUXY': 0.31, 'DENS': 0.00041408}}\n\n\n\nproperty mesh\n\nMesh from result file.\n\nExamples\n\n>>> rst.mesh\nANSYS Mesh\n  Number of Nodes:              1448\n  Number of Elements:           226\n  Number of Element Types:      1\n  Number of Node Components:    0\n  Number of Element Components: 0\n\n\n\nproperty n_results\n\nNumber of results\n\n\n\nproperty n_sector\n\nNumber of sectors\n\n\n\nnodal_acceleration(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal accelerations.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_acceleration(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_boundary_conditions(rnum)\n\nNodal boundary conditions for a given result number.\n\nThese nodal boundary conditions are generally set with the\nAPDL command D.  For example, D, 25, UX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with boundary conditions.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith boundary conditions.  See rst.result_dof for the\ndegrees of freedom associated with each index.\n\nbc (np.ndarray) – Boundary conditions.\n\nExamples\n\nPrint the boundary conditions where:\n- Node 3 is fixed\n- Node 25 has UX=0.001\n- Node 26 has UY=0.0011\n- Node 27 has UZ=0.0012\n\n>>> rst.nodal_boundary_conditions(0)\n(array([ 3,  3,  3, 25, 26, 27], dtype=int32),\narray([1, 2, 3, 1, 2, 3], dtype=int32),\narray([0.    , 0.    , 0.    , 0.001 , 0.0011, 0.0012]))\n\n\n\nnodal_displacement(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_elastic_strain(rnum, nodes=None)\n\nNodal component elastic strains.  This record contains\nstrains in the order X, Y, Z, XY, YZ, XZ, EQV.\n\nElastic strains can be can be nodal values extrapolated from\nthe integration points or values at the integration points\nmoved to the nodes.\n\nEquivalent MAPDL command: PRNSOL, EPEL\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nelastic_strain (np.ndarray) – Nodal component elastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal elastic strain for the first result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0)\n\nReturn the nodal elastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal elastic strain just for the nodes from 20 through 50.\n\n>>> nnum, elastic_strain = rst.nodal_elastic_strain(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a strain will be NAN.\n\n\n\nnodal_input_force(rnum)\n\nNodal input force for a given result number.\n\nNodal input force is generally set with the APDL command\nF.  For example, F, 25, FX, 0.001\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnnum (np.ndarray) – Node numbers of the nodes with nodal forces.\n\ndof (np.ndarray) – Array of indices of the degrees of freedom of the nodes\nwith input force.  See rst.result_dof for the degrees\nof freedom associated with each index.\n\nforce (np.ndarray) – Nodal input force.\n\nExamples\n\nPrint the nodal input force where:\n- Node 25 has FX=20\n- Node 26 has FY=30\n- Node 27 has FZ=40\n\n>>> rst.nodal_input_force(0)\n(array([ 71,  52, 127], dtype=int32),\n array([2, 1, 3], dtype=int32),\n array([30., 20., 40.]))\n\n\n\nnodal_plastic_strain(rnum, nodes=None)\n\nNodal component plastic strains.\n\nThis record contains strains in the order:\nX, Y, Z, XY, YZ, XZ, EQV.\n\nPlastic strains are always values at the integration points\nmoved to the nodes.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nplastic_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV.\n\nExamples\n\nLoad the nodal plastic strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0)\n\nReturn the nodal plastic strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal plastic strain just for the nodes from 20\nthrough 50.\n\n>>> nnum, plastic_strain = rst.nodal_plastic_strain(0, nodes=range(20, 51))\n\n\n\nnodal_reaction_forces(rnum)\n\nNodal reaction forces.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nrforces (np.ndarray) – Nodal reaction forces for each degree of freedom.\n\nnnum (np.ndarray) – Node numbers corresponding to the reaction forces.  Node\nnumbers may be repeated if there is more than one degree\nof freedom for each node.\n\ndof (np.ndarray) – Degree of freedom corresponding to each node using the\nMAPDL degree of freedom reference table.  See\nrst.result_dof for the corresponding degrees of\nfreedom for a given solution.\n\nExamples\n\nGet the nodal reaction forces for the first result and print\nthe reaction forces of a single node.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rforces, nnum, dof = rst.nodal_reaction_forces(0)\n>>> dof_ref = rst.result_dof(0)\n>>> rforces[:3], nnum[:3], dof[:3], dof_ref\n(array([  24102.21376091, -109357.01854005,   22899.5303263 ]),\n array([4142, 4142, 4142]),\n array([1, 2, 3], dtype=int32),\n ['UX', 'UY', 'UZ'])\n\n\n\nnodal_solution(rnum, in_nodal_coord_sys=False, nodes=None)\n\nReturns the DOF solution for each node in the global\ncartesian coordinate system or nodal coordinate system.\n\nSolution may be nodal temperatures or nodal displacements\ndepending on the type of the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal displacements or nodal temperatures.  Array\nis (nnod x sumdof), the number of nodes by the\nnumber of degrees of freedom which includes numdof and\nnfldof\n\nExamples\n\nReturn the nodal solution (in this case, displacement) for the\nfirst result of \"file.rst\".\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_solution(0)\n\nReturn the nodal solution just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, data = rst.nodal_solution(0, nodes='MY_COMPONENT')\n\nReturn the nodal solution just for the nodes from 20 through 50.\n\n>>> nnum, data = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nnodal_static_forces(rnum, nodes=None)\n\nReturn the nodal forces averaged at the nodes.\n\nNodal forces are computed on an element by element basis, and\nthis method averages the nodal forces for each element for\neach node.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nforces (np.ndarray) – Averaged nodal forces.  Array is sized [nnod x numdof]\nwhere nnod is the number of nodes and numdof is the\nnumber of degrees of freedom for this solution.\n\nExamples\n\nLoad the nodal static forces for the first result using the\nexample hexahedral result file.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> nnum, forces = rst.nodal_static_forces(0)\n\nReturn the nodal static forces just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes='MY_COMPONENT')\n\nReturn the nodal static forces just for the nodes from 20 through 50.\n\n>>> nnum, forces = rst.nodal_static_forces(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a a nodal will be NAN.  These are generally\nmidside (quadratic) nodes.\n\n\n\nnodal_stress(rnum, nodes=None)\n\nRetrieves the component stresses for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nComputes the nodal stress by averaging the stress for each\nelement at each node.  Due to the discontinuities across\nelements, stresses will vary based on the element they are\nevaluated from.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\nstress (numpy.ndarray) – Stresses at X, Y, Z, XY, YZ, XZ averaged at each corner\nnode.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.nodal_stress(0)\n\nReturn the nodal stress just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, stress = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the nodal stress just for the nodes from 20 through 50.\n\n>>> nnum, stress = rst.nodal_solution(0, nodes=range(20, 51))\n\nNotes\n\nNodes without a stress value will be NAN.\nEquivalent ANSYS command: PRNSOL, S\n\n\n\nnodal_temperature(rnum, nodes=None, **kwargs)\n\nRetrieves the temperature for each node in the\nsolution.\n\nThe order of the results corresponds to the sorted node\nnumbering.\n\nEquivalent MAPDL command: PRNSOL, TEMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (numpy.ndarray) – Node numbers of the result.\n\ntemperature (numpy.ndarray) – Temperature at each node.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, temp = rst.nodal_temperature(0)\n\nReturn the temperature just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, temp = rst.nodal_stress(0, nodes='MY_COMPONENT')\n\nReturn the temperature just for the nodes from 20 through 50.\n\n>>> nnum, temp = rst.nodal_solution(0, nodes=range(20, 51))\n\n\n\nnodal_thermal_strain(rnum, nodes=None)\n\nNodal component thermal strain.\n\nThis record contains strains in the order X, Y, Z, XY, YZ, XZ,\nEQV, and eswell (element swelling strain).  Thermal strains\nare always values at the integration points moved to the\nnodes.\n\nEquivalent MAPDL command: PRNSOL, EPTH, COMP\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nnodes (str, sequence of int or str, optional) – Select a limited subset of nodes.  Can be a nodal\ncomponent or array of node numbers.  For example\"MY_COMPONENT\"\n\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nnp.arange(1000, 2001)\n\nReturns\n\nnnum (np.ndarray) – MAPDL node numbers.\n\nthermal_strain (np.ndarray) – Nodal component plastic strains.  Array is in the order\nX, Y, Z, XY, YZ, XZ, EQV, ESWELL\n\nExamples\n\nLoad the nodal thermal strain for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0)\n\nReturn the nodal thermal strain just for the nodal component\n'MY_COMPONENT'.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes='MY_COMPONENT')\n\nReturn the nodal thermal strain just for the nodes from 20 through 50.\n\n>>> nnum, thermal_strain = rst.nodal_thermal_strain(0, nodes=range(20, 51))\n\n\n\nnodal_time_history(solution_type='NSL', in_nodal_coord_sys=False)\n\nThe DOF solution for each node for all result sets.\n\nThe nodal results are returned returned in the global\ncartesian coordinate system or nodal coordinate system.\n\nParameters\n\nsolution_type (str, optional) – The solution type.  Must be either nodal displacements\n('NSL'), nodal velocities ('VEL') or nodal\naccelerations ('ACC').\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate system.\nDefault False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Nodal solution for all result sets.  Array is sized\nrst.nsets x nnod x Sumdof, which is the number of\ntime steps by number of nodes by degrees of freedom.\n\n\n\nnodal_velocity(rnum, in_nodal_coord_sys=False)\n\nNodal velocities for a given result set.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nin_nodal_coord_sys (bool, optional) – When True, returns results in the nodal coordinate\nsystem.  Default False.\n\nReturns\n\nnnum (int np.ndarray) – Node numbers associated with the results.\n\nresult (float np.ndarray) – Array of nodal velocities.  Array is (nnod x\nsumdof), the number of nodes by the number of degrees\nof freedom which includes numdof and nfldof\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, data = rst.nodal_velocity(0)\n\nNotes\n\nSome solution results may not include results for each node.\nThese results are removed by and the node numbers of the\nsolution results are reflected in nnum.\n\n\n\nproperty node_components\n\nDictionary of ansys node components from the result file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> rst = pymapdl_reader.read_binary(examples.rstfile)\n>>> rst.node_components.keys()\ndict_keys(['ECOMP1', 'ECOMP2', 'ELEM_COMP'])\n>>> rst.node_components['NODE_COMP']\narray([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n      20], dtype=int32)\n\n\n\noverwrite_element_solution_record(data, rnum, solution_type, element_id)\n\nOverwrite element solution record.\n\nThis method replaces solution data for of an element at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\ndata (list or np.ndarray) – Data that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nelement_id (int) – Ansys element number (e.g. 1)\n\nExamples\n\nOverwrite the elastic strain record for element 1 for the\nfirst result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = np.random.random(56)\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL', 1)\n\n\n\noverwrite_element_solution_records(element_data, rnum, solution_type)\n\nOverwrite element solution record.\n\nThis method replaces solution data for a set of elements at a\nresult index for a given solution type.  The number of items\nin data must match the number of items in the record.\n\nIf you are not sure how many records are in a given record,\nuse element_solution_data to retrieve all the records for\na given solution_type and check the number of items in the\nrecord.\n\nNote: The record being replaced cannot be a compressed record.\nIf the result file uses compression (default sparse\ncompression as of 2019R1), you can disable this within MAPDL\nwith:\n/FCOMP, RST, 0\n\nParameters\n\nelement_data (dict) – Dictionary of results that will replace the existing records.\n\nrnum (int) – Zero based result number.\n\nsolution_type (str) – Element data type to overwrite.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nExamples\n\nOverwrite the elastic strain record for elements 1 and 2 with\nfor the first result with random data.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> data = {1: np.random.random(56),\n            2: np.random.random(56)}\n>>> rst.overwrite_element_solution_data(data, 0, 'EEL')\n\n\n\nparse_coordinate_system()\n\nReads in coordinate system information from a binary result file.\n\nReturns\n\nc_systems – Dictionary containing one entry for each defined coordinate system.\nIf no non-standard coordinate systems have been defined, an empty\ndictionary will be returned.  First coordinate system is assumed to\nbe global cartesian.\n\nReturn type\n\ndict\n\nNotes\n\neuler angles : [THXY, THYZ, THZX]\n\nFirst rotation about local Z (positive X toward Y).\n\nSecond rotation about local X (positive Y toward Z).\n\nThird rotation about local Y (positive Z toward X).\n\nPAR1\nUsed for elliptical, spheroidal, or toroidal systems. If KCS =\n1 or 2, PAR1 is the ratio of the ellipse Y-axis radius to\nX-axis radius (defaults to 1.0 (circle)). If KCS = 3, PAR1 is\nthe major radius of the torus.\n\nPAR2\nUsed for spheroidal systems. If KCS = 2, PAR2 = ratio of\nellipse Z-axis radius to X-axis radius (defaults to 1.0\n(circle)).\n\nCoordinate system type:\n\n0: Cartesian\n\n1: Cylindrical (circular or elliptical)\n\n2: Spherical (or spheroidal)\n\n3: Toroidal\n\n\n\nparse_step_substep(user_input)\n\nConverts (step, substep) to a cumulative index\n\n\n\nproperty pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nplot(node_components=None, element_components=None, sel_type_all=True, **kwargs)\n\nPlot result geometry\n\nParameters\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – List of camera position, focal point, and view up.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> rst.plot()\n\nPlot just the element component ‘ROTOR_SHAFT’\n\n>>> rst.plot(element_components='ROTOR_SHAFT')\n\nPlot two node components\n>>> rst.plot(node_components=[‘MY_COMPONENT’, ‘MY_OTHER_COMPONENT’])\n\n\n\nplot_cylindrical_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal_stress in the cylindrical coordinate system.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"R\"\n- \"THETA\"\n- \"Z\"\n- \"RTHETA\"\n- \"THETAZ\"\n- \"RZ\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal stress in the radial direction.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_cylindrical_nodal_stress(0, 'R')\n\n\n\nplot_element_result(rnum, result_type, item_index, in_element_coord_sys=False, **kwargs)\n\nPlot an element result.\n\nParameters\n\nrnum (int) – Result number.\n\nresult_type (str) – Element data type to retrieve.EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nitem_index (int) – Index of the data item for each node within the element.\n\nin_element_coord_sys (bool, optional) – Returns the results in the element coordinate system.\nDefault False and will return the results in the global\ncoordinate system.\n\nReturns\n\nnnum (np.ndarray) – ANSYS node numbers\n\nresult (np.ndarray) – Array of result data\n\n\n\nplot_nodal_displacement(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)\n\n\n\nplot_nodal_elastic_strain(rnum, comp, scalar_bar_args={'title': 'EQV Nodal Elastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal elastic strain.\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Elastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT']\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot nodal elastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_elastic_strain(0)\n\n\n\nplot_nodal_plastic_strain(rnum, comp, scalar_bar_args={'title': 'Nodal Plastic Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component plastic strain.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Plastic strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nExamples\n\nPlot plastic strain for a static pontoon model\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_pontoon()\n>>> result.plot_nodal_plastic_strain(0)\n\n\n\nplot_nodal_solution(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the nodal solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Display component to display.  Options are 'X',\n'Y', 'Z', 'NORM', or an available degree of\nfreedom.  Result may also include other degrees of\nfreedom, check rst.result_dof for available degrees of\nfreedoms for a given result.  Defaults to \"NORM\" for a\nstructural displacement result, and \"TEMP\" for a\nthermal result.\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot).\n\nReturns\n\ncpos – Camera position from vtk render window.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the nodal solution result 0 of verification manual\nexample\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_solution(0)\n\nPlot with a white background and showing edges\n\n>>> result.plot_nodal_solution(0, background='w', show_edges=True)\n\n\n\nplot_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlots the stresses at each node in the solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (str, optional) – Stress component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – 3 x 3 vtk camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the X component nodal stress while showing displacement.\n\n>>> rst.plot_nodal_stress(0, comp='x', show_displacement=True)\n\n\n\nplot_nodal_temperature(rnum, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal temperature\n\nParameters\n\nrnum (int) – Result number\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot temperature of a result.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> result = pymapdl_reader.read_binary('file.rst')\n>>> result.plot_nodal_temperature(0)\n\nPlot while showing edges and disabling lighting\n\n>>> result.plot_nodal_temperature(0, show_edges=True, lighting=False)\n\n\n\nplot_nodal_thermal_strain(rnum, comp=None, scalar_bar_args={'title': 'Nodal Thermal Strain'}, show_displacement=False, displacement_factor=1, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot nodal component thermal strains.\n\nEquivalent MAPDL command: PLNSOL, EPTH, COMP\n\nParameters\n\nrnum (int) – Result number\n\ncomp (str, optional) – Thermal strain component to display.  Available options:\n- \"X\"\n- \"Y\"\n- \"Z\"\n- \"XY\"\n- \"YZ\"\n- \"XZ\"\n- \"EQV\"\n- \"ESWELL\"\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\n**kwargs (keyword arguments) – Optional keyword arguments.  See help(pyvista.plot)\n\nExamples\n\nPlot thermal strain for result 0 of verification manual example 33.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> result = examples.download_verification_result(33)\n>>> result.plot_nodal_thermal_strain(0)\n\n\n\nplot_principal_nodal_stress(rnum, comp=None, show_displacement=False, displacement_factor=1.0, node_components=None, element_components=None, sel_type_all=True, treat_nan_as_zero=False, **kwargs)\n\nPlot the principal stress.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\ncomp (string) – Stress component to plot.  S1, S2, S3 principal stresses, SINT\nstress intensity, and SEQV equivalent stress.Stress type must be a string from the following list:\n['S1', 'S2', 'S3', 'SINT', 'SEQV']\n\nshow_displacement (bool, optional) – Deforms mesh according to the result.\n\ndisplacement_factor (float, optional) – Increases or decreases displacement by a factor.\n\nnode_components (list, optional) – Accepts either a string or a list strings of node\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nelement_components (list, optional) – Accepts either a string or a list strings of element\ncomponents to plot.  For example:\n['MY_COMPONENT', 'MY_OTHER_COMPONENT]\n\nsel_type_all (bool, optional) – If node_components is specified, plots those elements\ncontaining all nodes of the component.  Default True.\n\ntreat_nan_as_zero (bool, optional) – Treat NAN values (i.e. stresses at midside nodes) as zero\nwhen plotting.\n\nkwargs (keyword arguments) – Additional keyword arguments.  See help(pyvista.plot)\n\nReturns\n\ncpos – VTK camera position.\n\nReturn type\n\nlist\n\nExamples\n\nPlot the equivalent von mises stress.\n\n>>> rst.plot_principal_nodal_stress(0, comp='SEQV')\n\n\n\nprincipal_nodal_stress(rnum, nodes=None)\n\nComputes the principal component stresses for each node in\nthe solution.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nnodenum (numpy.ndarray) – Node numbers of the result.\n\npstress (numpy.ndarray) – Principal stresses, stress intensity, and equivalent stress.\n[sigma1, sigma2, sigma3, sint, seqv]\n\nExamples\n\nLoad the principal nodal stress for the first solution.\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> rst = pymapdl_reader.read_binary('file.rst')\n>>> nnum, stress = rst.principal_nodal_stress(0)\n\nNotes\n\nANSYS equivalent of:\nPRNSOL, S, PRIN\n\nwhich returns:\nS1, S2, S3 principal stresses, SINT stress intensity, and SEQV\nequivalent stress.\n\nInternal averaging algorithm averages the component values\nfrom the elements at a common node and then calculates the\nprincipal using the averaged value.\n\nSee the MAPDL AVPRIN command for more details.\nansys-mapdl-reader uses the default AVPRIN, 0 option.\n\n\n\nresult_dof(rnum)\n\nReturn a list of degrees of freedom for a given result number.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\ndof – List of degrees of freedom.\n\nReturn type\n\nlist\n\nExamples\n\n>>> rst.result_dof(0)\n['UX', 'UY', 'UZ']\n\n\n\nsave_as_vtk(filename, rsets=None, result_types=['ENS'], progress_bar=True)\n\nWrites results to a vtk readable file.\n\nNodal results will always be written.\n\nThe file extension will select the type of writer to use.\n'.vtk' will use the legacy writer, while '.vtu' will\nselect the VTK XML writer.\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of grid to be written.  The file extension will\nselect the type of writer to use.  '.vtk' will use the\nlegacy writer, while '.vtu' will select the VTK XML\nwriter.\n\nrsets (collections.Iterable) – List of result sets to write.  For example range(3) or\n[0].\n\nresult_types (list) – Result type to write.  For example ['ENF', 'ENS']\nList of some or all of the following:EMS: misc. data\n\nENF: nodal forces\n\nENS: nodal stresses\n\nENG: volume and energies\n\nEGR: nodal gradients\n\nEEL: elastic strains\n\nEPL: plastic strains\n\nECR: creep strains\n\nETH: thermal strains\n\nEUL: euler angles\n\nEFX: nodal fluxes\n\nELF: local forces\n\nEMN: misc. non-sum values\n\nECD: element current densities\n\nENL: nodal nonlinear data\n\nEHC: calculated heat generations\n\nEPT: element temperatures\n\nESF: element surface stresses\n\nEDI: diffusion strains\n\nETB: ETABLE items\n\nECT: contact data\n\nEXY: integration point locations\n\nEBA: back stresses\n\nESV: state variables\n\nMNL: material nonlinear record\n\nprogress_bar (bool, optional) – Display a progress bar using tqdm.\n\nExamples\n\nWrite nodal results as a binary vtk file.\n\n>>> rst.save_as_vtk('results.vtk')\n\nWrite using the xml writer\n\n>>> rst.save_as_vtk('results.vtu')\n\nWrite only nodal and elastic strain for the first result\n\n>>> rst.save_as_vtk('results.vtk', [0], ['EEL', 'EPL'])\n\nWrite only nodal results (i.e. displacements) for the first result.\n\n>>> rst.save_as_vtk('results.vtk', [0], [])\n\n\n\nproperty section_data\n\nThe section data from the result file\n\nReturns\n\nsection_data – Dictionary of the section data with the section numbers as\nkeys.\n\nReturn type\n\ndict\n\nNotes\n\nThere is limited documentation on how ANSYS stores the\nsections within a result file, and as such it may be difficult\nto interpret the section data for a given model.\n\n\n\nsolution_info(rnum)\n\nReturn an informative dictionary of solution data for a\nresult.\n\nParameters\n\nrnum (int or list) – Cumulative result number with zero based indexing, or a\nlist containing (step, substep) of the requested result.\n\nReturns\n\nheader – Double precision solution header data.\n\nReturn type\n\ndict\n\nExamples\n\nExtract the solution info from a sample example result file.\n\n>>> from ansys.mapdl.reader import examples\n>>> rst = examples.download_pontoon()\n>>> rst.solution_info(0)\n{'cgcent': [],\n 'fatjack': [],\n 'timfrq': 44.85185724963714,\n 'lfacto': 1.0,\n 'lfactn': 1.0,\n 'cptime': 3586.4873046875,\n 'tref': 71.6,\n 'tunif': 71.6,\n 'tbulk': 293.0,\n 'volbase': 0.0,\n 'tstep': 0.0,\n '__unused': 0.0,\n 'accel_x': 0.0,\n 'accel_y': 0.0,\n 'accel_z': 0.0,\n 'omega_v_x': 0.0,\n 'omega_v_y': 0.0,\n 'omega_v_z': 0.0,\n 'omega_a_x': 0.0,\n 'omega_a_y': 0.0,\n 'omega_a_z': 0.0,\n 'omegacg_v_x': 0.0,\n 'omegacg_v_y': 0.0,\n 'omegacg_v_z': 0.0,\n 'omegacg_a_x': 0.0,\n 'omegacg_a_y': 0.0,\n 'omegacg_a_z': 0.0,\n 'dval1': 0.0,\n 'pCnvVal': 0.0}\n\nNotes\n\nThe keys of the solution header are described below:\n\ntimfrq\n\nTime value (or frequency value, for a modal or\n\nharmonic analysis)\n\nlfacto\n\nthe “old” load factor (used in ramping a load\n\nbetween old and new values)\n\nlfactn  : The “new” load factor\n\ncptime  : Elapsed CPU time (in seconds)\n\ntref    : The reference temperature\n\ntunif   : The uniform temperature\n\ntbulk   : Bulk temp for FLOTRAN film coefs.\n\nVolBase : Initial total volume for VOF\n\ntstep   : Time Step size for FLOTRAN analysis\n\n0.0     : Position not used\n\naccel   : Linear acceleration terms\n\nomega\n\nAngular velocity (first 3 terms) and angular acceleration\n\n(second 3 terms)\n\nomegacg\n\nAngular velocity (first 3 terms) and angular\n\nacceleration (second 3 terms) these\nvelocity/acceleration terms are computed about the\ncenter of gravity\n\ncgcent  : (X,y,z) location of center of gravity\n\nfatjack : Fatjack ocean wave data (wave height and period)\n\ndval1\n\nIf pmeth=0: FATJACK ocean wave direction\n\nif pmeth=1: p-method convergence values\n\npCnvVal : P-method convergence values\n\n\n\ntext_result_table(rnum)\n\nReturns a text result table for plotting\n\n\n\nproperty version\n\nThe version of MAPDL used to generate this result file.\n\nExamples\n\n>>> rst.version\n20.1\n\n\n\nwrite_tables(filename: str | Path)\n\nWrite binary tables to ASCII.  Assumes int32\n\nParameters\n\nfilename (str, pathlib.Path) – Filename to write the tables to.\n\nExamples\n\n>>> rst.write_tables('tables.txt')"},{"objectID":"Home","href":"examples/00-read_binary/load_thermal_result.html#thermal-analysis","title":"Thermal Analysis","text":"Thermal Analysis\n\nVisualize the result of verification manual test 33.\n\nDownload the result file from verification manual test case 33\n\n\n\nPlot with contours\n\n\n\nTotal running time of the script: (0 minutes 0.462 seconds)\n\n\n\nDownload Jupyter notebook: load_thermal_result.ipynb\n\nDownload Python source code: load_thermal_result.py\n\nDownload zipped: load_thermal_result.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"user_guide/archive.html#reading-and-writing-mapdl-archive-files","title":"Reading and Writing Mapdl Archive Files","text":"Reading and Writing Mapdl Archive Files"},{"objectID":"Home","href":"user_guide/archive.html#reading-ansys-archives","title":"Reading and Writing Mapdl Archive Files > Reading ANSYS Archives","text":"Reading ANSYS Archives\n\nMAPDL archive *.cdb and *.dat files containing elements (both\nlegacy and modern) can be loaded using Archive and then converted to a\nvtk object:\n\nYou can also optionally read in any stored parameters within the\narchive file by enabling the read_parameters parameter.\n\nSee the Archive class documentation below for more details on the\nclass methods and properties."},{"objectID":"Home","href":"user_guide/archive.html#writing-ansys-archives","title":"Reading and Writing Mapdl Archive Files > Writing ANSYS Archives","text":"Writing ANSYS Archives\n\nUnstructured grids generated using VTK can be converted to ANSYS APDL\narchive files and loaded into any version of ANSYS using\npymapdl_reader.save_as_archive.  The following example using the\nbuilt-in archive file demonstrates this capability.\n\nResulting ANSYS quality report:"},{"objectID":"Home","href":"user_guide/archive.html#converting-a-mapdl-archive-file-to-vtk-for-paraview","title":"Reading and Writing Mapdl Archive Files > Converting a MAPDL Archive File to VTK for Paraview","text":"Converting a MAPDL Archive File to VTK for Paraview\n\nMAPDL archive files containing solid elements (both legacy and modern)\ncan be loaded using Archive and then converted to a VTK object.\n\nYou can then load this vtk file using pyvista or another program that uses VTK."},{"objectID":"Home","href":"user_guide/archive.html#supported-elements","title":"Reading and Writing Mapdl Archive Files > Supported Elements","text":"Supported Elements\n\nAt the moment, only solid elements are supported by the\nsave_as_archive function, to include:\n\nvtk.VTK_TETRA\n\nvtk.VTK_QUADRATIC_TETRA\n\nvtk.VTK_PYRAMID\n\nvtk.VTK_QUADRATIC_PYRAMID\n\nvtk.VTK_WEDGE\n\nvtk.VTK_QUADRATIC_WEDGE\n\nvtk.VTK_HEXAHEDRON\n\nvtk.VTK_QUADRATIC_HEXAHEDRON\n\nLinear element types will be written as SOLID185, quadratic elements\nwill be written as SOLID186, except for quadratic tetrahedrals, which\nwill be written as SOLID187."},{"objectID":"Home","href":"user_guide/archive.html#archive-class","title":"Reading and Writing Mapdl Archive Files > Archive Class","text":"Archive Class\n\n\n\nclass ansys.mapdl.reader.archive.Archive(filename, read_parameters=False, parse_vtk=True, force_linear=False, allowable_types=None, null_unallowed=False, verbose=False, name='', read_eblock=True)\n\nRead a blocked ANSYS archive file or input file.\n\nReads a blocked CDB file and optionally parses it to a vtk grid.\nThis can be used to read in files written from MAPDL using the\nCDWRITE command or input files ('.dat') files written from\nANSYS Workbench.\n\nWrite the archive file using CDWRITE, DB, archive.cdb\n\nParameters\n\nfilename (string, pathlib.Path) – Filename of block formatted cdb file\n\nread_parameters (bool, optional) – Optionally read parameters from the archive file.  Default\nFalse.\n\nparse_vtk (bool, optional) – When True, parse the raw data into to VTK format.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nverbose (bool, optional) – Print out each step when reading the archive file.  Used for\ndebug purposes and defaults to False.\n\nname (str, optional) – Internally used parameter used to have a custom __repr__.\n\nread_eblock (bool, default: True) – Read the element block.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> hex_beam = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> print(hex_beam)\nANSYS Archive File HexBeam.cdb\n  Number of Nodes:              40\n  Number of Elements:           321\n  Number of Element Types:      1\n  Number of Node Components:    2\n  Number of Element Components: 2\n\nPrint the node array\n\n>>> hex_beam.nodes\narray([[0.  , 0.  , 0.  ],\n       [1.  , 0.  , 0.  ],\n       [0.25, 0.  , 0.  ],\n       ...,\n       [0.75, 0.5 , 3.5 ],\n       [0.75, 0.5 , 4.  ],\n       [0.75, 0.5 , 4.5 ]])\n\nRead an ANSYS workbench input file\n\n>>> my_archive = pymapdl_reader.Archive('C:\\Users\\user\\stuff.dat')\n\nNotes\n\nThis class only reads EBLOCK records with SOLID records.  For\nexample, the record EBLOCK,19,SOLID,,3588 will be read, but\nEBLOCK,10,,,3588 will not be read.  Generally, MAPDL will only\nwrite SOLID records and Mechanical Workbench may write SOLID\nrecords.  These additional records will be ignored.\n\n\n\nproperty ekey\n\nElement type key\n\nArray containing element type numbers in the first column and\nthe element types (like SURF154) in the second column.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.ekey\narray([[  1,  45],\n       [  2,  95],\n       [  3,  92],\n       [ 60, 154]], dtype=int32)\n\n\n\nproperty elem\n\nList of elements containing raw ansys information.\n\nEach element contains 10 items plus the nodes belonging to the\nelement.  The first 10 items are:\n\nFIELD 0 : material reference number\n\nFIELD 1 : element type number\n\nFIELD 2 : real constant reference number\n\nFIELD 3 : section number\n\nFIELD 4 : element coordinate system\n\nFIELD 5 : death flag (0 - alive, 1 - dead)\n\nFIELD 6 : solid model reference\n\nFIELD 7 : coded shape key\n\nFIELD 8 : element number\n\nFIELD 9 : base element number (applicable to reinforcing elements only)\n\nFIELDS 10 - 30 : The nodes belonging to the element in ANSYS numbering.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem\n[array([  1,   4,  19,  15,  63,  91, 286, 240,   3,  18,  17,\n         16,  81, 276, 267, 258,  62,  90, 285, 239],\n array([  4,   2,   8,  19,  91,  44, 147, 286,   5,   7,  21,\n         18, 109, 137, 313, 276,  90,  43, 146, 285],\n array([ 15,  19,  12,  10, 240, 286, 203, 175,  17,  20,  13,\n         14, 267, 304, 221, 230, 239, 285, 202, 174],\n...\n\n\n\nproperty elem_real_constant\n\nReal constant reference for each element.\n\nUse the data within rlblock and rlblock_num to get the\nreal constant datat for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem_real_constant\narray([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        ...,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 61, 61, 61, 61,\n       61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n       61], dtype=int32)\n\n\n\nproperty element_components\n\nElement components for the archive.\n\nOutput is a dictionary of element components.  Each entry is an\narray of MAPDL element numbers corresponding to the element\ncomponent.  The keys are element component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_components\n{'ECOMP1 ': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n                   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n                   dtype=int32),\n'ECOMP2 ': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n                  14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32)}\n\n\n\nelement_coord_system()\n\nElement coordinate system number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_coord_system\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0], dtype=int32)\n\n\n\nproperty enum\n\nANSYS element numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.enum\narray([    1,     2,     3, ...,  9998,  9999, 10000])\n\n\n\nproperty et_id\n\nElement type id (ET) for each element.\n\n\n\nproperty etype\n\nElement type of each element.\n\nThis is the ansys element type for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.etype\narray([ 45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n        45,  45,  45,  45,  45,  45,  45,  45,  92,  92,  92,\n        92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,\n        ...,\n        92,  92,  92,  92,  92, 154, 154, 154, 154, 154, 154,\n       154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n       154], dtype=int32)\n\nNotes\n\nElement types are listed below.  Please see the APDL Element\nReference for more details:\n\nhttps://www.mm.bme.hu/~gyebro/files/vem/ansys_14_element_reference.pdf\n\n\n\nproperty filename: str\n\nString form of the filename. This property is read-only.\n\n\n\nproperty grid\n\nReturn a pyvista.UnstructuredGrid of the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.grid\nUnstructuredGrid (0x7ffa237f08a0)\n  N Cells:      40\n  N Points:     321\n  X Bounds:     0.000e+00, 1.000e+00\n  Y Bounds:     0.000e+00, 1.000e+00\n  Z Bounds:     0.000e+00, 5.000e+00\n  N Arrays:     13\n\n\n\nproperty key_option\n\nAdditional key options for element types\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.key_option\n{1: [[1, 11]]}\n\n\n\nproperty material_type\n\nMaterial type index of each element in the archive.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.material_type\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1], dtype=int32)\n\n\n\nproperty n_elem\n\nNumber of nodes\n\n\n\nproperty n_node\n\nNumber of nodes\n\n\n\nproperty nnum\n\nArray of node numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nnum\narray([    1,     2,     3, ..., 19998, 19999, 20000])\n\n\n\nproperty node_angles\n\nNode angles from the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n ...,\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]]\n\n\n\nproperty node_components\n\nNode components for the archive.\n\nOutput is a dictionary of node components.  Each entry is an\narray of MAPDL node numbers corresponding to the node\ncomponent.  The keys are node component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.node_components\n{'NCOMP2  ': array([  1,   2,   3,   4,   5,   6,   7,   8,\n                     14, 15, 16, 17, 18, 19, 20, 21, 43, 44,\n                     62, 63, 64, 81, 82, 90, 91, 92, 93, 94,\n                     118, 119, 120, 121, 122, 123, 124, 125,\n                     126, 137, 147, 148, 149, 150, 151, 152,\n                     153, 165, 166, 167, 193, 194, 195, 202,\n                     203, 204, 205, 206, 207, 221, 240, 258,\n                     267, 268, 276, 277, 278, 285, 286, 287,\n                     304, 305, 306, 313, 314, 315, 316\n                     ], dtype=int32),\n...,\n}\n\n\n\nproperty nodes\n\nArray of nodes.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [1.   0.   0.  ]\n [0.25 0.   0.  ]\n ...,\n [0.75 0.5  3.5 ]\n [0.75 0.5  4.  ]\n [0.75 0.5  4.5 ]]\n\n\n\nproperty parameters\n\nParameters stored in the archive file\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile,\n                                     read_parameters=True)\n>>> archive.parameters\n{}\n\n\n\nproperty pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nplot(off_screen: bool | None = None, full_screen: bool | None = None, screenshot: str | bool | None = None, interactive: bool = True, cpos: CameraPositionOptions | None = None, window_size: list[int] | None = None, show_bounds: bool = False, show_axes: bool | None = None, notebook: bool | None = None, background: ColorLike | None = None, text: str = '', return_img: bool = False, eye_dome_lighting: bool = False, volume: bool = False, parallel_projection: bool = False, jupyter_backend: JupyterBackendOptions | None = None, return_viewer: bool = False, return_cpos: bool = False, jupyter_kwargs: dict | None = None, theme: Theme | None = None, anti_aliasing: Literal['ssaa', 'msaa', 'fxaa'] | bool | None = None, zoom: str | float | None = None, border: bool = False, border_color: ColorLike = 'k', border_width: float = 2.0, ssao: bool = False, **kwargs)\n\nPlot a PyVista, numpy, or vtk object.\n\nAdded in version 0.47: plot can be invoked with the shell command:Run pyvista plot --help for more details on available parameters.Providing multiple files renders them inside the same window.\n\nParameters\n\nvar_item (pyvista.DataSet) – See Plotter.add_mesh for all\nsupported types.\n\noff_screen\n\nbool, optional\n\nPlots off screen when True.  Helpful for saving\nscreenshots without a window popping up.  Defaults to the\nglobal setting pyvista.OFF_SCREEN.\n\nfull_screen\n\nbool, default: pyvista.plotting.themes.Theme.full_screen\n\nOpens window in full screen.  When enabled, ignores\nwindow_size.\n\nscreenshot\n\nstr | bool, optional\n\nSaves screenshot to file when enabled.  See:\nPlotter.screenshot().\nDefault False.\n\nWhen True, takes screenshot and returns numpy array of\nimage.\n\ninteractive\n\nbool, default: pyvista.plotting.themes.Theme.interactive\n\nAllows user to pan and move figure.\n\ncpos\n\nCameraPositionOptions, optional\n\nList of camera position, focal point, and view up.\nSee the pyvista.Plotter.camera_position for concrete examples\non how to use this parameter and cameras_api for a detailed\ndocumentation on pyvista.Camera.\n\nwindow_size\n\nlist[int], default: pyvista.plotting.themes.Theme.window_size\n\nWindow size in pixels.\n\nshow_bounds\n\nbool, default: False\n\nShows mesh bounds when True.\n\nshow_axes\n\nbool, default: pyvista.plotting.themes._AxesConfig.show\n\nShows a vtk axes widget.\n\nnotebook\n\nbool, default: pyvista.plotting.themes.Theme.notebook\n\nWhen True, the resulting plot is placed inline a jupyter\nnotebook.  Assumes a jupyter console is active.\n\nbackground\n\nColorLike, default: pyvista.plotting.themes.Theme.background\n\nColor of the background.\n\ntext\n\nstr, optional\n\nAdds text at the bottom of the plot.\n\nreturn_img\n\nbool, default: False\n\nReturns numpy array of the last image rendered.\n\neye_dome_lighting\n\nbool, optional\n\nEnables eye dome lighting.\n\nvolume\n\nbool, default: False\n\nUse the Plotter.add_volume() method for volume rendering.\n\nparallel_projection\n\nbool, default: False\n\nEnable parallel projection.\n\njupyter_backend\n\nJupyterBackendOptions, optional\n\nJupyter notebook plotting backend to use.\nSee available documentation at pyvista.set_jupyter_backend()\nto see all valid values for this parameter along with a detailed documentation.\n\nDefaults to pyvista.plotting.themes.Theme.jupyter_backend\n\nreturn_viewer\n\nbool, default: False\n\nReturn the jupyterlab viewer, scene, or display object\nwhen plotting with jupyter notebook.\n\nreturn_cpos\n\nbool, default: False\n\nReturn the last camera position from the render window\nwhen enabled.  Defaults to value in theme settings.\n\njupyter_kwargs\n\ndict, optional\n\nKeyword arguments for the Jupyter notebook plotting backend.\nSee customize_trame_toolbar_example for an example\nusing this keyword.\n\ntheme\n\npyvista.plotting.themes.Theme, optional\n\nPlot-specific theme.\n\nanti_aliasing\n\nLiteral[‘ssaa’, ‘msaa’, ‘fxaa’] | bool, optional\n\nEnable or disable anti-aliasing. If True, uses \"msaa\". If False,\ndisables anti_aliasing. If a string, should be one of the following:\n\n\"ssaa\" - Super-Sample Anti-Aliasing\n\n\"msaa\" - Multi-Sample Anti-Aliasing\n\n\"fxaa\" - Fast Approximate Anti-Aliasing\n\nDefaults to pyvista.plotting.themes.Theme.anti_aliasing\n\nzoom\n\nfloat | str, optional\n\nCamera zoom.  Either 'tight' or a float. A value greater than 1\nis a zoom-in, a value less than 1 is a zoom-out.  Must be greater\nthan 0.\n\nborder\n\nbool, default: False\n\nDraw a border around each render window.\n\nborder_color\n\nColorLike, default: “k”\n\nEither a string, rgb list, or hex color string.  For example:\n\ncolor='white'\n\ncolor='w'\n\ncolor=[1.0, 1.0, 1.0]\n\ncolor='#FFFFFF'\n\nborder_width\n\nfloat, default: 2.0\n\nWidth of the border in pixels when enabled.\n\nssao\n\nbool, optional\n\nEnable surface space ambient occlusion (SSAO). See\nPlotter.enable_ssao() for more details.\n\n**kwargs\n\ndict, optional\n\nSee pyvista.Plotter.add_mesh() for additional options.\n\nReturns\n\ncpos (list) – List of camera position, focal point, and view up.\nReturned only when return_cpos=True or set in the\ndefault global or plot theme.  Not returned when in a\njupyter notebook and return_viewer=True.\n\nimage (np.ndarray) – Numpy array of the last image when either return_img=True\nor screenshot=True is set. Not returned when in a\njupyter notebook with return_viewer=True. Optionally\ncontains alpha values. Sized:\n\n[Window height x Window width x 3] if the theme sets\ntransparent_background=False.\n\n[Window height x Window width x 4] if the theme sets\ntransparent_background=True.\n\nwidget (ipywidgets.Widget) – IPython widget when return_viewer=True.\n\nExamples\n\nPlot a simple sphere while showing its edges.\n\n>>> import pyvista as pv\n>>> mesh = pv.Sphere()\n>>> mesh.plot(show_edges=True)\n\nPlot a volume mesh. Color by distance from the center of the\nImageData. Note volume=True is passed.\n\n>>> import numpy as np\n>>> grid = pv.ImageData(dimensions=(32, 32, 32), spacing=(0.5, 0.5, 0.5))\n>>> grid['data'] = np.linalg.norm(grid.center - grid.points, axis=1)\n>>> grid['data'] = np.abs(grid['data'] - grid['data'].max()) ** 3\n>>> grid.plot(volume=True)\n\n\n\nproperty quality\n\nMinimum scaled jacobian cell quality.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.quality\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n\n\n\nproperty rlblock\n\nReal constant data from the RLBLOCK.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rlblock\n[[0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.02 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.01 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005]]\n\n\n\nproperty rlblock_num\n\nIndices from the real constant data\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rnum\narray([60, 61, 62, 63])\n\n\n\nsave(filename, binary=True, force_linear=False, allowable_types=[], null_unallowed=False)\n\nSave the geometry as a vtk file\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of output file. Writer type is inferred from\nthe extension of the filename.\n\nbinary (bool, optional) – If True, write as binary, else ASCII.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nExamples\n\n>>> geom.save('mesh.vtk')\n\nNotes\n\nBinary files write much faster than ASCII and have a smaller\nfile size.\n\n\n\nproperty section\n\nSection number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.section\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1], dtype=int32)\n\n\n\nproperty tshape\n\nTshape of contact elements.\n\n\n\nproperty tshape_key\n\nDict with the mapping between element type and element shape.\n\nTShape is only applicable to contact elements."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive","title":"Reading and Writing Mapdl Archive Files > Archive Class > Archive","text":"class ansys.mapdl.reader.archive.Archive(filename, read_parameters=False, parse_vtk=True, force_linear=False, allowable_types=None, null_unallowed=False, verbose=False, name='', read_eblock=True)\n\nRead a blocked ANSYS archive file or input file.\n\nReads a blocked CDB file and optionally parses it to a vtk grid.\nThis can be used to read in files written from MAPDL using the\nCDWRITE command or input files ('.dat') files written from\nANSYS Workbench.\n\nWrite the archive file using CDWRITE, DB, archive.cdb\n\nParameters\n\nfilename (string, pathlib.Path) – Filename of block formatted cdb file\n\nread_parameters (bool, optional) – Optionally read parameters from the archive file.  Default\nFalse.\n\nparse_vtk (bool, optional) – When True, parse the raw data into to VTK format.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nverbose (bool, optional) – Print out each step when reading the archive file.  Used for\ndebug purposes and defaults to False.\n\nname (str, optional) – Internally used parameter used to have a custom __repr__.\n\nread_eblock (bool, default: True) – Read the element block.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> hex_beam = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> print(hex_beam)\nANSYS Archive File HexBeam.cdb\n  Number of Nodes:              40\n  Number of Elements:           321\n  Number of Element Types:      1\n  Number of Node Components:    2\n  Number of Element Components: 2\n\nPrint the node array\n\n>>> hex_beam.nodes\narray([[0.  , 0.  , 0.  ],\n       [1.  , 0.  , 0.  ],\n       [0.25, 0.  , 0.  ],\n       ...,\n       [0.75, 0.5 , 3.5 ],\n       [0.75, 0.5 , 4.  ],\n       [0.75, 0.5 , 4.5 ]])\n\nRead an ANSYS workbench input file\n\n>>> my_archive = pymapdl_reader.Archive('C:\\Users\\user\\stuff.dat')\n\nNotes\n\nThis class only reads EBLOCK records with SOLID records.  For\nexample, the record EBLOCK,19,SOLID,,3588 will be read, but\nEBLOCK,10,,,3588 will not be read.  Generally, MAPDL will only\nwrite SOLID records and Mechanical Workbench may write SOLID\nrecords.  These additional records will be ignored.\n\n\n\nproperty ekey\n\nElement type key\n\nArray containing element type numbers in the first column and\nthe element types (like SURF154) in the second column.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.ekey\narray([[  1,  45],\n       [  2,  95],\n       [  3,  92],\n       [ 60, 154]], dtype=int32)\n\n\n\nproperty elem\n\nList of elements containing raw ansys information.\n\nEach element contains 10 items plus the nodes belonging to the\nelement.  The first 10 items are:\n\nFIELD 0 : material reference number\n\nFIELD 1 : element type number\n\nFIELD 2 : real constant reference number\n\nFIELD 3 : section number\n\nFIELD 4 : element coordinate system\n\nFIELD 5 : death flag (0 - alive, 1 - dead)\n\nFIELD 6 : solid model reference\n\nFIELD 7 : coded shape key\n\nFIELD 8 : element number\n\nFIELD 9 : base element number (applicable to reinforcing elements only)\n\nFIELDS 10 - 30 : The nodes belonging to the element in ANSYS numbering.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem\n[array([  1,   4,  19,  15,  63,  91, 286, 240,   3,  18,  17,\n         16,  81, 276, 267, 258,  62,  90, 285, 239],\n array([  4,   2,   8,  19,  91,  44, 147, 286,   5,   7,  21,\n         18, 109, 137, 313, 276,  90,  43, 146, 285],\n array([ 15,  19,  12,  10, 240, 286, 203, 175,  17,  20,  13,\n         14, 267, 304, 221, 230, 239, 285, 202, 174],\n...\n\n\n\nproperty elem_real_constant\n\nReal constant reference for each element.\n\nUse the data within rlblock and rlblock_num to get the\nreal constant datat for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem_real_constant\narray([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        ...,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 61, 61, 61, 61,\n       61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n       61], dtype=int32)\n\n\n\nproperty element_components\n\nElement components for the archive.\n\nOutput is a dictionary of element components.  Each entry is an\narray of MAPDL element numbers corresponding to the element\ncomponent.  The keys are element component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_components\n{'ECOMP1 ': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n                   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n                   dtype=int32),\n'ECOMP2 ': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n                  14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32)}\n\n\n\nelement_coord_system()\n\nElement coordinate system number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_coord_system\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0], dtype=int32)\n\n\n\nproperty enum\n\nANSYS element numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.enum\narray([    1,     2,     3, ...,  9998,  9999, 10000])\n\n\n\nproperty et_id\n\nElement type id (ET) for each element.\n\n\n\nproperty etype\n\nElement type of each element.\n\nThis is the ansys element type for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.etype\narray([ 45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n        45,  45,  45,  45,  45,  45,  45,  45,  92,  92,  92,\n        92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,\n        ...,\n        92,  92,  92,  92,  92, 154, 154, 154, 154, 154, 154,\n       154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n       154], dtype=int32)\n\nNotes\n\nElement types are listed below.  Please see the APDL Element\nReference for more details:\n\nhttps://www.mm.bme.hu/~gyebro/files/vem/ansys_14_element_reference.pdf\n\n\n\nproperty filename: str\n\nString form of the filename. This property is read-only.\n\n\n\nproperty grid\n\nReturn a pyvista.UnstructuredGrid of the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.grid\nUnstructuredGrid (0x7ffa237f08a0)\n  N Cells:      40\n  N Points:     321\n  X Bounds:     0.000e+00, 1.000e+00\n  Y Bounds:     0.000e+00, 1.000e+00\n  Z Bounds:     0.000e+00, 5.000e+00\n  N Arrays:     13\n\n\n\nproperty key_option\n\nAdditional key options for element types\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.key_option\n{1: [[1, 11]]}\n\n\n\nproperty material_type\n\nMaterial type index of each element in the archive.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.material_type\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1], dtype=int32)\n\n\n\nproperty n_elem\n\nNumber of nodes\n\n\n\nproperty n_node\n\nNumber of nodes\n\n\n\nproperty nnum\n\nArray of node numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nnum\narray([    1,     2,     3, ..., 19998, 19999, 20000])\n\n\n\nproperty node_angles\n\nNode angles from the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n ...,\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]]\n\n\n\nproperty node_components\n\nNode components for the archive.\n\nOutput is a dictionary of node components.  Each entry is an\narray of MAPDL node numbers corresponding to the node\ncomponent.  The keys are node component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.node_components\n{'NCOMP2  ': array([  1,   2,   3,   4,   5,   6,   7,   8,\n                     14, 15, 16, 17, 18, 19, 20, 21, 43, 44,\n                     62, 63, 64, 81, 82, 90, 91, 92, 93, 94,\n                     118, 119, 120, 121, 122, 123, 124, 125,\n                     126, 137, 147, 148, 149, 150, 151, 152,\n                     153, 165, 166, 167, 193, 194, 195, 202,\n                     203, 204, 205, 206, 207, 221, 240, 258,\n                     267, 268, 276, 277, 278, 285, 286, 287,\n                     304, 305, 306, 313, 314, 315, 316\n                     ], dtype=int32),\n...,\n}\n\n\n\nproperty nodes\n\nArray of nodes.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [1.   0.   0.  ]\n [0.25 0.   0.  ]\n ...,\n [0.75 0.5  3.5 ]\n [0.75 0.5  4.  ]\n [0.75 0.5  4.5 ]]\n\n\n\nproperty parameters\n\nParameters stored in the archive file\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile,\n                                     read_parameters=True)\n>>> archive.parameters\n{}\n\n\n\nproperty pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nplot(off_screen: bool | None = None, full_screen: bool | None = None, screenshot: str | bool | None = None, interactive: bool = True, cpos: CameraPositionOptions | None = None, window_size: list[int] | None = None, show_bounds: bool = False, show_axes: bool | None = None, notebook: bool | None = None, background: ColorLike | None = None, text: str = '', return_img: bool = False, eye_dome_lighting: bool = False, volume: bool = False, parallel_projection: bool = False, jupyter_backend: JupyterBackendOptions | None = None, return_viewer: bool = False, return_cpos: bool = False, jupyter_kwargs: dict | None = None, theme: Theme | None = None, anti_aliasing: Literal['ssaa', 'msaa', 'fxaa'] | bool | None = None, zoom: str | float | None = None, border: bool = False, border_color: ColorLike = 'k', border_width: float = 2.0, ssao: bool = False, **kwargs)\n\nPlot a PyVista, numpy, or vtk object.\n\nAdded in version 0.47: plot can be invoked with the shell command:Run pyvista plot --help for more details on available parameters.Providing multiple files renders them inside the same window.\n\nParameters\n\nvar_item (pyvista.DataSet) – See Plotter.add_mesh for all\nsupported types.\n\noff_screen\n\nbool, optional\n\nPlots off screen when True.  Helpful for saving\nscreenshots without a window popping up.  Defaults to the\nglobal setting pyvista.OFF_SCREEN.\n\nfull_screen\n\nbool, default: pyvista.plotting.themes.Theme.full_screen\n\nOpens window in full screen.  When enabled, ignores\nwindow_size.\n\nscreenshot\n\nstr | bool, optional\n\nSaves screenshot to file when enabled.  See:\nPlotter.screenshot().\nDefault False.\n\nWhen True, takes screenshot and returns numpy array of\nimage.\n\ninteractive\n\nbool, default: pyvista.plotting.themes.Theme.interactive\n\nAllows user to pan and move figure.\n\ncpos\n\nCameraPositionOptions, optional\n\nList of camera position, focal point, and view up.\nSee the pyvista.Plotter.camera_position for concrete examples\non how to use this parameter and cameras_api for a detailed\ndocumentation on pyvista.Camera.\n\nwindow_size\n\nlist[int], default: pyvista.plotting.themes.Theme.window_size\n\nWindow size in pixels.\n\nshow_bounds\n\nbool, default: False\n\nShows mesh bounds when True.\n\nshow_axes\n\nbool, default: pyvista.plotting.themes._AxesConfig.show\n\nShows a vtk axes widget.\n\nnotebook\n\nbool, default: pyvista.plotting.themes.Theme.notebook\n\nWhen True, the resulting plot is placed inline a jupyter\nnotebook.  Assumes a jupyter console is active.\n\nbackground\n\nColorLike, default: pyvista.plotting.themes.Theme.background\n\nColor of the background.\n\ntext\n\nstr, optional\n\nAdds text at the bottom of the plot.\n\nreturn_img\n\nbool, default: False\n\nReturns numpy array of the last image rendered.\n\neye_dome_lighting\n\nbool, optional\n\nEnables eye dome lighting.\n\nvolume\n\nbool, default: False\n\nUse the Plotter.add_volume() method for volume rendering.\n\nparallel_projection\n\nbool, default: False\n\nEnable parallel projection.\n\njupyter_backend\n\nJupyterBackendOptions, optional\n\nJupyter notebook plotting backend to use.\nSee available documentation at pyvista.set_jupyter_backend()\nto see all valid values for this parameter along with a detailed documentation.\n\nDefaults to pyvista.plotting.themes.Theme.jupyter_backend\n\nreturn_viewer\n\nbool, default: False\n\nReturn the jupyterlab viewer, scene, or display object\nwhen plotting with jupyter notebook.\n\nreturn_cpos\n\nbool, default: False\n\nReturn the last camera position from the render window\nwhen enabled.  Defaults to value in theme settings.\n\njupyter_kwargs\n\ndict, optional\n\nKeyword arguments for the Jupyter notebook plotting backend.\nSee customize_trame_toolbar_example for an example\nusing this keyword.\n\ntheme\n\npyvista.plotting.themes.Theme, optional\n\nPlot-specific theme.\n\nanti_aliasing\n\nLiteral[‘ssaa’, ‘msaa’, ‘fxaa’] | bool, optional\n\nEnable or disable anti-aliasing. If True, uses \"msaa\". If False,\ndisables anti_aliasing. If a string, should be one of the following:\n\n\"ssaa\" - Super-Sample Anti-Aliasing\n\n\"msaa\" - Multi-Sample Anti-Aliasing\n\n\"fxaa\" - Fast Approximate Anti-Aliasing\n\nDefaults to pyvista.plotting.themes.Theme.anti_aliasing\n\nzoom\n\nfloat | str, optional\n\nCamera zoom.  Either 'tight' or a float. A value greater than 1\nis a zoom-in, a value less than 1 is a zoom-out.  Must be greater\nthan 0.\n\nborder\n\nbool, default: False\n\nDraw a border around each render window.\n\nborder_color\n\nColorLike, default: “k”\n\nEither a string, rgb list, or hex color string.  For example:\n\ncolor='white'\n\ncolor='w'\n\ncolor=[1.0, 1.0, 1.0]\n\ncolor='#FFFFFF'\n\nborder_width\n\nfloat, default: 2.0\n\nWidth of the border in pixels when enabled.\n\nssao\n\nbool, optional\n\nEnable surface space ambient occlusion (SSAO). See\nPlotter.enable_ssao() for more details.\n\n**kwargs\n\ndict, optional\n\nSee pyvista.Plotter.add_mesh() for additional options.\n\nReturns\n\ncpos (list) – List of camera position, focal point, and view up.\nReturned only when return_cpos=True or set in the\ndefault global or plot theme.  Not returned when in a\njupyter notebook and return_viewer=True.\n\nimage (np.ndarray) – Numpy array of the last image when either return_img=True\nor screenshot=True is set. Not returned when in a\njupyter notebook with return_viewer=True. Optionally\ncontains alpha values. Sized:\n\n[Window height x Window width x 3] if the theme sets\ntransparent_background=False.\n\n[Window height x Window width x 4] if the theme sets\ntransparent_background=True.\n\nwidget (ipywidgets.Widget) – IPython widget when return_viewer=True.\n\nExamples\n\nPlot a simple sphere while showing its edges.\n\n>>> import pyvista as pv\n>>> mesh = pv.Sphere()\n>>> mesh.plot(show_edges=True)\n\nPlot a volume mesh. Color by distance from the center of the\nImageData. Note volume=True is passed.\n\n>>> import numpy as np\n>>> grid = pv.ImageData(dimensions=(32, 32, 32), spacing=(0.5, 0.5, 0.5))\n>>> grid['data'] = np.linalg.norm(grid.center - grid.points, axis=1)\n>>> grid['data'] = np.abs(grid['data'] - grid['data'].max()) ** 3\n>>> grid.plot(volume=True)\n\n\n\nproperty quality\n\nMinimum scaled jacobian cell quality.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.quality\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n\n\n\nproperty rlblock\n\nReal constant data from the RLBLOCK.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rlblock\n[[0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.02 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.01 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005]]\n\n\n\nproperty rlblock_num\n\nIndices from the real constant data\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rnum\narray([60, 61, 62, 63])\n\n\n\nsave(filename, binary=True, force_linear=False, allowable_types=[], null_unallowed=False)\n\nSave the geometry as a vtk file\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of output file. Writer type is inferred from\nthe extension of the filename.\n\nbinary (bool, optional) – If True, write as binary, else ASCII.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nExamples\n\n>>> geom.save('mesh.vtk')\n\nNotes\n\nBinary files write much faster than ASCII and have a smaller\nfile size.\n\n\n\nproperty section\n\nSection number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.section\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1], dtype=int32)\n\n\n\nproperty tshape\n\nTshape of contact elements.\n\n\n\nproperty tshape_key\n\nDict with the mapping between element type and element shape.\n\nTShape is only applicable to contact elements."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.ekey","title":"Reading and Writing Mapdl Archive Files > Archive Class > ekey","text":"property ekey\n\nElement type key\n\nArray containing element type numbers in the first column and\nthe element types (like SURF154) in the second column.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.ekey\narray([[  1,  45],\n       [  2,  95],\n       [  3,  92],\n       [ 60, 154]], dtype=int32)"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.elem","title":"Reading and Writing Mapdl Archive Files > Archive Class > elem","text":"property elem\n\nList of elements containing raw ansys information.\n\nEach element contains 10 items plus the nodes belonging to the\nelement.  The first 10 items are:\n\nFIELD 0 : material reference number\n\nFIELD 1 : element type number\n\nFIELD 2 : real constant reference number\n\nFIELD 3 : section number\n\nFIELD 4 : element coordinate system\n\nFIELD 5 : death flag (0 - alive, 1 - dead)\n\nFIELD 6 : solid model reference\n\nFIELD 7 : coded shape key\n\nFIELD 8 : element number\n\nFIELD 9 : base element number (applicable to reinforcing elements only)\n\nFIELDS 10 - 30 : The nodes belonging to the element in ANSYS numbering.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem\n[array([  1,   4,  19,  15,  63,  91, 286, 240,   3,  18,  17,\n         16,  81, 276, 267, 258,  62,  90, 285, 239],\n array([  4,   2,   8,  19,  91,  44, 147, 286,   5,   7,  21,\n         18, 109, 137, 313, 276,  90,  43, 146, 285],\n array([ 15,  19,  12,  10, 240, 286, 203, 175,  17,  20,  13,\n         14, 267, 304, 221, 230, 239, 285, 202, 174],\n..."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.elem_real_constant","title":"Reading and Writing Mapdl Archive Files > Archive Class > elem_real_constant","text":"property elem_real_constant\n\nReal constant reference for each element.\n\nUse the data within rlblock and rlblock_num to get the\nreal constant datat for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.elem_real_constant\narray([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n        ...,\n        1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 61, 61, 61, 61,\n       61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n       61], dtype=int32)"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.element_components","title":"Reading and Writing Mapdl Archive Files > Archive Class > element_components","text":"property element_components\n\nElement components for the archive.\n\nOutput is a dictionary of element components.  Each entry is an\narray of MAPDL element numbers corresponding to the element\ncomponent.  The keys are element component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_components\n{'ECOMP1 ': array([17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n                   30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n                   dtype=int32),\n'ECOMP2 ': array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n                  14, 15, 16, 17, 18, 19, 20, 23, 24], dtype=int32)}"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.element_coord_system","title":"Reading and Writing Mapdl Archive Files > Archive Class > element_coord_system","text":"element_coord_system()\n\nElement coordinate system number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.element_coord_system\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0], dtype=int32)"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.enum","title":"Reading and Writing Mapdl Archive Files > Archive Class > enum","text":"property enum\n\nANSYS element numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.enum\narray([    1,     2,     3, ...,  9998,  9999, 10000])"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.et_id","title":"Reading and Writing Mapdl Archive Files > Archive Class > et_id","text":"property et_id\n\nElement type id (ET) for each element."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.etype","title":"Reading and Writing Mapdl Archive Files > Archive Class > etype","text":"property etype\n\nElement type of each element.\n\nThis is the ansys element type for each element.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.etype\narray([ 45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n        45,  45,  45,  45,  45,  45,  45,  45,  92,  92,  92,\n        92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,\n        ...,\n        92,  92,  92,  92,  92, 154, 154, 154, 154, 154, 154,\n       154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n       154], dtype=int32)\n\nNotes\n\nElement types are listed below.  Please see the APDL Element\nReference for more details:\n\nhttps://www.mm.bme.hu/~gyebro/files/vem/ansys_14_element_reference.pdf"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.filename","title":"Reading and Writing Mapdl Archive Files > Archive Class > filename","text":"property filename: str\n\nString form of the filename. This property is read-only."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.grid","title":"Reading and Writing Mapdl Archive Files > Archive Class > grid","text":"property grid\n\nReturn a pyvista.UnstructuredGrid of the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.grid\nUnstructuredGrid (0x7ffa237f08a0)\n  N Cells:      40\n  N Points:     321\n  X Bounds:     0.000e+00, 1.000e+00\n  Y Bounds:     0.000e+00, 1.000e+00\n  Z Bounds:     0.000e+00, 5.000e+00\n  N Arrays:     13"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.key_option","title":"Reading and Writing Mapdl Archive Files > Archive Class > key_option","text":"property key_option\n\nAdditional key options for element types\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.key_option\n{1: [[1, 11]]}"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.material_type","title":"Reading and Writing Mapdl Archive Files > Archive Class > material_type","text":"property material_type\n\nMaterial type index of each element in the archive.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.material_type\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1], dtype=int32)"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.n_elem","title":"Reading and Writing Mapdl Archive Files > Archive Class > n_elem","text":"property n_elem\n\nNumber of nodes"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.n_node","title":"Reading and Writing Mapdl Archive Files > Archive Class > n_node","text":"property n_node\n\nNumber of nodes"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.nnum","title":"Reading and Writing Mapdl Archive Files > Archive Class > nnum","text":"property nnum\n\nArray of node numbers.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nnum\narray([    1,     2,     3, ..., 19998, 19999, 20000])"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.node_angles","title":"Reading and Writing Mapdl Archive Files > Archive Class > node_angles","text":"property node_angles\n\nNode angles from the archive file.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n ...,\n [0.   0.   0.  ]\n [0.   0.   0.  ]\n [0.   0.   0.  ]]"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.node_components","title":"Reading and Writing Mapdl Archive Files > Archive Class > node_components","text":"property node_components\n\nNode components for the archive.\n\nOutput is a dictionary of node components.  Each entry is an\narray of MAPDL node numbers corresponding to the node\ncomponent.  The keys are node component names.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.node_components\n{'NCOMP2  ': array([  1,   2,   3,   4,   5,   6,   7,   8,\n                     14, 15, 16, 17, 18, 19, 20, 21, 43, 44,\n                     62, 63, 64, 81, 82, 90, 91, 92, 93, 94,\n                     118, 119, 120, 121, 122, 123, 124, 125,\n                     126, 137, 147, 148, 149, 150, 151, 152,\n                     153, 165, 166, 167, 193, 194, 195, 202,\n                     203, 204, 205, 206, 207, 221, 240, 258,\n                     267, 268, 276, 277, 278, 285, 286, 287,\n                     304, 305, 306, 313, 314, 315, 316\n                     ], dtype=int32),\n...,\n}"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.nodes","title":"Reading and Writing Mapdl Archive Files > Archive Class > nodes","text":"property nodes\n\nArray of nodes.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.nodes\n[[0.   0.   0.  ]\n [1.   0.   0.  ]\n [0.25 0.   0.  ]\n ...,\n [0.75 0.5  3.5 ]\n [0.75 0.5  4.  ]\n [0.75 0.5  4.5 ]]"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.parameters","title":"Reading and Writing Mapdl Archive Files > Archive Class > parameters","text":"property parameters\n\nParameters stored in the archive file\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile,\n                                     read_parameters=True)\n>>> archive.parameters\n{}"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.pathlib_filename","title":"Reading and Writing Mapdl Archive Files > Archive Class > pathlib_filename","text":"property pathlib_filename: Path\n\nReturn the pathlib.Path version of the filename. This property can not be set."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.plot","title":"Reading and Writing Mapdl Archive Files > Archive Class > plot","text":"plot(off_screen: bool | None = None, full_screen: bool | None = None, screenshot: str | bool | None = None, interactive: bool = True, cpos: CameraPositionOptions | None = None, window_size: list[int] | None = None, show_bounds: bool = False, show_axes: bool | None = None, notebook: bool | None = None, background: ColorLike | None = None, text: str = '', return_img: bool = False, eye_dome_lighting: bool = False, volume: bool = False, parallel_projection: bool = False, jupyter_backend: JupyterBackendOptions | None = None, return_viewer: bool = False, return_cpos: bool = False, jupyter_kwargs: dict | None = None, theme: Theme | None = None, anti_aliasing: Literal['ssaa', 'msaa', 'fxaa'] | bool | None = None, zoom: str | float | None = None, border: bool = False, border_color: ColorLike = 'k', border_width: float = 2.0, ssao: bool = False, **kwargs)\n\nPlot a PyVista, numpy, or vtk object.\n\nAdded in version 0.47: plot can be invoked with the shell command:Run pyvista plot --help for more details on available parameters.Providing multiple files renders them inside the same window.\n\nParameters\n\nvar_item (pyvista.DataSet) – See Plotter.add_mesh for all\nsupported types.\n\noff_screen\n\nbool, optional\n\nPlots off screen when True.  Helpful for saving\nscreenshots without a window popping up.  Defaults to the\nglobal setting pyvista.OFF_SCREEN.\n\nfull_screen\n\nbool, default: pyvista.plotting.themes.Theme.full_screen\n\nOpens window in full screen.  When enabled, ignores\nwindow_size.\n\nscreenshot\n\nstr | bool, optional\n\nSaves screenshot to file when enabled.  See:\nPlotter.screenshot().\nDefault False.\n\nWhen True, takes screenshot and returns numpy array of\nimage.\n\ninteractive\n\nbool, default: pyvista.plotting.themes.Theme.interactive\n\nAllows user to pan and move figure.\n\ncpos\n\nCameraPositionOptions, optional\n\nList of camera position, focal point, and view up.\nSee the pyvista.Plotter.camera_position for concrete examples\non how to use this parameter and cameras_api for a detailed\ndocumentation on pyvista.Camera.\n\nwindow_size\n\nlist[int], default: pyvista.plotting.themes.Theme.window_size\n\nWindow size in pixels.\n\nshow_bounds\n\nbool, default: False\n\nShows mesh bounds when True.\n\nshow_axes\n\nbool, default: pyvista.plotting.themes._AxesConfig.show\n\nShows a vtk axes widget.\n\nnotebook\n\nbool, default: pyvista.plotting.themes.Theme.notebook\n\nWhen True, the resulting plot is placed inline a jupyter\nnotebook.  Assumes a jupyter console is active.\n\nbackground\n\nColorLike, default: pyvista.plotting.themes.Theme.background\n\nColor of the background.\n\ntext\n\nstr, optional\n\nAdds text at the bottom of the plot.\n\nreturn_img\n\nbool, default: False\n\nReturns numpy array of the last image rendered.\n\neye_dome_lighting\n\nbool, optional\n\nEnables eye dome lighting.\n\nvolume\n\nbool, default: False\n\nUse the Plotter.add_volume() method for volume rendering.\n\nparallel_projection\n\nbool, default: False\n\nEnable parallel projection.\n\njupyter_backend\n\nJupyterBackendOptions, optional\n\nJupyter notebook plotting backend to use.\nSee available documentation at pyvista.set_jupyter_backend()\nto see all valid values for this parameter along with a detailed documentation.\n\nDefaults to pyvista.plotting.themes.Theme.jupyter_backend\n\nreturn_viewer\n\nbool, default: False\n\nReturn the jupyterlab viewer, scene, or display object\nwhen plotting with jupyter notebook.\n\nreturn_cpos\n\nbool, default: False\n\nReturn the last camera position from the render window\nwhen enabled.  Defaults to value in theme settings.\n\njupyter_kwargs\n\ndict, optional\n\nKeyword arguments for the Jupyter notebook plotting backend.\nSee customize_trame_toolbar_example for an example\nusing this keyword.\n\ntheme\n\npyvista.plotting.themes.Theme, optional\n\nPlot-specific theme.\n\nanti_aliasing\n\nLiteral[‘ssaa’, ‘msaa’, ‘fxaa’] | bool, optional\n\nEnable or disable anti-aliasing. If True, uses \"msaa\". If False,\ndisables anti_aliasing. If a string, should be one of the following:\n\n\"ssaa\" - Super-Sample Anti-Aliasing\n\n\"msaa\" - Multi-Sample Anti-Aliasing\n\n\"fxaa\" - Fast Approximate Anti-Aliasing\n\nDefaults to pyvista.plotting.themes.Theme.anti_aliasing\n\nzoom\n\nfloat | str, optional\n\nCamera zoom.  Either 'tight' or a float. A value greater than 1\nis a zoom-in, a value less than 1 is a zoom-out.  Must be greater\nthan 0.\n\nborder\n\nbool, default: False\n\nDraw a border around each render window.\n\nborder_color\n\nColorLike, default: “k”\n\nEither a string, rgb list, or hex color string.  For example:\n\ncolor='white'\n\ncolor='w'\n\ncolor=[1.0, 1.0, 1.0]\n\ncolor='#FFFFFF'\n\nborder_width\n\nfloat, default: 2.0\n\nWidth of the border in pixels when enabled.\n\nssao\n\nbool, optional\n\nEnable surface space ambient occlusion (SSAO). See\nPlotter.enable_ssao() for more details.\n\n**kwargs\n\ndict, optional\n\nSee pyvista.Plotter.add_mesh() for additional options.\n\nReturns\n\ncpos (list) – List of camera position, focal point, and view up.\nReturned only when return_cpos=True or set in the\ndefault global or plot theme.  Not returned when in a\njupyter notebook and return_viewer=True.\n\nimage (np.ndarray) – Numpy array of the last image when either return_img=True\nor screenshot=True is set. Not returned when in a\njupyter notebook with return_viewer=True. Optionally\ncontains alpha values. Sized:\n\n[Window height x Window width x 3] if the theme sets\ntransparent_background=False.\n\n[Window height x Window width x 4] if the theme sets\ntransparent_background=True.\n\nwidget (ipywidgets.Widget) – IPython widget when return_viewer=True.\n\nExamples\n\nPlot a simple sphere while showing its edges.\n\n>>> import pyvista as pv\n>>> mesh = pv.Sphere()\n>>> mesh.plot(show_edges=True)\n\nPlot a volume mesh. Color by distance from the center of the\nImageData. Note volume=True is passed.\n\n>>> import numpy as np\n>>> grid = pv.ImageData(dimensions=(32, 32, 32), spacing=(0.5, 0.5, 0.5))\n>>> grid['data'] = np.linalg.norm(grid.center - grid.points, axis=1)\n>>> grid['data'] = np.abs(grid['data'] - grid['data'].max()) ** 3\n>>> grid.plot(volume=True)"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.quality","title":"Reading and Writing Mapdl Archive Files > Archive Class > quality","text":"property quality\n\nMinimum scaled jacobian cell quality.\n\nNegative values indicate invalid cells while positive values\nindicate valid cells.  Varies between -1 and 1.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.quality\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.rlblock","title":"Reading and Writing Mapdl Archive Files > Archive Class > rlblock","text":"property rlblock\n\nReal constant data from the RLBLOCK.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rlblock\n[[0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.02 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.01 ],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005],\n [0.   , 0.   , 0.   , 0.   , 0.   , 0.   , 0.005]]"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.rlblock_num","title":"Reading and Writing Mapdl Archive Files > Archive Class > rlblock_num","text":"property rlblock_num\n\nIndices from the real constant data\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.rnum\narray([60, 61, 62, 63])"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.save","title":"Reading and Writing Mapdl Archive Files > Archive Class > save","text":"save(filename, binary=True, force_linear=False, allowable_types=[], null_unallowed=False)\n\nSave the geometry as a vtk file\n\nParameters\n\nfilename (str, pathlib.Path) – Filename of output file. Writer type is inferred from\nthe extension of the filename.\n\nbinary (bool, optional) – If True, write as binary, else ASCII.\n\nforce_linear (bool, optional) – This parser creates quadratic elements if available.  Set\nthis to True to always create linear elements.  Defaults\nto False.\n\nallowable_types (list, optional) – Allowable element types.  Defaults to all valid element\ntypes in ansys.mapdl.reader.elements.valid_typesSee help(ansys.mapdl.reader.elements) for available element types.\n\nnull_unallowed (bool, optional) – Elements types not matching element types will be stored\nas empty (null) elements.  Useful for debug or tracking\nelement numbers.  Default False.\n\nExamples\n\n>>> geom.save('mesh.vtk')\n\nNotes\n\nBinary files write much faster than ASCII and have a smaller\nfile size."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.section","title":"Reading and Writing Mapdl Archive Files > Archive Class > section","text":"property section\n\nSection number\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> from ansys.mapdl.reader import examples\n>>> archive = pymapdl_reader.Archive(examples.hexarchivefile)\n>>> archive.section\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1], dtype=int32)"},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.tshape","title":"Reading and Writing Mapdl Archive Files > Archive Class > tshape","text":"property tshape\n\nTshape of contact elements."},{"objectID":"Home","href":"user_guide/archive.html#ansys.mapdl.reader.archive.Archive.tshape_key","title":"Reading and Writing Mapdl Archive Files > Archive Class > tshape_key","text":"property tshape_key\n\nDict with the mapping between element type and element shape.\n\nTShape is only applicable to contact elements."},{"objectID":"Home","href":"api/emat.html#element-matrix-class","title":"Element Matrix Class","text":"Element Matrix Class\n\n\n\nclass ansys.mapdl.reader.emat.EmatFile(filename)\n\nEnables pythonic access to an ANSYS element matrix file.\n\nParameters\n\nfilename (str, pathlib.Path) – File to open.  Generally ends in *.emat.\n\nExamples\n\n>>> from ansys.mapdl import reader as pymapdl_reader\n>>> emat_file = pymapdl_reader.read_binary('file.emat')\n\n\n\nproperty eeqv\n\nElement equivalence table.  This table equates the number\nused for storage to the actual element number.\n\nNotes\n\nThe ANSYS program stores all element data in the numerical\norder that the SOLUTION processor solves the elements.  This\ntable equates the order number used to the actual element.\n\n\n\nproperty element_matrices_index_table\n\nReturn element matrices index table\n\n\n\nproperty enum\n\nSorted ANSYS element numbers\n\n\n\nproperty filename\n\nString form of the filename. This property is read-only.\n\n\n\nglobal_applied_force()\n\nReturns the applied force for each node.\n\nReturns\n\napplied_force – Applied force with size (n_nodes, n_dof).  Result is\nsorted to correspond with the sorted global nodes array.\n\nReturn type\n\nnp.ndarray\n\n\n\nproperty n_dof\n\nNumber of dofs per node\n\n\n\nproperty n_elements\n\nNumber of elements in the file\n\n\n\nproperty n_nodes\n\nNumber of nodes in the file\n\n\n\nproperty neqv\n\nNodal equivalence table. This table equates the number used\nfor storage to the actual node number.\n\n\n\nproperty nnum\n\nSorted ANSYS node numbers\n\n\n\nproperty pathlib_filename\n\nReturn the pathlib.Path version of the filename. This property can not be set.\n\n\n\nread_element(index, stress=True, mass=True, damping=True, stress_stiff=True, applied_force=True, newton_raphson=True, imaginary_load=True)\n\nRead element by index\n\nParameters\n\nindex (int) – Element index.  This is not the element number.  Reference\nthe element equivalency table for the actual element\nnumber.\n\nstress (bool, optional) – Return the stress matrix entries if available.\n\nmass (bool, optional) – Return the mass matrix entries if available.\n\ndamping (bool, optional) – Return the damping matrix entries if available.\n\nstress_stiff (bool, optional) – Return the stress stiffening entries if available.\n\nnewton_raphson (bool, optional) – Return the newton raphson load entries if available.\n\napplied_force (bool, optional) – Return the applied load vector if available.\n\nimaginary_load (bool, optional) – Return the imaginary load vector if available.\n\nReturns\n\ndof_idx (np.ndarray) – DOF index table. This record specifies the DOF locations\nof this element matrix in relation to the global\nmatrix. The index is calculated as (N-1)*NUMDOF+DOF, where\nN is the position number of the node in the nodal\nequivalence table and DOF is the DOF reference number\ngiven above\n\nelement_data (dict) – Dictionary containing the following entries for each of\nthe corresponding inputs when the item is True.\n- ‘stress’ : stress matrix entries\n- ‘mass’ : mass matrix entries\n- ‘damping’ : damping matrix entries\n- ‘stress_stiff’ : stress stiffening matrix entries\n- ‘newton_raphson’ : newton rapson load vector\n- ‘applied_force’ : applied force vector\n- ‘imaginary_load’ : imaginary load vector\n\nNotes\n\nIf the matrix is diagonal, the length of the records will be\nnmrow.  If the matrix is unsymmetric, the length of the\nrecords will be nmrow*nmrow. If the matrix is symmetric, only\nthe lower triangular terms are written and the length of the\nrecords will be (nmrow)*(nmrow+1)/2\n\nRecords are written relative to the dof_idx.  The index is\ncalculated as (N-1)*NUMDOF+DOF, where N is the position number\nof the node in the nodal equivalence table and DOF is the DOF\nreference number given by dof_idx.\n\n\n\nread_element_matrix_header(f_index)\n\nRead element matrix header\n\nParameters\n\nf_indes (int) – Fortran index to the start of the element matrix header.\n\nNotes\n\nstkey - stiffness matrix key\n\n0 - matrix not present\n1 - matrix present\n\nmkey - mass matrix key\n\n0 - matrix not present\n1 - matrix present\n\ndkey - damping matrix key\n\n0 - matrix not present\n1 - matrix present\n\nsskey - stress stiffening matrix key\n\n0 - matrix not present\n1 - matrix present\n\nakey - applied load vector key\n\n0 - vector not used\n1 - vector used\n\nnrkey - newton-raphson(restoring) load\n\n0 - vector not used\n1 - vector used\n\nikey - imaginary load vector key (for complex analyses)\n\n0 - vector not used\n1 - vector used\n\nnmrow - numbers/columns in matrices.\n\nIf the number is negative, the matrices will be written in\nlower triangular form.\n\n\n\nread_header()\n\nRead standard emat file header"},{"objectID":"Home","href":"examples/01-cyclic_results/index.html#cyclic-result-analysis","title":"Cyclic Result Analysis","text":"Cyclic Result Analysis\n\nThe following examples demonstrate how to load results from and\ndirectly analyze MAPDL result files from a cyclic analysis.\n\n/examples/01-cyclic_results/academic_sector_nd\n\n/examples/01-cyclic_results/academic_sector_stress_strain\n\n/examples/01-cyclic_results/sector_model\n\n"},{"objectID":"Contribute","href":"contributing.html#contribute","title":"Contribute","text":"Contribute\n\nOverall guidance on contributing to a PyAnsys library appears in the\nContributing topic\nin the PyAnsys Developer’s Guide. Ensure that you are thoroughly familiar\nwith it and all Guidelines and Best Practices\nbefore attempting to contribute to PyMAPDL-Reader.\n\nThe following contribution information is specific to PyMAPDL-Reader."},{"objectID":"Contribute","href":"contributing.html#cloning-the-pymapdl-reader-repository","title":"Contribute > Cloning the PyMAPDL Reader Repository","text":"Cloning the PyMAPDL Reader Repository\n\nRun this code to clone and install the latest version of PyMAPDL-Reader in development mode:"},{"objectID":"Contribute","href":"contributing.html#posting-issues","title":"Contribute > Posting Issues","text":"Posting Issues\n\nUse the PyMAPDL-Reader Issues\npage to submit questions, report bugs, and request new features.\n\nTo reach the project support team, email pyansys.core@ansys.com."},{"objectID":"Contribute","href":"contributing.html#viewing-pymapdl-reader-documentation","title":"Contribute > Viewing PyMAPDL-Reader Documentation","text":"Viewing PyMAPDL-Reader Documentation\n\nDocumentation for the latest stable release of PyMAPDL-Reader is hosted at\nPyMAPDL-Reader Documentation."},{"objectID":"Computation times","href":"sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:37.409 total execution time for 8 files from all galleries:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nsphx_glr_examples_01-cyclic_results_academic_sector_nd.py (../../examples/01-cyclic_results/academic_sector_nd.py)\n\n00:13.882\n\n0.0\n\nsphx_glr_examples_00-read_binary_custom_visualization.py (../../examples/00-read_binary/custom_visualization.py)\n\n00:07.687\n\n0.0\n\nsphx_glr_examples_00-read_binary_load_shaft_result.py (../../examples/00-read_binary/load_shaft_result.py)\n\n00:06.411\n\n0.0\n\nsphx_glr_examples_01-cyclic_results_sector_model.py (../../examples/01-cyclic_results/sector_model.py)\n\n00:06.291\n\n0.0\n\nsphx_glr_examples_01-cyclic_results_academic_sector_stress_strain.py (../../examples/01-cyclic_results/academic_sector_stress_strain.py)\n\n00:01.111\n\n0.0\n\nsphx_glr_examples_00-read_binary_load_corner_result.py (../../examples/00-read_binary/load_corner_result.py)\n\n00:00.883\n\n0.0\n\nsphx_glr_examples_00-read_binary_pontoon.py (../../examples/00-read_binary/pontoon.py)\n\n00:00.682\n\n0.0\n\nsphx_glr_examples_00-read_binary_load_thermal_result.py (../../examples/00-read_binary/load_thermal_result.py)\n\n00:00.462\n\n0.0"},{"objectID":"Home","href":"examples/01-cyclic_results/sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:21.284 total execution time for 3 files from examples/01-cyclic_results:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nsphx_glr_examples_01-cyclic_results_academic_sector_nd.py (academic_sector_nd.py)\n\n00:13.882\n\n0.0\n\nsphx_glr_examples_01-cyclic_results_sector_model.py (sector_model.py)\n\n00:06.291\n\n0.0\n\nsphx_glr_examples_01-cyclic_results_academic_sector_stress_strain.py (academic_sector_stress_strain.py)\n\n00:01.111\n\n0.0"},{"objectID":"Home","href":"examples/00-read_binary/custom_visualization.html#custom-scalar-visualization","title":"Custom Scalar Visualization","text":"Custom Scalar Visualization\n\nDisplay custom scalars using an existing mesh.\n\nEach result file contains both a mesh property and a grid\nproperty.  The mesh property can be through as the MAPDL\nrepresentation of the FEM while the grid property can be through\nof the Python visualizing property used to plot within Python."},{"objectID":"Home","href":"examples/00-read_binary/custom_visualization.html#plotting","title":"Custom Scalar Visualization > Plotting","text":"Plotting\n\nThe grid instance is a pyvista.UnstructuredGrid part of the pyvista library.  This class allows for advanced\nplotting using VTK in just a few lines of code.  For example, you can plot\nthe underlying mesh with:\n\n"},{"objectID":"Home","href":"examples/00-read_binary/custom_visualization.html#plotting-node-scalars","title":"Custom Scalar Visualization > Plotting Node Scalars","text":"Plotting Node Scalars\n\nIf you point-wise or cell-wise scalars (nodes and elements in FEA),\nyou can plot these scalars by setting the scalars= parameter.\nHere, I’m simply using the x location of the nodes to color the\nmesh.\n\nIt follows that you can use any set of scalars provided that it\nmatches the number of nodes in the unstructured grid or the number\nof cells in the unstructured grid.  Here, we’re plotting node values.\n\n"},{"objectID":"Home","href":"examples/00-read_binary/custom_visualization.html#plotting-with-missing-values","title":"Custom Scalar Visualization > Plotting With Missing Values","text":"Plotting With Missing Values\n\nIf you do not have values for every node (for example, the midside\nnodes), you can leave these values as NAN and the plotter will take\ncare of plotting only the real values.\n\nFor example, if you have calculated strain scalars that are only\navailable at certain nodes, you can still plot those.  This example\njust nulls out the first 2000 nodes to be able to visualize the\nmissing values.  If your are just missing midside values, your plot\nwill not show the missing values since pyvista only plots the edge\nnodes.\n\n\n\nTotal running time of the script: (0 minutes 7.687 seconds)\n\n\n\nDownload Jupyter notebook: custom_visualization.ipynb\n\nDownload Python source code: custom_visualization.py\n\nDownload zipped: custom_visualization.zip\n\nGallery generated by Sphinx-Gallery"}]